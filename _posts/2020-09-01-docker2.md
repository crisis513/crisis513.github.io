---
layout: post
title: "[Docker] 도커 이미지 및 볼륨"
date: 2020-09-01
desc: "[Docker] 도커 이미지 및 볼륨"
keywords: "son,blog,cccr,docker,image,volume"
categories: [Cccr]
tags: [son,blog,cccr,docker,image,volume]
icon: icon-html
---



---

### 목차

[1. 도커 이미지 ](#list1)

[&nbsp;&nbsp; 1.1. 도커 허브(docker hub)](#list1_1)

[&nbsp;&nbsp; 1.2. ](#list1_2)

[2. 도커 볼륨](#list2)

---

[실습환경참고](http://crisis513.github.io/cccr/2020/09/01/docker1.html#list2)

---

## <span style="color:purple">**1. 도커 이미지**</span>   <a name="list1"></a>

<br>

- **도커 허브(docker hub)**

    - 도커의 기본 이미지 저장소

    - 도커 허브에서 이미지를 검색하거나 특정 이미지를 사용하여 컨테이너를 실행하는 방법에 대해 알 수 있다.

    - 도커 허브의 기본적인 기능 : 이미지의 공유

    - 도커 허브에 저장된 이미지의 이름 "저장소 이름:태그" 형태

    - **실습**

        1. docker search   → 이미지 검색
        
            ```bash
            [user@docker ~]$ docker search centos
            ```

        2. docker pull    → 이미지를 다운로드할 때 사용

            ```bash
            [user@docker ~]$ docker pull centos
            [user@docker ~]$ docker pull centos:7
            [user@docker ~]$ docker pull mysql:5.7
            ```
        
        3. docker image   → 이미지 목록 나열
        
            ```bash
            [user@docker ~]$ docker images
            [user@docker ~]$ docker image ls
            ```

        4. docker rmi     → 이미지 삭제
        
            ```bash
            [user@docker ~]$ docker image rm hello-world:latest
            [user@docker ~]$ docker rmi hello-world:latest
        
            → 컨테이너가 있으면 삭제되지 않음 

            [user@docker ~]$ docker rmi mysql:5.7

            -f 옵션 → 권장하지 않음
            [user@docker ~]$ docker rmi hello-world:latest -f
            ```
            
        5. docker inspect    → 도커 오브젝트의 정보를 자세히 확인할 때 사용

        6. 레이어가 여러 개인 이미지 다운로드 & 정보 확인
        
            ```bash
            [user@docker ~]$ docker pull httpd:latest
            [user@docker ~]$ docker inspect httpd:latest
            "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:d0f104dc0a1f9c744b65b23b3fd4d4d3236b4656e67f776fe13f8ad8423b955c",
                "sha256:c865989f86f7664a3ea0574f65b5a53822673d8dc246830b5a4017ed4f5c0022",
                "sha256:3ba8a4f66ba2e80ddd029ed0d36ff3609968cc78ab6fc801742b96fba019d916",
                "sha256:843c3701e6221c43cbd86dbe4f38de8cc172c56654a4096da531258408989048",
                "sha256:88b680b1fdfcc61598563dceba6638a7eb4f436d6ba5c51e54f3bc3bd12ab499"
                ]
            },
            ```

        7. docker save / load  → 호스트에 저장된 이미지를 아카이브로 복사/아카이브 파일 불러오기

            ```bash
            [user@docker ~]$ docker save -o img.tar centos:latest httpd:latest
            [user@docker ~]$ tar tf img.tar
            [user@docker ~]$ ls -l img.tar 
            -rw-------. 1 user user 393334272  8월 10 13:56 img.tar
            [user@docker ~]$ docker rmi centos:latest httpd:latest

            [user@docker ~]$ docker load -i img.tar
            [user@docker ~]$ docker images
            REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
            httpd               latest              a6ea92c35c43        4 days ago          166MB
            centos              latest              831691599b88        7 weeks ago         215MB
            ```

<br>

- **컨테이너 실행**

    - **실습 - 컨테이너 생성 및 확인**

        1. docker ps   → 컨테이너 목록 확인

            ```bash
            
            [user@docker ~]$ docker ps
            [user@docker ~]$ docker container ls

            [user@docker ~]$ docker ps -a
            ```
        
            → 현재 호스트에 존재하는 모든 컨테이너를 출력

        2. 이름이 web1인 컨테이너 생성

            ```bash
            [user@docker ~]$ docker create --name web1 httpd:latest
            ```

        3. 이름이 os1인 컨테이너 생성

            ```bash
            [user@docker ~]$ docker create -it --name os1 centos:latest 
            1457915352d8967c6a9c0d102481120b731329819d258144637302b321da2c3e
            ```

        4. web1 start

            ```bash
            [user@docker ~]$ docker start web1
            [user@docker ~]$ docker inspect web1 

            [user@docker ~]$ curl 172.17.0.2
            <html><body><h1>It works!</h1></body></html>
            ```

        5. os1 start

            ```bash
            [user@docker ~]$ docker start -ai os1
            [root@1457915352d8 /]#
            [root@1457915352d8 /]# exit
            exit
            [user@docker ~]$ docker ps
            CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES
            4a0638e6bea2        httpd:latest        "httpd-foreground"   15 minutes ago      Up 9 minutes        80/tcp              web1
            ```

        6. docker run 명령으로 web2 컨테이너 실행
        
            ```bash
            [user@docker ~]$ docker run -d --name web2 httpd:latest
            ```

        7. os2 컨테이너 실행
        
            ```bash
            [user@docker ~]$ docker run -it --name os2 centos:latest 
            [root@f20ddba876c2 /]#
            ```

        8. os3 컨테이너 실행하면서 hostname 명령 실행
        
            ```bash
            [user@docker ~]$ docker run --name os3 centos:latest hostname
            ```
        
            → hostname : 한번 실행하고 종료되는 프로세스 

        9. os4 컨테이너 실행 후 삭제
        
            ```bash
            [user@docker ~]$ docker run --name os4 --rm centos:latest hostname
            ```

        10. 컨테이너 삭제

            ```bash
            [user@docker ~]$ docker rm os3
            ```

        11. 실행되는 컨테이너 외 전부 삭제
        
            ```bash
            [user@docker ~]$ docker container prune
            [user@docker ~]$ docker ps -a
            CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES
            f20ddba876c2        centos:latest       "/bin/bash"          6 minutes ago       Up 6 minutes                            os2
            60c84d29c6dc        httpd:latest        "httpd-foreground"   6 minutes ago       Up 6 minutes        80/tcp              web2
            1457915352d8        centos:latest       "/bin/bash"          44 minutes ago      Up 30 minutes                           os1
            4a0638e6bea2        httpd:latest        "httpd-foreground"   47 minutes ago      Up 41 minutes       80/tcp              web1
            ```

        12. docker stats    → 컨테이너의 실시간 상태 확인
        
            ```bash
            [user@docker ~]$ docker stats 
            ```

    - **실습 - 컨테이너 중지 및 제거**

        1. os2 컨테이너 중지

            ```bash
            [user@docker ~]$ docker stop os2
            os2
            ```

        2. os2 컨테이너 삭제

            ```bash
            [user@docker ~]$ docker rm os2
            os2
            ```

        3. 실행중인 컨테이너 삭제
        
            ```bash
            [user@docker ~]$ docker rm os1 -f
            ```

    - **실습 - 컨테이너 실행 시 유용한 설정**

        1. 환경변수

            ```bash
            [user@docker ~]$ docker run -it --name os3 -e "LAB=docker" centos:latest
            [root@38b6ed0b4cdb /]# echo $LAB
            docker
            [root@38b6ed0b4cdb /]# exit
            ```

        2. cpu 제한
        
            ```bash
            [user@docker ~]$ docker run -it --name os3 --cpus 0.3 centos:latest
            → 30% 사용 제한 
            [root@c2df3a13921e /]# dd if=/dev/zero of=/dev/null &

            <새로운 터미널>
            $ ssh user@192.168.56.100
            [user@docker ~]$ docker stats 

            [root@c2df3a13921e /]# exit
            ```

        3. 메모리 제한

            ```bash
            [user@docker ~]$ docker run -itd --name os5 --memory 1024m centos:latest
            ```

        4. 자원 제한 변경

            ```bash
            [user@docker ~]$ docker update --memory 2048m os5

            [user@docker ~]$ docker update --cpus 0.05 os5
            os5
            [user@docker ~]$ docker attach os5
            [root@50c259122bc9 /]# dd if=/dev/zero of=/dev/null &

            → 터미널 cpu 확인 
            ```

- **컨테이너 접근 및 실행**

    1. docker attach 

        - 표준 입력, 표준 출력/에러를 포함하는 컨테이너에 연결 가능

    2. docker exec

        - 실행중인 컨테이너에서 명령을 실행 가능

- **컨테이너 프로세스 및 로그 확인**

    - 컨테이너에서 실행 중인 프로세스와 로그를 확인 가능

    1. docker top 

        - 컨테이너에서 실행되는 프로세스의 정보를 확인 가능

        - 리눅스의 ps 옵션을 그대로 사용 가능함

    2. docker logs

        - 컨테이너의 로그를 확인 가능

        - **실습**

            ```bash
            [user@docker ~]$ docker run -d --name db1 mysql:5.7
            [user@docker ~]$ docker logs db1
            2020-08-10 06:54:13+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified
            	You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD

            [user@docker ~]$ docker run --name db2 -e "MYSQL_ROOT_PASSWORD=1234" -d mysql:5.7
            ```

- **컨테이너에 파일 복사 및 확인**

    1. docker cp

        - 호스트 파일을 컨테이너로 복사 or 컨테이너의 파일을 호스트에 복사

        - **실습**

            ```bash
            [user@docker ~]$ docker cp /etc/passwd os5:/tmp
            [user@docker ~]$ docker exec os5 ls -l /tmp/passwd
            -rw-r--r--. 1 root root 2304 Aug 10 02:15 /tmp/passwd
            [user@docker ~]$ docker cp os5:/tmp/passwd /home/user/
            [user@docker ~]$ ls -l passwd
            -rw-r--r--. 1 user user 2304  8월 10 11:15 passwd
            ```

    2. docker diff 

        - 컨테이너에서의 파일의 변경 상태를 체크

        - **실습**

            ```bash
            [user@docker ~]$ docker diff os5
            C /tmp
            A /tmp/passwd
            ```

        - docker diff 명령으로 출력되는 파일의 상태

            - A : 파일이 추가됨

            - C : 파일이 변경됨

            - D : 파일이 삭제됨

---

**docker 볼륨**

- **도커에서 데이터 관리**

    - 기본적으로 컨테이너에 생성되는 모든 파일은 컨테이너 레이어에 저장됨

        → 컨테이너와 함께 삭제되는 런타임 데이터 

        → 이 데이터를 영구적으로 저장하려면 반드시 볼륨을 사용해야 함 

    1. Bind Mount

        - 초기 도커부터 사용했던 방식

        - 호스트의 특정 디렉토리와 컨테이너의 디렉토리를 연결하는 방식

        - 따로 기록하지 않으면 관리하기 쉽지 않음

        - 성능이 뛰어나지만 호스트의 파일 시스템에 대한 의존도가 높음

        - 호스트의 민감한 파일까지 접근할 수 있음으로 보안 측면인 문제가 발생 가능함

    2. 볼륨

        - 도커에 의해 관리되는 스토리지

        - docker 명령을 사용하여 생성 가능, 사용되지 않으면 한꺼번에 삭제 가능

        - 이미지의 Volumes 부분에 어떤 값이 지정되어 있는 경우, 컨테이너로 실행할 때 볼륨을 지정해야 함

        - 다양한 드라이버를 지원

- **Bind Mount 사용**

    - **실습**

        ```bash
        [user@docker ~]$ mkdir ~/bm1
        [user@docker ~]$ touch ~/bm1/fileA.txt

        [user@docker ~]$ docker run -dit --name os3 -v ~/bm1:/tmp/mount centos:latest

        [user@docker ~]$ docker exec os3 ls -l /tmp/mount
        total 0
        -rw-rw-r--. 1 1000 1000 0 Aug 10 07:23 fileA.txt

        [user@docker ~]$ sudo -i
        [sudo] user의 암호: 
        [root@docker ~]# cd /var/lib/docker/volumes/
        [root@docker volumes]# ls -l
        ```

- **볼륨 사용**

    - **실습**

        1. vol1 볼륨 생성

            ```bash
            [user@docker ~]$ docker volume create vol1
            [user@docker ~]$ docker inspect vol1 
            [
                {
                    "CreatedAt": "2020-08-10T16:28:04+09:00",
                    "Driver": "local",
                    "Labels": {},
                    "Mountpoint": "/var/lib/docker/volumes/vol1/_data",
                    "Name": "vol1",
                    "Options": {},
                    "Scope": "local"
                }
            ]

            [user@docker ~]$ sudo -i
            [root@docker ~]# cd /var/lib/docker/volumes/
            [root@docker volumes]# ls
            ```

        2. vol1 볼륨을 os4의 /tmp/volume에 연결

            ```bash
            [user@docker ~]$ docker run -itd --name os4 -v vol1:/tmp/volume centos:latest

            [user@docker ~]$ docker exec os4 ls -l /tmp/volume
            [user@docker ~]$ docker exec os4 touch /tmp/volume/fileB.txt

            [user@docker ~]$ sudo -i
            [root@docker ~]# cd /var/lib/docker/volumes/vol1/_data/
            [root@docker _data]# ls
            fileB.txt

            [root@docker _data]# exit
            logout
            [user@docker ~]$ docker attach os4
            [root@f083223357e9 /]# cd /tmp/volume/
            [root@f083223357e9 volume]# ls -l
            total 0
            -rw-r--r--. 1 root root 0 Aug 10 07:31 fileB.txt
            [root@f083223357e9 volume]# cat > index.html
            Hello World!

            [root@f083223357e9 volume]# read escape sequence (Ctrl + p + q)
            [user@docker ~]$ docker run -d --name web3 -v vol1:/usr/local/apache2/htdocs

            [user@docker ~]$ docker run -d --name web3 -v vol1:/usr/local/apache2/htdocs:ro httpd:latest
            [user@docker ~]$ docker inspect web3 | grep -i ipaddress
                        "SecondaryIPAddresses": null,
                        "IPAddress": "172.17.0.7",
                                "IPAddress": "172.17.0.7",
            [user@docker ~]$ curl 172.17.0.7
            Hello World! 
            ```
<br>