---
layout: post
title: "[Docker] 도커 개요"
date: 2020-09-01
desc: "도커 개요"
keywords: "son,blog,cccr,docker,vm"
categories: [Cccr]
tags: [son,blog,cccr,docker,vm]
icon: icon-html
---



---

### 목차

[1. 도커 개요](#list1)

[&nbsp;&nbsp; 1.1. 도커란?](#list1_1)

[&nbsp;&nbsp; 1.2. 가상머신과 컨테이너 비교](#list1_2)

[&nbsp;&nbsp; 1.3. 도커의 특징](#list1_3)

[&nbsp;&nbsp; 1.4. 도커의 구조 및 기능](#list1_4)

[&nbsp;&nbsp; 1.5. 도커의 핵심 기술](#list1_5)


---

<br>

## <span style="color:purple">**1. 도커 개요**</span>   <a name="list1"></a>

<br>

- **도커란?**   <a name="list1_1"></a>

    - **Go 언어로 개발**된 컨테이너 기반의 오픈소스 가상화 플랫폼

    - 다양한 OS 환경, 여러 프로그램들을 화물에 비유하여 컨테이너에 실어 여러 곳으로 운반하여 배포한다는 개념

<br>

- **가상머신과 컨테이너 비교**    <a name="list1_2"></a>

    | ![vm_vs_container](/static/assets/img/landing/vm_vs_container.png){: width="760" height="330"} |
    |:--:| 
    | [그림 1] 컨테이너(왼쪽) vs 가상머신(오른쪽) |
    
    <br>

    1. 가상머신(Virtual Machine)

        - `Host OS의 자원을 할당받아` 하이퍼바이저를 이용해 Guest OS를 가상화 하여 사용하는 방식

        - Host OS의 리소스 분할 또는 오버헤드와 OS 위에 또 OS를 설치하는 개념이기 때문에 `속도저하`의 단점이 존재

    2. 컨테이너(Container)

        - `Host OS를 공유`하며, 여러 개의 컨테이너들이 서로 영향을 미치지 않고 `독립적으로 실행`되어 `가벼움`

        - VM과의 가장 큰 차이점은 `프로세스를 격리` 하는 것
        
        - 독립적으로 Host OS의 자원을 공유하며 각각 필요한 자원들을 할당받아 실행되기 때문에 `오버헤드가 적음`
    
    즉, 가상 머신은 전체 하드웨어 서버를 추상화하는 반면 컨테이너는 운영 체제 커널을 추상화하여 **훨씬 더 빠르고 가벼운 인스턴스를 제공**합니다.

<br>

- **도커의 특징**   <a name="list1_3"></a>

    1. 서버를 코드 형태로 정의

        - **IaC(Infrastructure as Code)**
        
        - 이미지를 제작할 때 코드 형태로 정의하여 작성 가능

    2. **이식성(portability)**

        - 개발 환경, 테스트 환경, 서비스 환경을 모두 동일하게 사용 가능

        - 도커 컨테이너의 기반이 되는 `도커 이미지`가 있다면 애플리케이션을 동일한 환경에서 구동할 수 있다

    3. **상호운용성(interoperability)**

        - 다양한 벤더의 시스템 및 오픈소스와 연계하여 사용 가능

        - 예를 들어, 상용 Linux 중 가장 많이 쓰이는 RHEL7에서도 도커를 `기본으로 탑재`

        - AWS에서도 Amazon EC2 Container Service를 통해 도커 실행 환경 운영 서비스를 제공

<br>

- **도커의 구조 및 기능**   <a name="list1_4"></a>

    | ![docker_architecture](/static/assets/img/landing/docker_architecture.png){: width="760" height="390"} |
    |:--:| 
    | [그림 2] 도커 아키텍처 |

    <br>

    1. **도커 데몬(Docker Deamon)**
    
        - **도커 API 요청을 지속적으로 수신 및 처리**
        
        - 도커 이미지, 컨테이너, 네트워크 및 볼륨을 관리하는 지속적인 백그라운드 프로세스

    2. **도커 클라이언트(Docker Client)**
    
        - **도커 데몬과 상호 작용**하기 위한 CLI(Docker) 
        
        - 컨테이너 인스턴스 관리 방법이 단순함

        - docker commit, docker export, docker import 등의 도커 관련 명령이 존재

    3. **도커 레지스트리(Docker Registry)**

        - `도커 이미지를 저장`하기 위해 사용

        - 기본적으로 `Docker Hub`라는 퍼블릭 레지스트리로 설정되어 있고 `Harbor`와 같은 프라이빗 레지스트리도 사용 가능
    
    4. **도커 객체**
    
        - 이미지

            - 컨테이너를 생성하기 위한 `Read Only` 템플릿

            - 도커 이미지를 생성하고 실행하기 까지의 단계를 정의한 `Dockerfile`을 통해 빌드 가능

            - 새로운 컨테이너를 생성하면 변경된 레이어만 따로 체크하는 형태로 가볍고 빠름

        - 컨테이너

            - 이미지의 실행 형태, 이미지를 실행하여 메모리에 올려 동작하는 것

            - `하나의 컨테이너`에는 `하나의 애플리케이션`만 실행하는 것을 **권장**

            - 기본적으로 호스트 머신의 네트워크 연결을 통해 외부 네트워크와 연결 가능

        - 네트워크

            - 격리 되어 동작하는 모든 컨테이너가 통신하기 위한 통로로 사용되며 다음의 5 가지 네트워크 드라이버를 사용

                1) Bridge
                
                컨테이너의 `기본 네트워크 드라이버`입니다. 애플리케이션이 독립 실행형 컨테이너, 즉 동일한 도커 호스트와 통신하는 여러 컨테이너에서 실행될 때 이 네트워크를 사용합니다.

                2) Host
                
                이 드라이버는 도커 컨테이너와 도커 호스트 간의 `네트워크 격리를 제거`합니다. 호스트와 컨테이너간에 네트워크 격리가 필요하지 않을 때 사용할 수 있습니다.

                3) Overlay
                
                이 네트워크는 `Swarm 서비스가 서로 통신` 할 수 있도록합니다. 컨테이너가 다른 도커 호스트에서 실행되기를 원하거나 여러 애플리케이션에서 Swarm 서비스를 구성하려는 경우에 사용합니다.

                4) None
                
                이 드라이버는 **모든 네트워킹을 비활성화**합니다.

                5) macvlan

                이 드라이버는 `컨테이너에 MAC 주소를 할당`하여 물리 장치처럼 보이게합니다. **Mac 주소를 통해 컨테이너 간의 트래픽을 라우팅**합니다. 예를 들어, VM 설정을 마이그레이션하는 동안 컨테이너가 물리 장치처럼 보이게 하려는 경우에 이 네트워크를 사용합니다.

        - 서비스

            - 여러가지 도커 데몬들로 구성 및 확장 가능
            
            - `Docker Swarm`과 같은 서비스를 통해 사용자에게는 단일 애플리케이션처럼 보임

<br>

- **도커의 핵심 기술**   <a name="list1_5"></a>

    1. 네임스페이스(Namespace)

        - **서로가 충돌하지 않는 독립된 컨테이너를 제공하기 위해** 네임스페이스라는 기술을 적용
        
        - 리눅스에서는 다음 6 가지 네임스페이스를 지원
        
            1) mnt (파일시스템 마운트): 호스트 파일시스템에 구애받지 않고 독립적으로 파일시스템을 마운트하거나 언마운트 가능

            2) pid (프로세스): 독립적인 프로세스 공간을 할당

            3) net (네트워크): namespace간에 network 충돌 방지 (중복 포트 바인딩 등)

            4) ipc (SystemV IPC): 프로세스간의 독립적인 통신통로 할당

            5) uts (hostname): 독립적인 hostname 할당
            
            6) user (UID): 독립적인 사용자 할당

    2. cgroups(Control Groups)

        - **리소스에 대한 제어를 가능**하게 해주는 리눅스 커널의 기능

        - 도커 엔진(Docker Engine)이 사용 가능한 하드웨어 자원을 공유하도록 허용하거나 선택적으로 제한할 수 있음

        - 다음 리소스를 제어할 수 있음

            1) 메모리

            2) CPU

            3) I/O

            4) 네트워크

            5) device 노드(/dev/)

<br>
