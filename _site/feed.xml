<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>s6i</title>
    <description>s6i's blog, use Jekyll and github pages.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 26 Oct 2020 15:49:58 +0900</pubDate>
    <lastBuildDate>Mon, 26 Oct 2020 15:49:58 +0900</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - Jenkins와 Slack 연동 그리고 멀티 브랜치 파이프라인의 사용</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 클라우드 네이티브 환경에서 DevSecOps 툴 체인 파이프라인을 구축하는 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;9월에 시작하여 11월 27일까지 진행되고 현재 진행 중이며, 내용이 긴 만큼 여러 포스트를 나눠 기록하고자 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 포스트의 내용은 프로젝트 도중 작성되어 추후 변경될 수 있음을 알립니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. Jeknins와 Slack 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Slack 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Jenkins 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 멀티 브랜치 파이프라인 사용&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 멀티 브랜치 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 멀티 브랜치 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-jeknins와-slack-연동---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. Jeknins와 Slack 연동&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Slack 설정&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;먼저 Jenkins 파이프라인의 실행 결과에 대한 메시지를 받아보기 위해 Slack에서 사용할 워크스페이스와 채널을 생성해줍니다.&lt;/p&gt;

    &lt;p&gt;워스크페이스와 채널을 생성하고나면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://YOUR_WORKSPACE.slack.com/apps&lt;/code&gt; URL에 접속해서 Slack에 추가 할 앱으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins CI&lt;/code&gt;를 검색합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_1.png&quot; alt=&quot;add_jenkins_ci&quot; width=&quot;461&quot; height=&quot;435&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Jenkins CI 앱 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slack에 추가&lt;/code&gt; 버튼을 누르고 앞서 생성해둔 채널을 선택하여 해당 채널에서 Jenkins의 메시지를 받아 볼 수 있도록 설정합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_2.png&quot; alt=&quot;jenkins_ci_configure&quot; width=&quot;632&quot; height=&quot;569&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Jenkins CI 구성 편집&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 Jenkins CI 앱이 추가되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구성&lt;/code&gt; 탭을 눌러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구성 편집&lt;/code&gt;에 들어가면 위의 [그림 2]와 같은 화면을 볼 수 있습니다.&lt;/p&gt;

    &lt;p&gt;아래쪽에 보면 토큰이 발급되어 있는 것을 볼 수 있을텐데, &lt;strong&gt;이 토큰은 나중에 Jenkins credentials을 생성할 때 사용&lt;/strong&gt;됩니다.&lt;/p&gt;

    &lt;p&gt;여기까지 설정했다면 Slack에서의 설정은 끝난 것입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins 설정&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Jenkins에서 Slack과 연동하는 방법을 알아보겠습니다.&lt;/p&gt;

    &lt;p&gt;먼저 Jenkins 설정에서 Slack 플러그인을 설치해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_3.png&quot; alt=&quot;install_slack_plugin&quot; width=&quot;667&quot; height=&quot;252&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Slack 플러그인 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 Slack 플러그인을 설치하고나면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 설정&lt;/code&gt; 탭의 맨 아래쪽에 Slack 설정 공간이 있습니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 4]와 같이 워크스페이스와 Credentials, 채널 ID를 정확하게 기입해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_4.png&quot; alt=&quot;jenkins_slack_configuration&quot; width=&quot;713&quot; height=&quot;275&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Jenkins에서 Slack 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Credentials의 경우에 옆의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add&lt;/code&gt; 버튼을 눌러 Slack의 Credentials를 추가할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;Credentials를 추가할 때 Kind는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Secret text&lt;/code&gt;로 두고 Secret은 [그림 2]에서 보이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;토큰&lt;/code&gt; 값을 입력해줍니다.&lt;/p&gt;

    &lt;p&gt;그런 우측 하단의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Connection&lt;/code&gt; 버튼을 눌러 정상적으로 연동되어 Success 문구가 뜨는지 확인합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins와 Slack이 정상적으로 연동되고나면 다시 파이프라인으로 돌아와서, 파이프라인이 모두 실행되고나서 Slack에 메시지를 보내는 테스트를 진행해보겠습니다.&lt;/p&gt;

    &lt;p&gt;파이프라인 스크립트는 앞선 포스트에서 사용했던 스크립트에서 다음과 같이 추가만 하였습니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          SLACK_CHANNEL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'#send-slack-message-from-jenkins'&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
      post &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
          success &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;'#00FF00'&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;SUCCESSFUL: Job '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]' (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          failure &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;'#F01717'&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;FAILURE: Job '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]' (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;파이프라인을 모두 실행하고 나서 파이프라인이 성공 혹은 실패 상태인지 확인하여 상태에 맞게 Slack 메시지를 보내도록 작성하였습니다.&lt;/p&gt;

    &lt;p&gt;성공하면 ‘SUCCESSFUL’이라는 문구와 함께 초록색으로 메시지가 전달될 것이고, 실패하면 ‘FAILURE’이라는 문구와 함께 빨간색으로 메시지가 전달될 것입니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 5]는 파이프라인이 정상적으로 실행되어 Slack으로 메시지가 전달 되었을 경우입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_5.png&quot; alt=&quot;slack_message&quot; width=&quot;485&quot; height=&quot;183&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Slack 메시지 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-멀티-브랜치-파이프라인-사용---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 멀티 브랜치 파이프라인 사용&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;멀티 브랜치 설정&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;이번에는 Jenkins에서 멀티 브랜치 파이프라인을 설정하는 방법을 알아보겠습니다.&lt;/p&gt;

    &lt;p&gt;먼저 Jenkins 시스템 설정에서 다음 [그림 6]과 같이 GitLab 서버에 대해 설정해야 합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_6.png&quot; alt=&quot;gitlab_server_configuration&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] Jenkins에서 GitLab 서버 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그런 다음 Jenkins 홈에서 왼쪽 탭의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로운 Item&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Multibranch Pipeline&lt;/code&gt;을 생성해줍니다.&lt;/p&gt;

    &lt;p&gt;멀티 브랜치 파이프라인을 만들 때 Branch Sources 항목에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add Source -&amp;gt; GitLab Project&lt;/code&gt;를 눌러 다음 [그림 7]과 같이 설정해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_7.png&quot; alt=&quot;multibranch_gitlab_configuration&quot; width=&quot;653&quot; height=&quot;623&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] 멀티브랜치 GitLab 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Server는 [그림 6]에서 정상적으로 설정했다면 자동으로 잡혀있을 것이고, Credentials는 CI 설정할 때 만들어두었던 것을 그대로 사용해주시면 됩니다.&lt;/p&gt;

    &lt;p&gt;그리고 파이프라인에 연결할 프로젝트를 생성한 계정의 ID를 Owner로 두면 해당 ID에서 관리하고 있는 프로젝트들을 아래 Projects에서 선택할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;Behaviours 항목에서 Add 버튼을 눌러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filter by name (with wildcards)&lt;/code&gt;를 생성해주고, 위에서 선택한 프로젝트에서 파이프라인을 실행할 브랜치들의 이름을 Include에 적어두면 됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;멀티 브랜치 파이프라인은 각 브랜치들에 Jenkinsfile을 생성하여 Jenkinsfile에서 스크립트를 작성해두어야 합니다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;master 브랜치에서는 CI/CD 파이프라인이 모두 동작하여 빌드부터 배포까지 모두 진행되도록 그대로 두었고,&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;release 브랜치에서는 CI 파이프라인만 동작하도록 아래와 같이 작성하였습니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          registry &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513/flask-app&quot;&lt;/span&gt;
          registryCredential &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'crisis513'&lt;/span&gt;
          dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
          releaseName &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-app&quot;&lt;/span&gt;
          helmChartRepo &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-kubernetes-helm&quot;&lt;/span&gt;
          release_version &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'latest'&lt;/span&gt;
          SLACK_CHANNEL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'#send-slack-message-from-jenkins'&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      agent &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          label &lt;span class=&quot;s2&quot;&gt;&quot;jenkins-slave&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Cloning our Git'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s1&quot;&gt;'http://GITLAB_SERVER_IP:8001/root/flask-app.git'&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Building docker image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry + &lt;span class=&quot;s2&quot;&gt;&quot;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Deploy docker image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              when &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  branch &lt;span class=&quot;s1&quot;&gt;'master'&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;, registryCredential &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          dockerImage.push&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Cleaning up'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              when &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  branch &lt;span class=&quot;s1&quot;&gt;'master'&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;docker rmi &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$registry&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Deploy image to kubernetes'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              when &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  branch &lt;span class=&quot;s1&quot;&gt;'master'&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&quot;
                      helm lint &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                      helm upgrade &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;releaseName&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                  &quot;&quot;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      post &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
          success &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;'#00FF00'&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;SUCCESSFUL: Job '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]' (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
          failure &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;'#FF0000'&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;FAILED: Job '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]' (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;멀티 브랜치 테스트&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;release 파이프라인을 실행시켜 정상적으로 동작하면 다음 [그림 8]과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_8.png&quot; alt=&quot;release_pipeline_test&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] release 브랜치 파이프라인 테스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Git clone하여 도커 이미지를 빌드하는 부분까지는 정상 동작하지만 도커 이미지를 배포하고 쿠버네티스 클러스터에 배포하기까지의 과정은 master 브랜치에서만 동작하도록 설정하였기 때문에 생락된 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음 포스팅부터는 지금까지 설정해 둔 DevOps 파이프라인에서 정적/동적 분석을 통해 안전한 배포를 할 수 있도록 보안에 대한 내용을 다뤄보도록 하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/10/15/devsecops5.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/10/15/devsecops5.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>jenkins</category>
        
        <category>slack</category>
        
        <category>multi-branch</category>
        
        <category>pipeline</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - Helm을 통한 모니터링과 로깅 시스템 구축</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 클라우드 네이티브 환경에서 DevSecOps 툴 체인 파이프라인을 구축하는 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;9월에 시작하여 11월 27일까지 진행되고 현재 진행 중이며, 내용이 긴 만큼 여러 포스트를 나눠 기록하고자 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 포스트의 내용은 프로젝트 도중 작성되어 추후 변경될 수 있음을 알립니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 모니터링 시스템 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Helm 개요와 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Prometheus와 Grafana 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 로깅 시스템 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. EFK(Elasticsearch-Fluent Bit-Kibana) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-모니터링-시스템-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 모니터링 시스템 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Helm 개요와 설치&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Helm은 쿠버네티스 패키지를 관리해주는 도구입니다.&lt;/p&gt;

    &lt;p&gt;Helm에서 사용되는 차트는 리소스를 하나로 묶은 패키지에 해당하며, Helm으로 차트를 관리하는 목적은 자칫 번잡해지기 쉬운 매니페스트 파일을 관리하기 쉽게 하기 위함입니다.&lt;/p&gt;

    &lt;p&gt;그리고 설치할 때마다 릴리스 버전이 생성되고 새로운 차트를 찾을때에는 Helm chart repository에서 찾을 수 있습니다.&lt;/p&gt;

    &lt;p&gt;Helm 다음 명령어로 간단하게 설치가 가능합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;700 get_helm.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./get_helm.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Helm이 정상적으로 설치되면 차트 레포지토리를 추가하고 업데이트해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add stable https://kubernetes-charts.storage.googleapis.com/
  &lt;span class=&quot;s2&quot;&gt;&quot;stable&quot;&lt;/span&gt; has been added to your repositories

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo update
  Hang tight &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;we grab the latest from your chart repositories...
  ...Successfully got an update from the &lt;span class=&quot;s2&quot;&gt;&quot;stable&quot;&lt;/span&gt; chart repository
  Update Complete. ⎈Happy Helming!⎈
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;여기까지만 해주어도 Helm을 사용할 준비가 끝난 것입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prometheus와 Grafana 구성&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;모니터링 환경을 구축하기 위해 앞서 설치한 Helm을 사용하여 Prometheus와 Grafana를 쿠버네티스에 설치할 것입니다.&lt;/p&gt;

    &lt;p&gt;먼저 모니터링을 위한 네임스페이스를 생성해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace monitoring
  namespace/monitoring created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;생성된 네임스페이스에 다음 명령어를 통해 prometheus-operator를 설치해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;prometheus stable/prometheus-operator &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; monitoring
  WARNING: This chart is deprecated
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  NAME: prometheus
  LAST DEPLOYED: Sun Oct  4 07:36:07 2020
  NAMESPACE: monitoring
  STATUS: deployed
  REVISION: 1
  NOTES:
  &lt;span class=&quot;k&quot;&gt;*******************&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; DEPRECATED &lt;span class=&quot;k&quot;&gt;****&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*******************&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; stable/prometheus-operator chart is deprecated.
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Further development has moved to https://github.com/prometheus-community/helm-charts
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; The chart has been renamed kube-prometheus-stack to more clearly reflect
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; that it installs the &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;kube-prometheus&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; project stack, within which Prometheus
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Operator is only one component.

  The Prometheus Operator has been installed. Check its status by running:
  kubectl &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; monitoring get pods &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;release=prometheus&quot;&lt;/span&gt;

  Visit https://github.com/coreos/prometheus-operator &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;instructions on how
  to create &amp;amp; configure Alertmanager and Prometheus instances using the Operator.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Prometheus와 Grafana가 재대로 동작하는지 확인해봅니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring
  NAME                                                         READY   STATUS    RESTARTS   AGE
  pod/alertmanager-prometheus-prometheus-oper-alertmanager-0   2/2     Running   0          10m
  pod/prometheus-grafana-7db88cd4c6-nff9b                      2/2     Running   0          10m
  pod/prometheus-kube-state-metrics-6b46f67bf6-n8pxk           1/1     Running   0          10m
  pod/prometheus-prometheus-node-exporter-d4zfh                1/1     Running   0          10m
  pod/prometheus-prometheus-node-exporter-dkjrj                1/1     Running   0          10m
  pod/prometheus-prometheus-node-exporter-zv7t9                1/1     Running   0          10m
  pod/prometheus-prometheus-oper-operator-7c75ff5864-z85j8     2/2     Running   0          10m
  pod/prometheus-prometheus-prometheus-oper-prometheus-0       3/3     Running   0          10m

  NAME                                              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                      AGE
  service/alertmanager-operated                     ClusterIP   None             &amp;lt;none&amp;gt;        9093/TCP,9094/TCP,9094/UDP   10m
  service/prometheus-grafana                        ClusterIP   10.104.145.38    &amp;lt;none&amp;gt;        80/TCP                       10m
  service/prometheus-kube-state-metrics             ClusterIP   10.109.220.132   &amp;lt;none&amp;gt;        8080/TCP                     10m
  service/prometheus-operated                       ClusterIP   None             &amp;lt;none&amp;gt;        9090/TCP                     10m
  service/prometheus-prometheus-node-exporter       ClusterIP   10.104.66.36     &amp;lt;none&amp;gt;        9100/TCP                     10m
  service/prometheus-prometheus-oper-alertmanager   ClusterIP   10.100.159.72    &amp;lt;none&amp;gt;        9093/TCP                     10m
  service/prometheus-prometheus-oper-operator       ClusterIP   10.99.75.140     &amp;lt;none&amp;gt;        8080/TCP,443/TCP             10m
  service/prometheus-prometheus-oper-prometheus     NodePort    10.107.124.62    &amp;lt;none&amp;gt;        9090/TCP                     10m

  NAME                                                 DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
  daemonset.apps/prometheus-prometheus-node-exporter   3         3         3       3            3           &amp;lt;none&amp;gt;          10m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Prometheus와 Grafana가 정상적으로 동작하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodePort를 생성&lt;/code&gt;하여 생성된 Prometheus와 Grafana 서비스에 접근할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 Prometheus의 포트번호를 31111, Grafana의 포트번호를 31112로 정하였고, &lt;strong&gt;GCP 방화벽에서도 해당 포트를 열어줍니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim prometheus_nodeport.yaml
  apiVersion: v1
  kind: Service
  metadata:
  name: prometheus
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app: prometheus
      prometheus: prometheus-prometheus-oper-prometheus
  ports:
      - protocol: TCP
      port: 9090
      targetPort: 9090
      nodePort: 31111

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim grafana_nodeport.yaml 
  apiVersion: v1
  kind: Service
  metadata:
  name: grafana
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app.kubernetes.io/instance: prometheus
      app.kubernetes.io/name: grafana
  ports:
      - protocol: TCP
      port: 3000
      targetPort: 3000
      nodePort: 31112

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; prometheus_nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; grafana_nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-masterIP:31111&lt;/code&gt; URL로 접속하여 상단 메뉴의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Status &amp;gt; Targets&lt;/code&gt;에 들어가보면 다음 [그림 1]과 같이 에러가 나 있을 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_4_1.png&quot; alt=&quot;proxy_etcd_error&quot; width=&quot;858&quot; height=&quot;254&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] kube-proxy와 kube-etcd 에러&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;kube-proxy는 메트릭 바인드 주소가 기본적으로 localhost로 잡혀있을 것입니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl edit cm/kube-proxy &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  kind: KubeProxyConfiguration
  metricsBindAddress: 0.0.0.0:10249
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete pod &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; k8s-app&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kube-proxy &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;metricsBindAddress 값을 위와 같이 0.0.0.0으로 바꿔주고 기존의 kube-proxy 파드를 제거하여 재생성되되록 해주면 Prometheus에서 kube-proxy가 정상적으로 작동할 것입니다.&lt;/p&gt;

    &lt;p&gt;다음으로 kube-etcd는 https 인증서 설정이 재대로 되어있지 않아서 생기는 문제입니다.&lt;/p&gt;

    &lt;p&gt;prometheus-operator를 배포할 때 Helm 차트의 values.yaml 파일을 다음과 같이 수정합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim values.yaml
  serviceMonitor:
      scheme: https
      insecureSkipVerify: &lt;span class=&quot;nb&quot;&gt;false
      &lt;/span&gt;serverName: localhost
      caFile: /etc/prometheus/secrets/etcd-client-cert/etcd-ca
      certFile: /etc/prometheus/secrets/etcd-client-cert/etcd-client
      keyFile: /etc/prometheus/secrets/etcd-client-cert/etcd-client-key

      secrets:
      - &lt;span class=&quot;s2&quot;&gt;&quot;etcd-client-cert&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;values.yaml 파일을 수정하고 caFile, certFile, keyFile에 맞는 시크릿을 생성해주어야 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ POD_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get pods &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'{.items[0].metadata.name}'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kube-apiserver &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create secret generic etcd-client-cert &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--from-literal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;etcd-ca&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD_NAME&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/kubernetes/pki/etcd/ca.crt&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--from-literal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;etcd-client&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD_NAME&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/kubernetes/pki/etcd/healthcheck-client.crt&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--from-literal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;etcd-client-key&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD_NAME&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/kubernetes/pki/etcd/healthcheck-client.key&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  secret/etcd-client-cert created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;etcd-client-cert 시크릿을 만들어주고 수정된 values.yaml 파일을 바탕으로 다시 prometheus-operator를 배포하면 etcd의 통신 에러도 해결 될 것입니다.&lt;/p&gt;

    &lt;p&gt;Helm에 value.xml 파일을 따로 수정하지 않으면 기본적으로 Grafana의 ID는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt;, 패스워드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prom-operator&lt;/code&gt;로 설정되어 있습니다.&lt;/p&gt;

    &lt;p&gt;참고로 초기 패스워드는 values.yaml 파일에서 수정할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-masterIP:31112&lt;/code&gt; URL로 접속하여 Grafana 대시보드가 Prometheus에서 수집된 메트릭을 잘 수집하여 시각화되어지는지 확인해봅니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_4_2.png&quot; alt=&quot;grafana_dashboard&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Grafana 대시보드 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 2]에서와 같이 쿠버네티스 클러스터에 대한 메트릭이 잘 수집되어 시각화해주는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-로깅-시스템-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 로깅 시스템 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EFK(Elasticsearch-Fluent Bit-Kibana) 구성&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;로깅 환경을 구축하기 위해 Helm을 사용하여 EFK를 쿠버네티스에 설치할 것입니다.&lt;/p&gt;

    &lt;p&gt;먼저 EFK 차트 레포지토리를 추가 및 업데이트를 해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add akomljen-charts https://raw.githubusercontent.com/komljen/helm-charts/master/charts/
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;그런 다음 모니터링과 마찬가지로 로깅을 위한 네임스페이스를 생성해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace logging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;elasticsearch-master와 elasticsearch-data에서 사용할 PV를 미리 각각 생성해주어야 PVC가 정상적으로 바인딩 되어 Elasticsearch 노드들이 정상적으로 동작됩니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim elastic-pv.yaml
  apiVersion: v1
  kind: PersistentVolume
  metadata:
  name: es-data-es-master-efk-cluster-default-0
  labels:
      cluster: efk-cluster
      component: elasticsearch-efk-cluster
      name: es-master-efk-cluster-default
      role: master
  spec:
  capacity:
      storage: 10Gi
  accessModes:
      - ReadWriteOnce
  hostPath:
      path: &lt;span class=&quot;s2&quot;&gt;&quot;/mnt/data&quot;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
  apiVersion: v1
  kind: PersistentVolume
  metadata:
  name: es-data-es-data-efk-cluster-default-0
  labels:
      cluster: efk-cluster
      component: elasticsearch-efk-cluster
      name: es-data-efk-cluster-default
      role: data
  spec:
  capacity:
      storage: 10Gi
  accessModes:
      - ReadWriteOnce
  hostPath:
      path: &lt;span class=&quot;s2&quot;&gt;&quot;/mnt/data&quot;&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; elastic-pv.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pv,pvc &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging
  NAME                                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                             STORAGECLASS   REASON   AGE
  persistentvolume/es-data-es-data-efk-cluster-default-0     10Gi       RWO            Retain           Bound    logging/es-data-es-data-efk-cluster-default-0                             15m
  persistentvolume/es-data-es-master-efk-cluster-default-0   10Gi       RWO            Retain           Bound    logging/es-data-es-master-efk-cluster-default-0                           15m

  NAME                                                            STATUS   VOLUME                                    CAPACITY   ACCESS MODES   STORAGECLASS   AGE
  persistentvolumeclaim/es-data-es-data-efk-cluster-default-0     Bound    es-data-es-data-efk-cluster-default-0     10Gi       RWO                           15m
  persistentvolumeclaim/es-data-es-master-efk-cluster-default-0   Bound    es-data-es-master-efk-cluster-default-0   10Gi       RWO                           15m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;PV를 정상적으로 생성하고 PVC가 바운드된 것이 확인되면 다음 명령어를 통해 efk를 설치해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;efk &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; logging akomljen-charts/efk

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging
  NAME                                                    READY   STATUS      RESTARTS   AGE
  pod/efk-elasticsearch-curator-1602579600-rcwk8          0/1     Completed   0          15m
  pod/efk-kibana-676fb9dbd4-rx5xv                         1/1     Running     0          15m
  pod/elasticsearch-operator-sysctl-fl7jd                 1/1     Running     0          15m
  pod/elasticsearch-operator-sysctl-mgsxp                 1/1     Running     0          15m
  pod/es-client-efk-cluster-5f65d7f687-hpm65              1/1     Running     0          15m
  pod/es-data-efk-cluster-default-0                       1/1     Running     0          15m
  pod/es-master-efk-cluster-default-0                     1/1     Running     0          15m
  pod/es-operator-elasticsearch-operator-876b46db-s84t8   1/1     Running     0          15m
  pod/fluent-bit-s5j8z                                    1/1     Running     0          15m
  pod/fluent-bit-spwj2                                    1/1     Running     0          15m


  NAME                                          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         AGE
  service/efk-kibana                            ClusterIP   10.111.218.138   &amp;lt;none&amp;gt;        443/TCP         15m
  service/elasticsearch-discovery-efk-cluster   ClusterIP   10.103.53.150    &amp;lt;none&amp;gt;        9300/TCP        15m
  service/elasticsearch-efk-cluster             ClusterIP   10.108.108.5     &amp;lt;none&amp;gt;        9200/TCP        15m
  service/es-data-svc-efk-cluster               ClusterIP   10.107.231.1     &amp;lt;none&amp;gt;        9300/TCP        15m

  NAME                                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                 AGE
  daemonset.apps/elasticsearch-operator-sysctl   2         2         2       2            2           beta.kubernetes.io/os&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux   15m
  daemonset.apps/fluent-bit                      2         2         2       2            2           &amp;lt;none&amp;gt;                        15m

  NAME                                                 READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/efk-kibana                           1/1     1            1           15m
  deployment.apps/es-client-efk-cluster                1/1     1            1           15m
  deployment.apps/es-operator-elasticsearch-operator   1/1     1            1           15m

  NAME                                                          DESIRED   CURRENT   READY   AGE
  replicaset.apps/efk-kibana-676fb9dbd4                         1         1         1       15m
  replicaset.apps/es-client-efk-cluster-5f65d7f687              1         1         1       15m
  replicaset.apps/es-operator-elasticsearch-operator-876b46db   1         1         1       15m

  NAME                                             READY   AGE
  statefulset.apps/es-data-efk-cluster-default     1/1     15m
  statefulset.apps/es-master-efk-cluster-default   1/1     15m

  NAME                                             COMPLETIONS   DURATION   AGE
  job.batch/efk-elasticsearch-curator-1602579600   1/1           2s         15m

  NAME                                      SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE
  cronjob.batch/efk-elasticsearch-curator   0 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;   False     0        15m             15m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;EFK가 정상적으로 설치되면 NodePort 서비스를 생성하여 외부에서 접근가능하도록 해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim kibana-nodeport.yaml
  apiVersion: v1
  kind: Service
  metadata:
  name: kibana
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app: kibana
      release: efk
  ports:
      - protocol: TCP
      port: 443
      targetPort: 5601
      nodePort: 30443

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; kibana-nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;마찬가지로 &lt;strong&gt;Kibana에 접근할 30443 포트는 GCP 방화벽에서도 열어주어야 접근이 가능합니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이렇게 Kibana에 접근하더라도 문제가 한 가지 더 있습니다.&lt;/p&gt;

    &lt;p&gt;Fluent Bit에서 쿠버네티스 클러스터의 로그를 수집할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log/containers&lt;/code&gt;에 존재하는 로그 파일을 읽어들이는데, journald 드라이버를 사용하여 컨테이너 로그를 수집하게 되어 있어 /var/log/containers 폴더에 로그가 쌓이지 않는 문제가 있습니다.&lt;/p&gt;

    &lt;p&gt;그래서 Kibana에 접속하더라도 생성할 인덱스 패턴이 존재하지 않았었는데, 문제를 해결하기 위해 다음과 같이 수정해야 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim /etc/sysconfig/docker
  &lt;span class=&quot;nv&quot;&gt;OPTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'--selinux-enabled --signature-verification=false'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;모든 쿠버네티스 클러스터에서 /etc/sysconfig/docker 파일에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--log-driver = journald 부분을 제거&lt;/code&gt;해야 도커 컨테이너 로그가 /var/log/containers 경로에 쌓이게 되고, Fluent Bit에서 해당 로그들을 수집하여 Kibana에서 인덱스 패턴을 생성할 수가 이쎅 됩니다.&lt;/p&gt;

    &lt;p&gt;정상적으로 로그가 쌓이게 되면 다시 Kibana에 접속하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kubernetes_cluster-*&lt;/code&gt;이라는 인덱스 패턴을 생성해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_4_3.png&quot; alt=&quot;kibana_index_pattern&quot; width=&quot;1233&quot; height=&quot;608&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Kibana 인덱스 패턴 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기까지 Helm을 이용하여 쿠버네티스에 로깅 및 모니터링 시스템을 구축해보았습니다.&lt;/p&gt;

    &lt;p&gt;포스팅은 간단해 보일 수 있어도 해결하기 힘든 기억이 있어 뿌듯합니다!&lt;/p&gt;

    &lt;p&gt;다음 포스팅에서는 Jenkins와 Slack을 연동하고 멀티 브랜치를 기반으로 작동하는 파이프라인을 생성하고 스크립트를 작성하는 부분에 대해 다뤄보겠습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 13 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/10/13/devsecops4.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/10/13/devsecops4.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>kubernetes</category>
        
        <category>helm</category>
        
        <category>prometheus</category>
        
        <category>grafana</category>
        
        <category>efk</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - CD 구성</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 클라우드 네이티브 환경에서 DevSecOps 툴 체인 파이프라인을 구축하는 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;9월에 시작하여 11월 27일까지 진행되고 현재 진행 중이며, 내용이 긴 만큼 여러 포스트를 나눠 기록하고자 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 포스트의 내용은 프로젝트 도중 작성되어 추후 변경될 수 있음을 알립니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. CD(Continuous Delivery/Continuous Deployment) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. CD 란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Jenkins - 쿠버네티스 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. Jenkins Slave 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_4&quot;&gt;   1.4. 쿠버네티스 배포 파이프라인 추가&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. ArgoCD를 이용한 CD 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. ArgoCD 란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. ArgoCD 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-cdcontinuous-deliverycontinuous-deploy-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. CD(Continuous Delivery/Continuous Deploy) 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CD 란?&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;CD는 지속적인 지속적인 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미합니다.&lt;/p&gt;

    &lt;p&gt;이 두 용어는 상호 교환적으로 사용되며, 두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 합니다.&lt;/p&gt;

    &lt;p&gt;지속적인 제공이란 &lt;strong&gt;개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드&lt;/strong&gt;되는 것을 뜻합니다.&lt;/p&gt;

    &lt;p&gt;지속적인 배포란 &lt;strong&gt;개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것&lt;/strong&gt;을 의미합니다.&lt;/p&gt;

    &lt;p&gt;이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결하여 줍니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins - 쿠버네티스 연동&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 쿠버네티스 클러스터와 연동하는 방법에 대해서 설명할 것입니다.&lt;/p&gt;

    &lt;p&gt;Jenkins와 쿠버네티스의 구성은 &lt;a href=&quot;https://crisis513.github.io/project/2020/10/03/devsecops1.html#list2_1&quot;&gt;구축 환경 참고&lt;/a&gt;를 참고해 주세요.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_1.png&quot; alt=&quot;kubernetes_plugin&quot; width=&quot;728&quot; height=&quot;718&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Jenkins에서 쿠버네티스 플러그인 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 설치된 쿠버네티스 플러그인에 대한 설정을 진행합니다.&lt;/p&gt;

    &lt;p&gt;Jenkins 시스템 설정에서 맨 밑으로 내려가면 [그림 2]와 같이 클라우드 설정하는 부분이 나옵니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_2.png&quot; alt=&quot;cloud_configuration&quot; width=&quot;598&quot; height=&quot;75&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Jenkins 시스템 설정에서 클라우드 설정 클릭&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a separate configuration page&lt;/code&gt;를 눌러 Configure Clouds 설정으로 들어옵니다.&lt;/p&gt;

    &lt;p&gt;쿠버네티스 설정은 다음 [그림 3], [그림 4]와 같이 진행합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_3.png&quot; alt=&quot;kubernetes_plugin_configuration&quot; width=&quot;725&quot; height=&quot;335&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] 쿠버네티스 플러그인 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Kubernetes URL은 kube-master 인스턴스에 접속하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.kube/config&lt;/code&gt; 파일의 내용을 확인해보면 server에 명시된 URL을 기입하면 됩니다.&lt;/p&gt;

    &lt;p&gt;Kubernetes URL을 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Connection&lt;/code&gt; 버튼을 눌러 쿠버네티스 클러스터에 정상적으로 접속되는지 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; ~/.kube/config 
  apiVersion: v1
  clusters:
  - cluster:
      certificate-authority-data: &lt;span class=&quot;nv&quot;&gt;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN5RENDQWJDZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJd01UQXdPREF5TlRreU9Gb1hEVE13TVRBd05qQXlOVGt5T0Zvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTlNhCkhwK2M2cWxhRXU1cXlWWHpLZFA3UTJZWnVjVnN1aTRTczFqamUxQW41cXlEVDVnMk9iKzM5OXN4Y0phM215MkIKYjg0UE5NYmc1MERyenZ4S1VOWVZySkk4Z1F2c2JXWXRPZnhhTGV3NUF1aE5NV1dsRlVlRUpyTE9WT0NQdndoTApDRHVLOVd5TUlIMTU4U1hKM1dYRW5TeUZJWXVSeDI3NTNicnFWRzVuNnZMTVVMMUdDKzNSaHJ1cEN5d0xoVG12CnpyYWdWTVFicUVjV2pTcjV2TVZueTduTXVvQ2xmSjE3SXBYa1MweTN3eDJsRTJVREtIblNuSlZHeVNYbXVKYVYKL3A5THk4djNWL2VsVjZLY1plRStIaVZFNlNBT3R4bXhwSDl2Zmh2blpxQzBsbzNpaGpzR0hGUGRyeStiZkhVegpPaSsrZ1VCZmxKTkZucFZlNE5zQ0F3RUFBYU1qTUNFd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFBNlI3NW9SWnJxQ2tDMEpqbURTMmgxMUN4WkYKTmM0cXRqMTlqeEZlQUFlMCt4a0MveUlidzBUYmY0OW1TWGE1VUhPbkE1RSszSStFWTdXc0h6dTJTOEZlU3FwbgpNZC9iYXp6aU5wT28vNGxoNGVWNkE5NmNsdjV1cm5CSVIzOVVpM085SnpKUDBobTRhUGxDZFVqcDhyb3BrSWFmCkZieURTcVBFS1E0Rm5tc1MvcGJWellHQ2RVdmlqT3JCcnBiTEU2ZW1PYkc2RGE4WG0xNWJHSzVUVUt5Mm5rOGgKOHoxNjZZanVVOTR1bW9RYjR4eVNWOThNZ2RRTWVsWml1U2dHelRKcEtKTHN3NG94SGdPbkNLZUNNeURHSFZOUwpnMFo2MU12YldlVzhzVEtaSHpCVVZySFZ3WjlTSCtNdGtMWllSb0VWdk9NTTNLSXczbmRieG8rcXd5OD0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
      server: https://10.178.0.19:6443
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그 후 아래로 내리다보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod Templates&lt;/code&gt;를 구성하는 버튼이 있습니다.&lt;/p&gt;

    &lt;p&gt;그 버튼을 눌러 다음 [그림 4]와 같이 설정하고 저장합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_4.png&quot; alt=&quot;pod_template&quot; width=&quot;910&quot; height=&quot;601&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Pod 템플릿 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins Slave 설정&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 쿠버네티스 클러스터와의 연동이 정상적으로 설정되었다면 다음은 Jenkins Slave를 생성 및 구성해야 합니다.&lt;/p&gt;

    &lt;p&gt;Jenkins의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Manage Nodes&lt;/code&gt; 설정에 들어와서 왼쪽의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신규 노드&lt;/code&gt; 탭을 눌러 Jenkins Slave 노드를 생성해줍니다.&lt;/p&gt;

    &lt;p&gt;첫 화면에서는 노드 명에 ‘jenkins-slave’라고 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Permanent Agent&lt;/code&gt;를 클릭 후 다음으로 넘어갑니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_5.png&quot; alt=&quot;create_jenkins_slave&quot; width=&quot;937&quot; height=&quot;437&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Jenkins Slave 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;신규 노드에 대한 설정에서 위의 [그림 5]와 같이 설정합니다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;jenkins-slave를 kube-master 인스턴스에서 실행시켜놓고 Jenkins에서 웹 소켓을 통해 kube-master에 접근하여 스크립트를 실행시켜서 서비스를 배포하는 형태로 진행됩니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;jenkins-slave agent를 생성하면 다음 [그림 6]의 화면을 볼 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_6.png&quot; alt=&quot;jenkins_slave_guide&quot; width=&quot;1050&quot; height=&quot;297&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] jenkins-slave 가이드 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;agent.jar 링크를 눌러 파일을 다운&lt;/strong&gt;받고 kube-master 인스턴스에 복사한 후에 [그림 6]에 보이는 명령을 실행하면 됩니다.&lt;/p&gt;

    &lt;p&gt;하지만 kube-master 인스턴스에는 java가 설치되어 있지 않아 java를 설치하고 설정하는 작업부터 진행합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;java-1.8.0-openjdk-devel.x86_64
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;readlink&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /usr/bin/javac
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vi /etc/profile
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;
  /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/bin/javac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;java 1.8 버전을 설치&lt;/strong&gt;하고 &lt;strong&gt;JAVA_HOME 환경변수를 설정&lt;/strong&gt;하여 java 명령을 실행시킬 수 있도록 해주고 다음 명령을 입력합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; agent.jar &lt;span class=&quot;nt&quot;&gt;-jnlpUrl&lt;/span&gt; http://serversIP:8002/computer/jenkins-slave/slave-agent.jnlp &lt;span class=&quot;nt&quot;&gt;-secret&lt;/span&gt; 032e782a7ef4897446fec5be230aefb9036ddb841552142e415012d266ced967 &lt;span class=&quot;nt&quot;&gt;-workDir&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/data/jenkins&quot;&lt;/span&gt;
  Sep 30, 2020 3:18:20 PM org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir
  INFO: Using /home/jenkins/agent/remoting as a remoting work directory
  Sep 30, 2020 3:18:20 PM org.jenkinsci.remoting.engine.WorkDirManager setupLogging
  INFO: Both error and output logs will be printed to /home/jenkins/agent/remoting
  Sep 30, 2020 3:18:21 PM hudson.remoting.jnlp.Main createEngine
  INFO: Setting up agent: jenkins-slave
  Sep 30, 2020 3:18:21 PM hudson.remoting.jnlp.Main&lt;span class=&quot;nv&quot;&gt;$CuiListener&lt;/span&gt; &amp;lt;init&amp;gt;
  INFO: Jenkins agent is running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;headless mode.
  Sep 30, 2020 3:18:21 PM hudson.remoting.Engine startEngine
  INFO: Using Remoting version: 4.5
  Sep 30, 2020 3:18:21 PM org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir
  INFO: Using /home/jenkins/agent/remoting as a remoting work directory
  Sep 30, 2020 3:18:21 PM hudson.remoting.jnlp.Main&lt;span class=&quot;nv&quot;&gt;$CuiListener&lt;/span&gt; status
  INFO: WebSocket connection open
  Sep 30, 2020 3:18:22 PM hudson.remoting.jnlp.Main&lt;span class=&quot;nv&quot;&gt;$CuiListener&lt;/span&gt; status
  INFO: Connected
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 jenkins-slave가 실행되면 Jenkins에서 쿠버네티스 클러스터에 서비스를 배포할 수 있는 환경이 만들어진 것이고 [그림 7]과 같이 agent가 연결된 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_7.png&quot; alt=&quot;jenkins_slave_agent&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] jenkins-slave agent 연결 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipeline 설정 및 테스트&lt;/strong&gt;   &lt;a name=&quot;list1_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;위의 쿠버네티스 관련 설정이 정상적으로 완료되면 파이프라인 스크립트를 다음과 같이 작성해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          registry &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513/flask-app&quot;&lt;/span&gt;
          registryCredential &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513&quot;&lt;/span&gt;
          dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
          releaseName &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-app&quot;&lt;/span&gt;
          helmChartRepo &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-kubernetes-helm&quot;&lt;/span&gt;
          release_version &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;latest&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      agent &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          label &lt;span class=&quot;s2&quot;&gt;&quot;jenkins-slave&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Cloning our Git'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s2&quot;&gt;&quot;http://GITLAB_SERVER_IP:8001/root/flask-app.git&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Building docker image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry + &lt;span class=&quot;s2&quot;&gt;&quot;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Deploy docker image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;, registryCredential &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          dockerImage.push&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Cleaning up'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;docker rmi &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$registry&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Deploy image to kubernetes'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&quot;
                      helm lint &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                      helm upgrade &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;releaseName&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                  &quot;&quot;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;만약 Jenkins agent에서 도커를 실행하지 못하는 에러가 발생하면 docker.io 패키지를 설치해주어야 합니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;파이프라인은 다음과 같이 실행됩니다.&lt;/p&gt;

    &lt;p&gt;CI가 실행되는 스크립트는 이전 포스팅과 동일하고 그 이후 배포하는 과정이 추가되었고, ‘Deploy image to kubernetes’ Stage에서 &lt;strong&gt;helm upgrade 명령어를 통해 쿠버네티스 클러스터에 실행되고 있는 서비스에 롤링 업데이트 형태로 재배포할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_8.png&quot; alt=&quot;pipeline_execute_result&quot; width=&quot;716&quot; height=&quot;332&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] 쿠버네티스 배포까지의 파이프라인 실행 결과&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위 스크립트의 실행 결과는 위의 [그림 8]과 같습니다. Git clone하는 부분부터 쿠버네티스 클러스터에 서비스 배포하는 과정까지 정상적으로 실행된 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Helm에 대한 부분은 추후 별도의 포스팅에서 다루도록 하겠습니다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-argocd를-이용한-cd-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. ArgoCD를 이용한 CD 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ArgoCD 란?&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;앞서 설명한 Jenkins Slave를 구성하여 CI/CD를 모두 제어할 수 있지만, CI를 Jenkins에서 진행하고 CD를 ArgoCD로 진행하는 형태로도 구축할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;ArgoCD는 쿠버네티스 클러스터에 설치 한 후 애플리케이션들을 관리할 수 ​​있습니다.&lt;/p&gt;

    &lt;p&gt;Git 저장소에 앱을 설명하는 쿠버네티스 매니페스트가 존재하는데, ArgoCD는 이러한 매니페스트가 항상 동기화되어 있는지 확인합니다.&lt;/p&gt;

    &lt;p&gt;모든 매니페스트와 해당 동기화 상태는 UI가 깔끔하고 시각적으로 잘 표현되어 있으면서도 가볍기 때문에 Jenkins와 같이 사용하는 것도 상당히 매력적인 선택지 중 하나입니다.&lt;/p&gt;

    &lt;p&gt;애플리케이션 배포 및 수명주기 관리는 자동화되고 감사 가능하며 이해하기 쉬워야합니다. 이 모든 작업은 Argo를 사용하여 수행 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ArgoCD 설치&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ArgoCD는 쿠버네티스 위에서 동작하는 GitOps 지속적 배포 도구입니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;따라서 Helm을 사용하여 ArgoCD를 쿠버네티스에 배포할 것 입니다.&lt;/p&gt;

    &lt;p&gt;우선 argocd의 네임스페이스를 생성해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace argocd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다음으로 ArgoCD의 Helm 레포지토리를 추가해주고 앞서 생성해준 argocd 네임스페이스에 Helm을 사용해 argocd를 설치해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add argo https://argoproj.github.io/argo-helm
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;argocd argo/argo-cd &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  NAME: argocd
  LAST DEPLOYED: Wed Oct 10 06:38:54 2020
  NAMESPACE: argocd
  STATUS: deployed
  REVISION: 1
  TEST SUITE: None
  NOTES:
  In order to access the server UI you have the following options:

  1. kubectl port-forward service/argocd-server &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; argocd 8080:443

      and &lt;span class=&quot;k&quot;&gt;then &lt;/span&gt;open the browser on http://localhost:8080 and accept the certificate

  2. &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;ingress &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the values file &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;service.ingress.enabled&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; and either
      - Add the annotation &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;ssl passthrough: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/ingress.md#option-1-ssl-passthrough
      - Add the &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--insecure&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; flag to &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;server.extraArgs&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the values file and terminate SSL at your ingress: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/ingress.md#option-2-multiple-ingress-objects-and-hosts


  After reaching the UI the first &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;you can login with username: admin and the password will be the
  name of the server pod. You can get the pod name by running:

  kubectl get pods &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; argocd &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; app.kubernetes.io/name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;argocd-server &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; name | &lt;span class=&quot;nb&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;설치 시 수정 된 values.yaml을 적용하고 싶을 때는 다음의 명령어를 통해 배포하면 됩니다.
$ helm install argocd argo/argo-cd -f ./values.yaml&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;성공적으로 배포가 되었는지 확인해봅니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; argocd
  NAME                                                READY   STATUS    RESTARTS   AGE
  pod/argocd-application-controller-544c45984-26sfs   1/1     Running   0          15h
  pod/argocd-dex-server-7cd54b9d86-6hhvw              1/1     Running   0          15h
  pod/argocd-redis-5ddd577d68-nh867                   1/1     Running   0          15h
  pod/argocd-repo-server-69fc78b68-8f9n2              1/1     Running   0          15h
  pod/argocd-server-7c5f6f8d9-xkc8h                   1/1     Running   0          15h


  NAME                            TYPE           CLUSTER-IP       EXTERNAL-IP     PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                      AGE
  service/argocd-dex-server       ClusterIP      10.100.97.188    &amp;lt;none&amp;gt;          5556/TCP,5557/TCP,5558/TCP   15h
  service/argocd-metrics          ClusterIP      10.108.127.86    &amp;lt;none&amp;gt;          8082/TCP                     15h
  service/argocd-redis            ClusterIP      10.105.230.152   &amp;lt;none&amp;gt;          6379/TCP                     15h
  service/argocd-repo-server      ClusterIP      10.104.24.97     &amp;lt;none&amp;gt;          8081/TCP,8084/TCP            15h
  service/argocd-server           ClusterIP      10.104.68.51     &amp;lt;none&amp;gt;          80:30854/TCP,443:32178/TCP   15h
  service/argocd-server-metrics   ClusterIP      10.103.118.105   &amp;lt;none&amp;gt;          8083/TCP                     15h


  NAME                                            READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/argocd-application-controller   1/1     1            1           15h
  deployment.apps/argocd-dex-server               1/1     1            1           15h
  deployment.apps/argocd-redis                    1/1     1            1           15h
  deployment.apps/argocd-repo-server              1/1     1            1           15h
  deployment.apps/argocd-server                   1/1     1            1           15h

  NAME                                                      DESIRED   CURRENT   READY   AGE
  replicaset.apps/argocd-application-controller-544c45984   1         1         1       15h
  replicaset.apps/argocd-dex-server-7cd54b9d86              1         1         1       15h
  replicaset.apps/argocd-redis-5ddd577d68                   1         1         1       15h
  replicaset.apps/argocd-repo-server-69fc78b68              1         1         1       15h
  replicaset.apps/argocd-server-7c5f6f8d9                   1         1         1       15h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;서비스가 정상적으로 배포가 되었다면 argocd에 접근하기 위해 argocd-server에 대한 NodePort를 생성해줍니다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 30093으로 정의하였고, 마찬가지로 GCP 방화벽에서도 해당 포트번호를 추가해주어야 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim argocd-nodeport.yaml 
  apiVersion: v1
  kind: Service
  metadata:
    name: argocd
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
    app.kubernetes.io/instance: argocd
    app.kubernetes.io/name: argocd-server
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
      nodePort: 30093
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이제 ArgoCD에 접속하여 로그인을 시도해봅니다.&lt;/p&gt;

    &lt;p&gt;Helm으로 배포했을 때 초기 아이디는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt;, 패스워드는 ArgoCD 파드명 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argocd-server-7c5f6f8d9-xkc8h&lt;/code&gt; 입니다.&lt;/p&gt;

    &lt;p&gt;정상적으로 로그인이 이루어지면 Git 레포지토리를 추가하는 작업을 해주어야 합니다.&lt;/p&gt;

    &lt;p&gt;왼쪽의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt; 탭에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repositories&lt;/code&gt; 항목을 눌러 다음 [그림 9]와 같이 레포지토리를 추가해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_9.png&quot; alt=&quot;argocd_repo&quot; width=&quot;680&quot; height=&quot;239&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] ArgoCD 레포지토리 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 레포지토리가 연결되면 [그림 10]과 같이 상태 부분에 &lt;strong&gt;Successful&lt;/strong&gt; 이라는 문구가 뜨게 됩니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_10.png&quot; alt=&quot;argocd_repo_check&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] ArgoCD 레포지토리 추가 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applications&lt;/code&gt; 탭에 와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEW APP&lt;/code&gt; 버튼을 눌러 배포를 관리할 애플리케이션을 추가해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_11.png&quot; alt=&quot;argocd_app&quot; width=&quot;638&quot; height=&quot;453&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] ArgoCD 애플리케이션 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;애플리케이션 이름을 정의해주고 아래로 내리면 [그림 12]와 같은 화면이 나옵니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_12.png&quot; alt=&quot;argocd_app2&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] ArgoCD 애플리케이션 추가2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;레포지토리 주소와 배포할 yaml 파일들이 들어있는 경로를 명시해주고, 배포할 쿠버네티스의 클러스터 주소와 네임스페이스까지 작성하여 애플리케이션을 만들어줍니다.&lt;/p&gt;

    &lt;p&gt;정상적으로 애플리케이션이 만들어지면 다음 [그림 13]과 같이 ArgoCD에서 Git 레포지토리와 연동된 애플리케이션을 볼 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_13.png&quot; alt=&quot;argocd_app_check&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] ArgoCD 애플리케이션 추가 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;동기화 되지 않은 상태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OutOfSync&lt;/code&gt;라는 문구와 &lt;strong&gt;노란색&lt;/strong&gt;으로 표현이 되고, Sync 버튼을 눌러주면 쿠버네티스 클러스터에 자동으로 배포가 되면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync OK&lt;/code&gt; 라는 문구와 함께 &lt;strong&gt;초록색&lt;/strong&gt;으로 바뀌어 정상 동작하는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;ArgoCD에서 정상적으로 동기화를 시켜주면 다음 [그림 14]와 같은 화면을 보실 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_14.png&quot; alt=&quot;argocd_sync&quot; width=&quot;952&quot; height=&quot;309&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 14] ArgoCD 배포 동기화&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;[그림 13]에서 애플리케이션을 선택해 들어가면 [그림 14]와 같이 실행중인 애플리케이션을 지속적으로 모니터링할 수 있는 화면이 나오게 됩니다.&lt;/p&gt;

    &lt;p&gt;Git 레포지토리와 쿠버네티스 클러스터와의 차이점을 보고하고 시각화하는 동시에 라이브 상태를 원하는 상태로 동기화하는 기능을 제공합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 11 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/10/11/devsecops3.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/10/11/devsecops3.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>jenkins</category>
        
        <category>cd</category>
        
        <category>argocd</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - CI 구성</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 클라우드 네이티브 환경에서 DevSecOps 툴 체인 파이프라인을 구축하는 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;9월에 시작하여 11월 27일까지 진행되고 현재 진행 중이며, 내용이 긴 만큼 여러 포스트를 나눠 기록하고자 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 포스트의 내용은 프로젝트 도중 작성되어 추후 변경될 수 있음을 알립니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. CI(Continuous Integration) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.2. CI 란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. GitLab - Jenkins 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. GitLab - Jenkins 웹훅 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. Jenkins 파이프라인 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 파이프라인 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. Jenkins - Docker 연동 및 파이프라인 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-cicontinuous-integration-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. CI(Continuous Integration) 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CI 란?&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;CI 란 팀의 구성원들이 작업한 내용을 정기적으로 통합하는 것을 의미합니다.&lt;/p&gt;

    &lt;p&gt;개발자들은 소스 코드를 정기적으로 Git, SVN 과 같은 SCM(Source Code Management, 형상 관리 시스템)에 Push 하는데, &lt;strong&gt;각각의 개발자들로부터 Push된 소스 코드들을 정기적으로 통합하는 것을 CI&lt;/strong&gt;라고 합니다.&lt;/p&gt;

    &lt;p&gt;CI를 구축하지 않은 경우 개발자들이 각자 개발한 소스 코드를 형상 관리 서버에 Commit 하면 별도의 품질관리를 거치지 않고 대부분 개발이 끝난 막바지에 통합을 하여 테스트를 진행하게 됩니다.&lt;/p&gt;

    &lt;p&gt;이럴경우, 개발 중 별도의 품질 관리를 수행하지 않았기 때문에 잘못된 소스 코드를 형상관리 시스템에 반영하였을 경우 발생되는 문제가 개발 후반에 모두 장애로 발견됩니다.&lt;/p&gt;

    &lt;p&gt;반면에 CI를 구축하게 되면 CI 서버는 형상 관리 서버에 Push 된 소스코드를 주기적으로 폴링하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴파일, 단위테스트, 코드 인스펙션&lt;/code&gt; 등의 과정을 수행하며 &lt;strong&gt;신규 또는 수정된 소스 코드에 결함이 있는지에 대한 여부를 지속적으로 검증&lt;/strong&gt;하기 때문에 조기에 결함을 발견하여 해결할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GitLab - Jenkins 연동&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SCM 툴인 Gitlab과 CI/CD Server 툴로 사용할 Jenkins를 연동하는 작업을 시작하겠습니다.&lt;/p&gt;

    &lt;p&gt;먼저 [그림 1]과 같이 관리자 계정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Admin Area &amp;gt; Network&lt;/code&gt; 탭으로 들어와 아웃바운드를 설정합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_1.png&quot; alt=&quot;gitlab_outbound&quot; width=&quot;761&quot; height=&quot;650&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] GitLab 네트워크 아웃바운드 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;웹훅 및 서비스가 액세스 할 수 있는 IP, 즉 Jenkins 서버의 IP를 적어줍니다.&lt;/p&gt;

    &lt;p&gt;다음으로 &lt;strong&gt;GitLab 프로젝트를 생성&lt;/strong&gt;하여 해당 프로젝트의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings &amp;gt; Access Tokens&lt;/code&gt; 탭에 들어옵니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_2.png&quot; alt=&quot;gitlab_access_token&quot; width=&quot;671&quot; height=&quot;612&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] GitLab Access Token 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 2]와 같이 토큰 명과 만료일을 설정하고 액세스 토큰을 생성하면 토큰 값이 나옵니다.&lt;/p&gt;

    &lt;p&gt;토큰 값은 Jenkins에서 credentials를 생성할 때 필요하기 때문에 따로 기록해둡니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Jenkins의 설정의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plugin Manager&lt;/code&gt; 탭으로 GitLab 관련한 플러그인을 모두 설치해줍니다.&lt;/p&gt;

    &lt;p&gt;GitLab 플러그인이 정상적으로 설치되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 설정&lt;/code&gt;으로 들어와서 [그림 3]과 같이 Gitlab을 연동하기 위한 설정을 해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_3.png&quot; alt=&quot;jenkins_gitlab_config&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Jenkins에서 GitLab 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;GitLab 호스트의 URL 및 포트를 적어주고 Credentials는 Add 버튼을 눌러 다음 [그림 4]와 같이 생성하여 줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_4.png&quot; alt=&quot;jenkins_gitlab_credentials&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Jenkins에서 GitLab Credentials 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Credentials 키를 정상적으로 생성 및 선택해주고 오른쪽 하단의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Connection&lt;/code&gt; 버튼을 눌러 Success 문구가 뜨는지 확인합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GitLab - Jenkins 웹훅 설정&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins와 Gitlab을 성공적으로 연동시키고 나서 Jenkins 메인 화면에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로운 Item&lt;/code&gt; 탭을 눌러줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_5.png&quot; alt=&quot;jenkins_new_item&quot; width=&quot;831&quot; height=&quot;402&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Jenkins Item 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 5]와 같이 파이프라인을 선택하고 아이템의 이름을 명시하고 OK 버튼을 눌러 아이템을 만들어줍니다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devsecops-pipeline&lt;/code&gt;라는 이름의 아이템을 만들어주었습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 아이템을 정상적으로 만들어준 후에 Giblab의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings &amp;gt; Webhooks&lt;/code&gt; 탭으로 들어옵니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_6.png&quot; alt=&quot;gitlab_webhook&quot; width=&quot;754&quot; height=&quot;357&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] GitLab 웹훅 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 6]와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://JenkinsID:JenkinsPassword@JenkinsIP:JenkinsPort/project/ProjectName&lt;/code&gt;의 형태로 URL을 작성해줍니다.&lt;/p&gt;

    &lt;p&gt;일단 설정은 푸시 이벤트에 대한 트리거만 걸어놓고 차후 멀티 브랜치에 대한 파이프라인 구성도 진행해볼 것입니다.&lt;/p&gt;

    &lt;p&gt;웹훅 설정을 마치고 아래로 내리면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test&lt;/code&gt; 버튼을 눌러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Push events&lt;/code&gt;에 대한 테스트를 진행해봅니다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hook executed successfully: HTTP 200&lt;/code&gt; 메시지가 뜨면 푸시 이벤트에 대한 웹훅도 정상적으로 설정되어 Jenkins를 통해 CI를 구성할 준비가 끝난 것입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-jenkins-파이프라인-설정---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. Jenkins 파이프라인 설정&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipeline 설정 및 테스트&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;[그림 5]에서 생성한 파이프라인의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구성&lt;/code&gt; 탭을 눌러서 다음 [그림 7]과 같이 Gitlab에 푸시되면 자동으로 파이프라인이 실행될 수 있도록 설정해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_7.png&quot; alt=&quot;gitlab_webhook&quot; width=&quot;846&quot; height=&quot;478&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] GitLab 웹훅 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;아래로 쭉 내리면 [그림 8]과 같이 파이프라인 스크립트를 작성할 수 있는 공간이 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_8.png&quot; alt=&quot;echo_hello_world&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] Hello World 파이프라인 스크립트 작성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Gitlab에 푸시했을 때 정상적으로 파이프라인이 작동하는지만 확인해보기 위해 ‘Hello World’를 출력하는 간단한 스크립트를 작성하여 설정을 저장했습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그러고나서 깃 푸시 이벤트를 보내면 다음 [그림 9]와 같이 자동으로 설정해둔 파이프라인이 정상적으로 실행되는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_9.png&quot; alt=&quot;pipeline_result&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] 파이프라인 실행 결과 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;실행된 파이프라인에 대한 로그는 해당 빌드 넘버를 클릭하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console Output&lt;/code&gt; 탭을 눌러 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_10.png&quot; alt=&quot;build_console&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] 파이프라인 실행 콘솔 로그 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;[그림 10]에서 볼 수 있듯이 정상적으로 파이프라인이 실행되어 콘솔에 ‘Hello World’ 문구가 출력된 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins - Docker 연동 및 파이프라인 테스트&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Gitlab과 Jenkins가 정상적으로 연동되어 Git Push에 의해 자동으로 파이프라인이 실행되는 부분까지 진행하였고 다음으로 파이프라인에서 &lt;strong&gt;git clone하여&lt;/strong&gt; 프로젝트 폴더의 Dockerfile을 통해 빌드하여 &lt;strong&gt;Docker hub에 푸시하는 부분까지 진행&lt;/strong&gt;하겠습니다.&lt;/p&gt;

    &lt;p&gt;우선 Jenkins가 설치되어 있는 노드에서 Git 혹은 Docker 관련 스크립트 실행시 커맨드 에러가 발생할 수 있으므로 servers 인스턴스에서 다음 명령어를 통해 파이프라인에서 Git과 Docker 명령을 사용할 수 있도록 해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker docker-registry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;docker 명령을 입력했을 때 권한 에러를 해결하기 위한 설정도 해주어야 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;service docker restart
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo chmod &lt;/span&gt;777 /var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그리고 Jenkins에서 [그림 11]에 보이는 Docker 관련 플러그인을 설치해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_11.png&quot; alt=&quot;docker_plugin_installation&quot; width=&quot;788&quot; height=&quot;319    &quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] Jenkins에서 Docker 플러그인 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Docker hub에 로그인 할 계정의 Credentials을 생성해야 합니다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;추후 Harbor로 변경할 예정입니다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_12.png&quot; alt=&quot;docker_hub_credentials&quot; width=&quot;636&quot; height=&quot;239&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] Docker hub credentials 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 Docker 관련 설정이 정상적으로 완료되면 파이프라인 스크립트를 다음과 같이 작성해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          registry &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513/flask-app&quot;&lt;/span&gt;
          registryCredential &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'crisis513'&lt;/span&gt;
          dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
          releaseName &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-app&quot;&lt;/span&gt;
          release_version &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'latest'&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      agent any
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Cloning our Git'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s1&quot;&gt;'http://GITLAB_SERVER_IP:8001/root/flask-app.git'&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Building docker image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry + &lt;span class=&quot;s2&quot;&gt;&quot;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Deploy docker image'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;, registryCredential &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          dockerImage.push&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Cleaning up'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;docker rmi &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$registry&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;파이프라인 스크립트의 문법에 대해 알고싶다면 &lt;a href=&quot;https://www.jenkins.io/doc/book/pipeline/syntax/&quot;&gt;Jenkins Pipeline Syntax&lt;/a&gt;에서 확인하시면 됩니다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;파이프라인은 다음과 같이 실행됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;GitLab 서버에서 flask-app 프로젝트를 가져와서 프로젝트 내의 Dockerfile을 통해 빌드하고 ‘crisis513’ 이라는 ID를 가진 credentials를 통해 Docker hub에 로그인 하여 해당 도커 레포지토리(registry)에 release_version에 해당하는 태그를 붙여 푸시하고 로컬에 생성된 도커 이미지는 삭제됩니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Dockerfile의 내용은 다음과 같습니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  FROM python:alpine

  RUN apk add &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; linux-headers build-base

  COPY requirements.txt /requirements.txt

  RUN pip &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; /requirements.txt

  COPY ./app /app
  WORKDIR /app
  RUN pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;flask

  RUN &lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database.db
  RUN python ./setup.py

  EXPOSE 8080
  CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;uwsgi&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;--ini&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;conf.ini&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;해당 Dockerfile이 포함된 프로젝트는 &lt;a href=&quot;https://github.com/crisis513/flask-app&quot;&gt;git - crisis513/flask-app&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;위의 파이프라인이 정상적으로 실행된 결과는 다음 [그림 13]과 같습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_13.png&quot; alt=&quot;docker_push_pipeline_result&quot; width=&quot;858&quot; height=&quot;382&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] Docker 푸시까지의 파이프라인 실행 결과&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Docker hub에 접속하면 도커 이미지도 정상적으로 푸시된 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기까지 GitLab - Jenkins - Docker를 연동하여 Git 푸시 이벤트가 발생했을 때 Git 프로젝트를 clone하여 Dockerfile을 빌드하여 Docker hub에 푸시하기까지의 과정을 모두 끝냈습니다.&lt;/p&gt;

    &lt;p&gt;다음은 CD(Continuous Delivery/Continuous Deployment) 환경을 구성하는 방법에 대해 알아보겠습니다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 08 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/10/08/devsecops2.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/10/08/devsecops2.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>gitlab</category>
        
        <category>jenkins</category>
        
        <category>ci</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - 개요 및 환경 구성</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 클라우드 네이티브 환경에서 DevSecOps 툴 체인 파이프라인을 구축하는 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;9월에 시작하여 11월 27일까지 진행되고 현재 진행 중이며, 내용이 긴 만큼 여러 포스트를 나눠 기록하고자 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 포스트의 내용은 프로젝트 도중 작성되어 추후 변경될 수 있음을 알립니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.1. 프로젝트 소개&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 프로젝트 목적&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. 프로젝트 아키텍처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 환경 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. GCP(Google Cloud Platform) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 쿠버네티스 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. GitLab 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_4&quot;&gt;   2.4. Jenkins 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-프로젝트-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 프로젝트 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 소개&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;많은 기업들이 클라우드 환경으로의 디지털 트랜스포메이션을 진행하면서, 기존의 보안 쳬계와 다른 클라우드 네이티브 환경에서의 보안을 어렵게 생각하는 경우가 많습니다.&lt;/p&gt;

    &lt;p&gt;온프레미스와는 전혀 다른 방식으로 보안을 구현해야하는 필요성이 대두되었고, 클라우드 환경에서는 기업마다 다른 개발환경과 개발문화로 인한 변화의 폭이 훨씬 크므로, 자동화되고 가시화된 개발보안방법론인 DevSecOps 쳬계를 적용하므로써 빠르게 변화하는 서비스 개발 속도에 발맞춰 보안의 속도도 따라가야 할 필요가 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 목적&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트를 통해 클라우드 네이티브 환경에서 DevSecOps 체계를 구현하는데 필요한 툴 체인들을 이해하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보안이 적용된 다양한 툴 체인 파이프라인 방법들을 구축&lt;/code&gt;하고자 합니다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;클라우드 네이티브 환경에서의 DevSecOps 쳬계와 CI/CD 체계를 이해&lt;/strong&gt;하고, 이 체계에 적용되는 보안 분석 도구들을 구축하여 &lt;strong&gt;실제 서비스 개발 프로세스에 적용할 수 있는 DevSecOps 툴체인 파이프라인 구축하는 것이 목적&lt;/strong&gt;입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 아키텍처&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트의 아키텍처는 다음 [그림 1]과 같습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_1.png&quot; alt=&quot;devops_architecture&quot; width=&quot;778&quot; height=&quot;513&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] DevOps 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;GitLab, Jenkins, Harbor, Helm을 이용해 CI(Continuous Integration)를, Jenkins, ArgoCD, Kubernetes를 통해 CD(Continuous Delivery/Continuous Deployment) 환경을 구축하고 파이프라인 실행 결과를 Slack으로 전달합니다.&lt;/p&gt;

    &lt;p&gt;그리고 서비스 운영에 필요한 로깅 시스템은 EFK(Elasticsearch-Fluentd-Kibana)를, 모니터링 시스템은 Prometheus, Grafana를 쿠버네티스의 서비스 형태로 구축하였습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;[그림 1]은 현재(2020-10-17)까지 진행된 부분이며, Security에 대한 파이프라인은 미완성으로 추후 아키텍처를 업데이트 할 예정입니다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-환경-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 환경 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GCP(Google Cloud Platform) 구성&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;GCP의 기능으로 있는 GKE(Google Kubernetes Engine)을 사용하여 손 쉽게 쿠버네티스 환경을 구성할 수 있지만, 현재는 테스트용으로 인스턴스를 따로 생성하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubeadm&lt;/code&gt;을 통해 쿠버네티스를 구성할 것 입니다.&lt;/p&gt;

    &lt;p&gt;따라서 다음 [그림 2]와 같이 GCP 인스턴스를 생성해줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_2.png&quot; alt=&quot;gcp_instance&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] GCP 인스턴스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인스턴스 생성할 때의 설정은 다음과 같습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;리전: asia-northeast3(서울)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;머신 계열: n1-standard-2(vCPU 2개, 7.5GB 메모리)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;부팅 디스크: CentOS 7&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;액세스 범위: 모든 Cloud API에 대한 전체 액세스 허용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방화벽: HTTP/HTTPS 트래픽 허용&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;추가로 [VPC 네트워크] - [외부 IP 주소] 탭에 들어가 각 인스턴스들의 IP를 고정으로 바꿔주었습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;쿠버네티스 구성&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;위에서 언급하였듯 생성한 인스턴스에 kubeadm 명령을 통해 쿠버네티스를 구성합니다.&lt;/p&gt;

    &lt;p&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-master, kube-worker1, kube-worker2 모두&lt;/code&gt; 동일하게 아래의 명령을 실행하도록 합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;쿠버네티스 설치를 위한 모든 과정은 root 권한으로 진행합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;su -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;스왑 메모리 사용 중지합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;swapoff &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;0 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/vm/swappiness
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/swap/ s/^#*/#/'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;Swap은 디스크의 일부 공간을 메모리처럼 사용하는 기능입니다. 
  Kubelet이 정상 동작할 수 있도록 swap 디바이스와 파일 모두 disable 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;각 노드의 통신을 원활하게 하기 위해 방화벽을 해제하고 SELinux를 비활성화 시켜줍니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl disable firewalld
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl stop firewalld

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;setenforce 0
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'s/^SELINUX=enforcing$/SELINUX=permissive/'&lt;/span&gt; /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RHEL과 CentOS 7에서 iptables 관련 이슈가 있어 커널 매개변수를 다음과 같이 수정하고 적용합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt;  /etc/sysctl.d/k8s.conf
  net.bridge.bridge-nf-call-ip6tables = 1
  net.bridge.bridge-nf-call-iptables = 1
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;  EOF

&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sysctl &lt;span class=&quot;nt&quot;&gt;--system&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;br_netfilter 모듈을 활성화합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;modprobe br_netfilter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;br_netfilter 모듈을 명시적으로 추가한 후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsmod | grep br_netfilter&lt;/code&gt; 명령어로 추가 여부를 확인할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도커 및 쿠버네티스 설치 후 서비스 시작&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;docker &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start docker.service

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt; /etc/yum.repos.d/kubernetes.repo
  [kubernetes]
  name=Kubernetes
  baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
  enabled=1
  gpgcheck=1
  repo_gpgcheck=1
  gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
  exclude=kube*
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;  EOF

&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; yum-utils device-mapper-persistent-data lvm2
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum-config-manager &lt;span class=&quot;nt&quot;&gt;--add-repo&lt;/span&gt; https://download.docker.com/linux/centos/docker-ce.repo 
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-ce-18.06.2.ce
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--disableexcludes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kubernetes kubeadm-1.15.5-0.x86_64 kubectl-1.15.5-0.x86_64 kubelet-1.15.5-0.x86_64
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;kubelet &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;본 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;헬스체크 이슈&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대쉬보드 호환성&lt;/code&gt;의 이유로 비교적 안정적인 쿠버네티스 1.15 버전으로 명시하여 설치하였습니다.&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;처음에 1.19 버전으로 설치했었다가 쿠버네티스 클러스터의 매트릭을 수집해주는 &lt;strong&gt;kube-state-metrics&lt;/strong&gt;이 정상적으로 작동하지 않아 1.15버전으로 재설치한 것입니다.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-master&lt;/code&gt;에서만 아래의 명령을 실행하도록 합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨트롤 구성 요소들의 이미지를 설치합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm config images pull
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kube-master 노드를 초기화 해줍니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm init
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;init] Using Kubernetes version: v1.15.5
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Running pre-flight checks
          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;WARNING Service-Kubelet]: kubelet service is not enabled, please run &lt;span class=&quot;s1&quot;&gt;'systemctl enable kubelet.service'&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Pulling images required &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;setting up a Kubernetes cluster
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] This might take a minute or two, depending on the speed of your internet connection
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] You can also perform this action &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;beforehand using &lt;span class=&quot;s1&quot;&gt;'kubeadm config images pull'&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet environment file with flags to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/kubeadm-flags.env&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet configuration to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/config.yaml&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Activating the kubelet service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;certs] Using certificateDir folder &lt;span class=&quot;s2&quot;&gt;&quot;/etc/kubernetes/pki&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;certs] Generating &lt;span class=&quot;s2&quot;&gt;&quot;ca&quot;&lt;/span&gt; certificate and key

  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Your Kubernetes control-plane has initialized successfully!
  To start using your cluster, you need to run the following as a regular user:
  &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube
  &lt;span class=&quot;nb&quot;&gt;sudo cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; /etc/kubernetes/admin.conf &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
  &lt;span class=&quot;nb&quot;&gt;sudo chown&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;:&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
  You should now deploy a pod network to the cluster.
  Run &lt;span class=&quot;s2&quot;&gt;&quot;kubectl apply -f [podnetwork].yaml&quot;&lt;/span&gt; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/
  Then you can &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;any number of worker nodes by running the following on each as root:
  kubeadm &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;10.178.0.19:6443 &lt;span class=&quot;nt&quot;&gt;--token&lt;/span&gt; tcqjev.d775p70aj3dseele &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;--discovery-token-ca-cert-hash&lt;/span&gt; sha256:d9f67f85ea3e5ca8821dd311cf0c3c886d9637c14814b61f15f67e06f732b200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kubeadm init의 결과에서 나온 것 처럼 일반 사용자가 kubectl 명령을 사용할 수 있도록 환경변수를 설정합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; /etc/kubernetes/admin.conf &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo chown&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;:&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 kubeadm init의 결과에서 나온 것 처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-worker 노드들&lt;/code&gt;에서만 아래의 명령을 실행하도록 합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨트롤 구성 요소들의 이미지를 설치합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;10.178.0.19:6443 &lt;span class=&quot;nt&quot;&gt;--token&lt;/span&gt; tcqjev.d775p70aj3dseele &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;--discovery-token-ca-cert-hash&lt;/span&gt; sha256:d9f67f85ea3e5ca8821dd311cf0c3c886d9637c14814b61f15f67e06f732b200
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Running pre-flight checks
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Reading configuration from the cluster...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] FYI: You can look at this config file with &lt;span class=&quot;s1&quot;&gt;'kubectl -n kube-system get cm kubead
  m-config -oyaml'&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Downloading configuration &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the kubelet from the &lt;span class=&quot;s2&quot;&gt;&quot;kubelet-config-1.15&quot;&lt;/span&gt; Con
  figMap &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the kube-system namespace
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet configuration to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/config.yaml&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet environment file with flags to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/kubead
  m-flags.env&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Activating the kubelet service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Waiting &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the kubelet to perform the TLS Bootstrap...
  This node has joined the cluster:
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Certificate signing request was sent to apiserver and a response was received.
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; The Kubelet was informed of the new secure connection details.
  Run &lt;span class=&quot;s1&quot;&gt;'kubectl get nodes'&lt;/span&gt; on the control-plane to see this node &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;the cluster.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;마지막으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-master&lt;/code&gt;에서 weave를 설치합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;kubectl apply를 통해 weave 생성&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://cloud.weave.works/k8s/net?k8s-version=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl version | &lt;span class=&quot;nb&quot;&gt;base64&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;tr&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  serviceaccount/weave-net created
  clusterrole.rbac.authorization.k8s.io/weave-net created
  clusterrolebinding.rbac.authorization.k8s.io/weave-net created
  role.rbac.authorization.k8s.io/weave-net created
  rolebinding.rbac.authorization.k8s.io/weave-net created
  daemonset.apps/weave-net created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;CNI(Container Network Interface)를 설치하면 CoreDNS Pod가 정상적으로 동작하게 됩니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;쿠버네티스 클러스터가 정상적으로 구성되었는지 확인해봅니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get nodes
  NAME           STATUS   ROLES    AGE   VERSION
  kube-master    Ready    master   1d   v1.15.5
  kube-worker1   Ready    &amp;lt;none&amp;gt;   1d   v1.15.5
  kube-worker2   Ready    &amp;lt;none&amp;gt;   1d   v1.15.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get cs
  NAME                 STATUS    MESSAGE             ERROR
  controller-manager   Healthy   ok                  
  scheduler            Healthy   ok                  
  etcd-0               Healthy   &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;health&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get po &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; custom-columns&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;POD:metadata.name,NODE:spec.nodeName &lt;span class=&quot;nt&quot;&gt;--sort-by&lt;/span&gt; spec.nodeName &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
  POD                                   NODE
  kube-proxy-ks9ss                      kube-master
  etcd-kube-master                      kube-master
  kube-apiserver-kube-master            kube-master
  kube-controller-manager-kube-master   kube-master
  kube-scheduler-kube-master            kube-master
  weave-net-4g8fj                       kube-master
  kube-proxy-mg5z5                      kube-worker1
  weave-net-rjqk5                       kube-worker1
  coredns-5c98db65d4-xd8lw              kube-worker1
  coredns-5c98db65d4-zf5kx              kube-worker2
  weave-net-gvwqv                       kube-worker2
  kube-proxy-7jd9r                      kube-worker2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GitLab 구성&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Gitlab과 Jenkins 설치는 [그림 2]의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;servers 인스턴스&lt;/code&gt;에서 진행합니다.&lt;/p&gt;

    &lt;p&gt;GitLab은 자체 CI를 무료로 제공하고 있어 외부 CI 서비스를 사용할 필요가 없습니다.&lt;/p&gt;

    &lt;p&gt;하지만 Jenkins에서 제공되는 플러그인이 많기 때문에 보안을 적용한 파이프라인을 구축하기에는 외부 CI/CD 서비스인 Jenkins를 사용할 것이고, 기존의 서비스 중인 Github 혹은 Gitlab을 사용해도 무방합니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;GitLab 설치 및 설정&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;# openssh 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; curl policycoreutils-python openssh-server openssh-clients

  &lt;span class=&quot;c&quot;&gt;# 서버 부팅 시 sshd 실행&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;sshd &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start sshd

  &lt;span class=&quot;c&quot;&gt;# 방화벽 해제&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 메일서버 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; postfix

  &lt;span class=&quot;c&quot;&gt;# 서버 부팅 시 메일서버 실행&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;postfix &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start postfix

  &lt;span class=&quot;c&quot;&gt;# gitlab 패키치 저장소 등록 및 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sS&lt;/span&gt; https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;bash
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;EXTERNAL_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;servers IP:8001&quot;&lt;/span&gt; yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; gitlab-ce
  gitlab Reconfigured!

      &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;                 &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;*****&lt;/span&gt;               &lt;span class=&quot;k&quot;&gt;*****&lt;/span&gt;
      .&lt;span class=&quot;k&quot;&gt;******&lt;/span&gt;             &lt;span class=&quot;k&quot;&gt;*******&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;********&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;********&lt;/span&gt;
  ,,,,,,,,,&lt;span class=&quot;k&quot;&gt;***********&lt;/span&gt;,,,,,,,,,
  ,,,,,,,,,,,&lt;span class=&quot;k&quot;&gt;*********&lt;/span&gt;,,,,,,,,,,,
  .,,,,,,,,,,,&lt;span class=&quot;k&quot;&gt;*******&lt;/span&gt;,,,,,,,,,,,,
      ,,,,,,,,,&lt;span class=&quot;k&quot;&gt;*****&lt;/span&gt;,,,,,,,,,.
          ,,,,,,,&lt;span class=&quot;k&quot;&gt;****&lt;/span&gt;,,,,,,
              .,,,&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;,,,,
                  ,&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,.


      _______ __  __          __
      / ____&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; /_/ /   ____ _/ /_
  / / __/ / __/ /   / __ &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/ __ &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  / /_/ / / /_/ /___/ /_/ / /_/ /
  &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;___/_/&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;_/_____/&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;_,_/_.___/


  Thank you &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;installing GitLab!
  GitLab should be available at http://servers IP:8001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;Gitlab이 정상적으로 설치되면 Gitlab에서 사용할 포트 및 기타 설정을 해줍니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;# GitLab 설정파일에서 해당 라인 주석 해제 혹은 추가&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi /etc/gitlab/gitlab.rb
  32 external_url &lt;span class=&quot;s1&quot;&gt;'http://servers IP:8001'&lt;/span&gt;
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  1215 nginx[&lt;span class=&quot;s1&quot;&gt;'enable'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true 
  &lt;/span&gt;1216 nginx[&lt;span class=&quot;s1&quot;&gt;'client_max_body_size'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2G'&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 변경된 설정 적용&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gitlab-ctl reconfigure

  &lt;span class=&quot;c&quot;&gt;# 8001 방화벽 해제&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8001/tcp
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;Gitlab의 설정을 끝내고 Gitlab에 접속하기 전에 &lt;strong&gt;GCP의 방화벽도 열어주어야 외부에서 접근이 가능&lt;/strong&gt;합니다.&lt;/p&gt;

        &lt;p&gt;다음 [그림 3]과 같이 &lt;strong&gt;[VPC 네트워크] - [방화벽] 탭&lt;/strong&gt;에서 servers에서 사용할 포트들을 열어주기 위한 방화벽 규칙을 생성해줍니다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_3.png&quot; alt=&quot;gcp_firewall&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] GCP 방화벽 포트 오픈&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;GCP 방화벽까지 열어주고나서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;servers IP:8001&lt;/code&gt; URL로 접속하면 다음 [그림 3]과 같이 root 계정의 초기 패스워드를 지정하는 화면을 볼 수 있습니다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_4.png&quot; alt=&quot;gitlab_new_password&quot; width=&quot;569&quot; height=&quot;385&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] GitLab 접속 후 패스워드 변경&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins 구성&lt;/strong&gt;   &lt;a name=&quot;list2_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Jenkins 설치 및 설정&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;# Java 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; java-1.8.0-openjdk-devel.x86_64

  &lt;span class=&quot;c&quot;&gt;# JAVA_HOME 환경변수 확인&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;which javac
  /usr/bin/javac
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;readlink&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /usr/bin/javac
  /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/bin/javac

  &lt;span class=&quot;c&quot;&gt;# 경로 뒤의 /bin/javac는 제외하고 JAVA_HOME 환경변수 설정&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;sudo tee&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /etc/profile
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;
  /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64

  &lt;span class=&quot;c&quot;&gt;# maven 설치 (http://maven.apache.org/download.cgi)&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mkdir&lt;/span&gt; /tools
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tools
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;wget http://mirror.apache-kr.org/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo tar &lt;/span&gt;xzf apache-maven-3.6.3-bin.tar.gz
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; apache-maven-3.6.3 maven
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi /etc/profile.d/maven.sh
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;MAVEN_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/tools/maven
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;MAVEN_HOME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/bin:&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile.d/maven.sh

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mvn &lt;span class=&quot;nt&quot;&gt;-version&lt;/span&gt;
  Apache Maven 3.6.3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cecedd343002696d0abb50b32b541b8a6ba2883f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  Maven home: /tools/maven
  Java version: 1.8.0_262, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre
  Default locale: en_US, platform encoding: UTF-8
  OS name: &lt;span class=&quot;s2&quot;&gt;&quot;linux&quot;&lt;/span&gt;, version: &lt;span class=&quot;s2&quot;&gt;&quot;3.10.0-1127.el7.x86_64&quot;&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;amd64&quot;&lt;/span&gt;, family: &lt;span class=&quot;s2&quot;&gt;&quot;unix&quot;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# Jenkins repo 다운로드 및 key import&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;wget &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;rpm &lt;span class=&quot;nt&quot;&gt;--import&lt;/span&gt; https://pkg.jenkins.io/redhat-stable/jenkins.io.key

  &lt;span class=&quot;c&quot;&gt;# Jenkins 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; jenkins

  &lt;span class=&quot;c&quot;&gt;# Jenkins 기본 포트 변경&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi /etc/sysconfig/jenkins
  56 &lt;span class=&quot;nv&quot;&gt;JENKINS_PORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;8002&quot;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 8002 방화벽 해제&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--new-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins &lt;span class=&quot;nt&quot;&gt;--set-short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Jenkins Service Ports&quot;&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins &lt;span class=&quot;nt&quot;&gt;--set-description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Jenkins service firewalld port exceptions&quot;&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8002/tcp 
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 서버 부팅 시 Jenkins 실행&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start jenkins &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;Jenkins에 접속하기 위한 포트는 8002로 설정하였고 GCP 방화벽에서 이미 포트를 열어둔 상태입니다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_5.png&quot; alt=&quot;jenkins_install&quot; width=&quot;520&quot; height=&quot;462&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Jenkins 접속&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;servers IP:8002&lt;/code&gt; URL로 접속하면 위의 [그림 5]와 같이 화면이 뜹니다.&lt;/p&gt;

        &lt;p&gt;화면의 안내에 따라 &lt;strong&gt;/var/lib/jenkins/secrets/initialAdminPassword 파일을 확인&lt;/strong&gt;합니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo cat&lt;/span&gt; /var/lib/jenkins/secrets/initialAdminPassword
  f05ef37257944b62a80086bbc4b047bf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;Jenkins 초기 비밀번호를 확인하고 입력하여 다음으로 넘어갑니다.&lt;/p&gt;

        &lt;p&gt;다음은 Customize Jenkins라는 페이지가 나오는데, 여기서는 원하는 Jenkins 플러그인을 설치할 수 있습니다.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Jenkins 플러그인은 Jenkins가 설치된 이후에도 자유롭게 설치가 가능&lt;/strong&gt;하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Install suggested plugins&lt;/code&gt;를 눌러 기본 플러그인만 설치하고 넘어갑니다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;Jenkins가 정상적으로 설치되면 다음 [그림 6]과 같은 화면이 뜨게 됩니다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_6.png&quot; alt=&quot;jenkins_main&quot; width=&quot;563&quot; height=&quot;389&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] Jenkins 정상 설치 화면&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이로써 쿠버네티스 클러스터와 GitLab, Jenkins의 설치 및 기본 구성은 끝이 났습니다.&lt;/p&gt;

    &lt;p&gt;다음은 CI(Continuous Integration) 환경을 구성하는 방법에 대해 알아보겠습니다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 03 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/10/03/devsecops1.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/10/03/devsecops1.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>kubernetes</category>
        
        <category>gitlab</category>
        
        <category>jenkins</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Docker] 도커 이미지</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 도커 이미지 제작 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. 이미지 태그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 이미지 업로드&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. 이미지 제작&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. Dockerfile 이미지 제작&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-도커-이미지-제작---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 도커 이미지 제작&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이미지 태그&lt;/strong&gt; &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;이미지의 이름을 변경하는 기능은 없으며, 태그 기능을 사용하여 이미지를 가리키는 이름을 하나 추가 하는 형태 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;태그 지정 : “허브ID/저장소이름:태그” 형태 유지&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실습 - docker tag&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images
  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
  httpd               latest              a6ea92c35c43        5 days ago          166MB
  mysql               5.7                 718a6da099d8        6 days ago          448MB
  ubuntu              latest              1e4467b07108        2 weeks ago         73.9MB
  centos              latest              831691599b88        7 weeks ago         215MB

  &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;1. docker tag&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker tag centos:latest mycentos:latest
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images
  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
  centos              latest              831691599b88        7 weeks ago         215MB
  &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;mycentos            latest              831691599b88        7 weeks ago         215MB&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt; 

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker tag centos:latest nobreak/docker:centos 

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images
  REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
  mycentos            latest              831691599b88        7 weeks ago         215MB
  &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;nobreak/docker      centos              831691599b88        7 weeks ago         215MB&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이미지 업로드&lt;/strong&gt; &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;이미지를 업로드하려면 먼저 저장소에 로그인 해야 함&lt;/p&gt;

        &lt;p&gt;→ 로그인한 후에 push 명령으로 업로드 가능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이미지를 업로드할 때 반드시 docker login 명령으로 로그인한 사용자의 아이디와 이미지의 이름의 앞의 값이 같아야 함&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실습 - 이미지 업로드&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; anonymous email : triclobufr@matra.top

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker tag mycentos:latest triclobufr/mycentos:latest

  1. docker login&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker login
  Login with your Docker ID to push and pull images from Docker Hub. If you &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;not have a Docker ID, &lt;span class=&quot;nb&quot;&gt;head &lt;/span&gt;over to https://hub.docker.com to create one.
  Username: triclobufr
  Password: 
  WARNING! Your password will be stored unencrypted &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/user/.docker/config.json.
  Configure a credential helper to remove this warning. See
  https://docs.docker.com/engine/reference/commandline/login/#credentials-store

  Login Succeeded

  2. docker push    → 저장소에 이미지를 업로드
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker push triclobufr/mycentos:latest

  3. docker &lt;span class=&quot;nb&quot;&gt;logout&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;logout&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;도커 허브에서 확인&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67e64e18-a7dc-402c-95b5-3f0828b296e7/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67e64e18-a7dc-402c-95b5-3f0828b296e7/Untitled.png&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이미지 제작&lt;/strong&gt; &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;생성된 컨테이너에서 이미지를 생성&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;컨테이너의 파일 시스템을 추출하여 이미지를 생성&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실습 - docker commit&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1. docker commit → 생성된 컨테이너 기반으로 이미지 생성
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker commit web5 triclobufr/myweb:0.1

  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; docker images 명령으로 확인
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images 
  REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
  triclobufr/myweb      0.1                 42696f6ed819        13 seconds ago      166MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실습 - docker export / import&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1. docker &lt;span class=&quot;nb&quot;&gt;export&lt;/span&gt;  → 컨테이너 파일 시스템을 추출하여 아카이브 파일로 생성
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; export.tar web5

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; export.tar 
  &lt;span class=&quot;nt&quot;&gt;-rw-------&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 user user 167300096  8월 11 12:19 export.tar

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;tvf export.tar

  2. docker import → export로 추출된 아카이브 파일을 이미지화
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker import export.tar myweb:import

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect myweb:import
  &lt;span class=&quot;s2&quot;&gt;&quot;RootFS&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;Type&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;layers&quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;Layers&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
       &lt;span class=&quot;s2&quot;&gt;&quot;sha256:08574ce553601b4be46f0c7f5bf4228e2a650840a9f80291a87db8e8abdc277a&quot;&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
  → 레이어가 하나로 통합
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-dockerfile-이미지-제작---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. Dockerfile 이미지 제작&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dockerfile 개요&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;도커는 Dockerfile을 사용하여 이미지 제작 가능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;여러가지 지시어를 사용하여 이미지 제작 가능&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dockerfile 지시어&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Dockerfile은 다양한 지시어를 가지고 있음&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Dockerfile 지시어 → [책 참고]&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RUN, CMD, ENTRYPOINT 지시어 → exec 와 shell 형식 사용&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;exec : [“yum”, “-y”, “install”. “httpd”]&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;shell : yum -y install httpd&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dockerfile 실습&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1. 폴더 생성
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;centos_web
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;centos_web/

  2. Dockerfile 생성
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim Dockerfile
  FROM centos:latest
  MAINTAINER nobreak
  RUN yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;httpd
  CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/sbin/httpd&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;-D&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;FOREGROUND&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  ENV WEBPORT 80
  EXPOSE &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WEBPORT&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
  EXPOSE 443
  VOLUME /var/www/html
  COPY index.html /var/www/html/index.html

  3. index.html 생성
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;CentOS apache&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; index.html

  4. docker build 명령 → 이미지 제작
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; triclobufr/centosweb:latest &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

  5. docker images 명령으로 확인
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images triclobufr/centosweb:latest 
  REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
  triclobufr/centosweb   latest              cd18168344ab        21 seconds ago      254MB

  6. 컨테이너 생성 &amp;amp; 확인
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; centosweb &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; triclobufr/centosweb:latest
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect centosweb

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker centos_web]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl 172.17.0.4
  CentOS apache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 03 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/infra/2020/09/03/docker4.html</link>
        <guid isPermaLink="true">http://localhost:4000/infra/2020/09/03/docker4.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>image</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Docker] 도커 네트워크</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 도커 네트워크 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. 네트워크 드라이버&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. bridge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. host&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_4&quot;&gt;   1.4. none&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_5&quot;&gt;   1.5. overlay&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_6&quot;&gt;   1.6. macvlan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 컨테이너의 통신&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 포트 포워딩&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-도커-네트워크---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 도커 네트워크&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;네트워크 드라이버&lt;/strong&gt; &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;docker network ls    → 네트워크 드라이버 목록 확인&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network &lt;span class=&quot;nb&quot;&gt;ls
 &lt;/span&gt;NETWORK ID          NAME                DRIVER              SCOPE
 b3b9ff62fe49        bridge              bridge              &lt;span class=&quot;nb&quot;&gt;local
 &lt;/span&gt;aeca1add77f7        host                host                &lt;span class=&quot;nb&quot;&gt;local
 &lt;/span&gt;766cc2ddc934        none                null                &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bridge&lt;/strong&gt;    &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨테이너가 사용하는 프라이빗 네트워크&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;같은 bridge에 연결되어 있으면 컨테이너의 IP주소로 통신 가능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;외부와 통신도 가능함 → NAPT 통신 사용, 외부와 통신하기 위해서 포트포워딩 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;bridge 네트워크 실습&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;docker network create   → 네트워크 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect bridge
 → 해당 네트워크의 대역과 연결되어 있는 컨테이너의 목록 및 IP 주소 확인 가능 

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network create &lt;span class=&quot;nt&quot;&gt;--subnet&lt;/span&gt; 172.18.0.0/16 &lt;span class=&quot;nt&quot;&gt;--gateway&lt;/span&gt; 172.18.0.1 net1

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network &lt;span class=&quot;nb&quot;&gt;ls
 &lt;/span&gt;NETWORK ID          NAME                DRIVER              SCOPE
 b3b9ff62fe49        bridge              bridge              &lt;span class=&quot;nb&quot;&gt;local
 &lt;/span&gt;aeca1add77f7        host                host                &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;7854534b99b2      net1                bridge              &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
 766cc2ddc934        none                null                &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;net1을 사용하는 컨테이너 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-itd&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os5 &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; net1 centos:latest

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;os5 ip a s
 1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
     &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     inet 127.0.0.1/8 scope host lo
     valid_lft forever preferred_lft forever
 12: eth0@if13: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
     &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
     inet &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;172.18.0.2/16&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt; brd 172.18.255.255 scope global eth0
     valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;host&lt;/strong&gt;  &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;호스트에서 컨테이너의 네트워크 격리를 해제하여 호스트의 네트워크 정보를 공유해서 사용하는 방법&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;host 네트워크 실습&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web4 &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; host httpd:latest 
  06f5be6f136862da2df9ee875c71167820eabd29c489c934b2834db859258762

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl localhost
  &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;It works!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; host &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os6 &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; centos:latest
  → 원래 호스트의 ip가 나옴

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker stop web4
  web4

  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; httpd 설치
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;httpd
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start httpd
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl status httpd

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl localhost

  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; host 네트워크를 사용하는 webserver2 컨테이너 생성
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; webserver2 &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; host httpd:latest
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl localhost
  → 호스트 OS에 있는 httpd.service가 출력
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;none&lt;/strong&gt;  &lt;a name=&quot;list1_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨테이너의 네트워크 기능을 사용 X&lt;/p&gt;

        &lt;p&gt;→ Interface를 할당하지 않을 때 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;none 네트워크 실습&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os6 &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; none centos:latest ip a s
  1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
      &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      inet 127.0.0.1/8 scope host lo
         valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;overlay&lt;/strong&gt;   &lt;a name=&quot;list1_5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;서로 다른 도커 호스트를 연결하여 통신&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도커 스웜과 같은 클러스터 서비스에 사용&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;macvlan&lt;/strong&gt;   &lt;a name=&quot;list1_6&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;MAC 주소를 컨테이너에 할당 → 물리적인 네트워크에서 같이 사용 가능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실제 네트워크에 직접 연결해야할 때 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;macvlan 네트워크 실습&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;IP 확인
            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ip a show enp0s8
     enp0s8: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
     &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 08:00:27:dd:11:95 brd ff:ff:ff:ff:ff:ff
     inet 192.168.56.100/24 brd 192.168.56.255 scope global noprefixroute enp0s8
         valid_lft forever preferred_lft forever
     inet6 fe80::d31:5047:a77b:837e/64 scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;noprefixroute 
         valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;NIC의 promisc모드를 활성화&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;enp0s8 promisc on

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ip a show enp0s8
 enp0s8: &amp;lt;BROADCAST,MULTICAST,&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;PROMISC&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
 &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 08:00:27:dd:11:95 brd ff:ff:ff:ff:ff:ff
 inet 192.168.56.100/24 brd 192.168.56.255 scope global noprefixroute enp0s8
     valid_lft forever preferred_lft forever
 inet6 fe80::d31:5047:a77b:837e/64 scope &lt;span class=&quot;nb&quot;&gt;link &lt;/span&gt;noprefixroute 
     valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;macvlan 네트워크 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network create &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; macvlan &lt;span class=&quot;nt&quot;&gt;--subnet&lt;/span&gt; 192.168.56.0/24 
 &lt;span class=&quot;nt&quot;&gt;--gateway&lt;/span&gt; 192.168.56.1 &lt;span class=&quot;nt&quot;&gt;--ip-range&lt;/span&gt; 192.168.56.128/25 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;enp0s8 macvlan1

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network &lt;span class=&quot;nb&quot;&gt;ls
 &lt;/span&gt;NETWORK ID          NAME                DRIVER              SCOPE
 b3b9ff62fe49        bridge              bridge              &lt;span class=&quot;nb&quot;&gt;local
 &lt;/span&gt;aeca1add77f7        host                host                &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;309515f14dde        macvlan1            macvlan             &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;macvlan 드라이버를 사용하는 컨테이너 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; macvlan1 &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; centos:latest

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@da574e50dae8 /]# ip a
 lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
     &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     inet 127.0.0.1/8 scope host lo
     valid_lft forever preferred_lft forever
 eth0@if3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default 
     &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 02:42:c0:a8:38:80 brd ff:ff:ff:ff:ff:ff link-netnsid 0
     inet 192.168.56.128/24 brd 192.168.56.255 scope global eth0
     valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컨테이너의-통신---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;컨테이너의 통신&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;링크&lt;/strong&gt;  &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨테이너 간 이름 또는 Alias으로 통신해야 하는 경우에 링크 기능 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;링크 실습&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;web3 컨테이너 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web3 httpd:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;link 사용 → ping 테스트&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-itd&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os7 &lt;span class=&quot;nt&quot;&gt;--link&lt;/span&gt; web3 centos:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker attach os7
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@c3efaa711015 /]# ping web3
 PING web3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;172.17.0.2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 56&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;84&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; bytes of data.
 64 bytes from web3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;172.17.0.2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;nv&quot;&gt;icmp_seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;64 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.089 ms
 64 bytes from web3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;172.17.0.2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: &lt;span class=&quot;nv&quot;&gt;icmp_seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2 &lt;span class=&quot;nv&quot;&gt;ttl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;64 &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.099 ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;/etc/hosts 파일 확인&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@c3efaa711015 /]# &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/hosts
 172.17.0.2	web3 029780c37d77
 172.17.0.3	c3efaa711015
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;컨테이너 이름 or 별칭 사용 가능&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;포트 포워딩&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;브릿지 네트워크를 사용하는 컨테이너는 외부에서 접근할 때 포트 포워딩해야 함&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;포트 포워딩 실습&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;호스트의 8080포트로 접근할때 컨테이너의 80번 포트로 전달하는 포트포워딩 설정&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web5 &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8080:80 httpd:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker ps&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps 
 CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                  NAMES
 f0929f220e86        httpd:latest        &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;   29 seconds ago      Up 28 seconds       0.0.0.0:8080-&amp;gt;80/tcp   web5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;접근 확인&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl localhost:8080
 &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;It works!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;현재 도커가 설치되어 있는 CentOS 7에서 curl 명령어를 통해 8080 포트로의 접근이 가능한지 확인합니다.&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; son@ubuntu:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl 192.168.56.100:8080
 &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;It works!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;현재 Virtualbox를 통해 CentOS를 구동시키고 있는 Ubuntu(Host OS)에서 curl 명령어를 통해 8080 포트로의 접근이 가능한지 확인합니다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/infra/2020/09/02/docker3.html</link>
        <guid isPermaLink="true">http://localhost:4000/infra/2020/09/02/docker3.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>network</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Docker] 도커 이미지와 컨테이너 및 볼륨 기초</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 도커 이미지(Docker Image)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. 도커 허브(Docker Hub)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 도커 이미지 관련 명령어 실습&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 도커 컨테이너(Docker Container)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 컨테이너 관련 명령어 실습&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 도커 볼륨(Docker Volume)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_1&quot;&gt;   3.1. 도커에서 데이터 관리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_2&quot;&gt;   3.2. Bind Mount 사용&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_3&quot;&gt;   3.3. 볼륨 사용 실습&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-도커-이미지---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 도커 이미지&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커 허브(Docker Hub)&lt;/strong&gt; &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;자신의 계정이 있다면 프로젝트를 Push/Pull 할 수 있는 Github와 같이 도커에서도 도커 허브라는 컨테이너 이미지 저장소를 제공하고 있습니다.&lt;/p&gt;

    &lt;p&gt;Github와 마찬가지로 도커 계정이 있다면 누구나 Push/Pull 할 수 있다는 점에서 비슷합니다.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub&lt;/a&gt; 사이트에서 회원가입하여 사용하실 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/docker_image.png&quot; alt=&quot;docker_image&quot; width=&quot;760&quot; height=&quot;330&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 깃허브와 도커 허브&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;도커에서 운영하고 있는 컨테이너 이미지 저장소&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도커 허브에 저장된 이미지의 이름은 &lt;strong&gt;저장소 이름:태그&lt;/strong&gt; 형태&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Inactive 이미지(6개월간 Push나 Pull이 한 번도 일어나지 않은 이미지)는 삭제 대상이 됨&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이 외의 자세한 정보는 아래의 도커의 FAQ 문서를 참고해주세요.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.docker.com/pricing/resource-consumption-updates&quot;&gt;Resource Consumption Updates FAQ&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.docker.com/legal/docker-terms-service&quot;&gt;Docker Terms of Service&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커 이미지 관련 명령어 실습&lt;/strong&gt;  &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;docker search&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker search centos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;도커 이미지를 검색하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker search&lt;/code&gt; 명령어를 사용합니다. 해당 명령어는 centos 공식 이미지가 있는지를 검색하게 됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker pull&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker pull httpd
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker pull centos:7
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker pull mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;이미지를 다운로드하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker pull 이미지명:태그명&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;

        &lt;p&gt;태그를 생략하면 가장 최신 버전(latest)를 자동으로 받게 되고, 태그를 지정하면 해당 태그의 이미지를 다운로드 하게 됩니다.&lt;/p&gt;

        &lt;p&gt;위의 명령어를 수행하면 최신버전의 httpd 이미지, 7 태그(버전)에 해당하는 centos 이미지와 5.7 태그에 해당하는 mysql 이미지를 다운로드 받을 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker image&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker image &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;이미지 목록을 보기 위한 명령어로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker images&lt;/code&gt;를 사용합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker rmi&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker rmi hello-world:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker rmi mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;이미지를 삭제하기 위해&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rmi&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;

        &lt;p&gt;기본적으로 컨테이너가 실행되고 있으면 삭제되지 않지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-f&lt;/code&gt; 옵션을 사용하여 이미지를 강제로 삭제시킬 수 있습니다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker rmi &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;docker images &lt;span class=&quot;nt&quot;&gt;-aq&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;나아가 모든 이미지를 한번에 삭제하고자 한다면 다음과 같이 docker images 명령의 -a, -q 옵션을 사용하여 이미지 ID를 구한 뒤 docker rmi 명령에 넘겨주는 방법이 있습니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker inspect&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect httpd:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;s2&quot;&gt;&quot;Id&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;8aadfb1607e5065070b96cbe5e3259312038cc0e51b2ba62e4ea9da802691574&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Created&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2020-08-18T07:16:27.598216826Z&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Path&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Args&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;State&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
             &lt;span class=&quot;s2&quot;&gt;&quot;Status&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;running&quot;&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;Running&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;Paused&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;Restarting&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;OOMKilled&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;Dead&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;Pid&quot;&lt;/span&gt;: 4925,
             &lt;span class=&quot;s2&quot;&gt;&quot;ExitCode&quot;&lt;/span&gt;: 0,
             &lt;span class=&quot;s2&quot;&gt;&quot;Error&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;StartedAt&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2020-08-18T07:20:00.233063636Z&quot;&lt;/span&gt;,
             &lt;span class=&quot;s2&quot;&gt;&quot;FinishedAt&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2020-08-18T07:19:49.732866179Z&quot;&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
     ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;도커 오브젝트의 정보를 자세하게 확인하고싶을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker inspect&lt;/code&gt; 명령을 사용합니다. 컨테이너 혹은 이미지의 low level 정보를 확인할 수 있고, 기본적인 출력 포맷은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;json&lt;/code&gt; 형태입니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker save / docker load&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker save &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; img.tar centos:7 httpd:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;tf img.tar
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; img.tar 
 &lt;span class=&quot;nt&quot;&gt;-rw-------&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 user user 393334272  8월 10 13:56 img.tar
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker rmi centos:7 httpd:latest

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker load &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; img.tar
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker images
 REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
 centos              7                   831691599b88        4 days ago          215MB
 httpd               latest              a6ea92c35c43        4 days ago          166MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;호스트에 저장된 이미지를 아카이브로 복사하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker save&lt;/code&gt; 명령어를 사용하고, 아카이브 파일을 미이지로 불러오기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker load&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;

        &lt;p&gt;2번에서 생성한 centos:7 이미지와 httpd:latest 이미지를 img.tar라는 이름으로 저장하고나서 두 이미지를 삭제한 후에 img.tar 파일으로 이미지를 불러오는 것을 확인할 수 있습니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-도커-컨테이너docker-container---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 도커 컨테이너(Docker Container)&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker version
Client: Docker Engine - Community
    Version:           19.03.12
    API version:       1.40
    Go version:        go1.13.10
    Git commit:        48a66213fe
    Built:             Mon Jun 22 15:46:54 2020
    OS/Arch:           linux/amd64
    Experimental:      &lt;span class=&quot;nb&quot;&gt;false

&lt;/span&gt;Server: Docker Engine - Community
    Version:           19.03.12
    API version:       1.40
    Go version:        go1.13.10
    Git commit:        48a66213fe
    Built:             Mon Jun 22 15:46:54 2020
    OS/Arch:           linux/amd64
    Experimental:      &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;도커 버전을 확인하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker version&lt;/code&gt; 명령어를 입력하면 도커의 버전 정보가 클라이언트와 서버로 나뉘어져 있습니다. 도커는 하나의 명령어로 실행되지만 실제로는 클라이언트와 서버 역할을 각각 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/docker_client_host.png&quot; alt=&quot;docker_client_host&quot; width=&quot;523&quot; height=&quot;228&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 도커 클라이언트와 호스트&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;도커 명령어를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터미널에 출력해줍니다. 기본값이 도커 서버의 소켓을 바라보고 있기 때문에 사용자는 의식하지 않고 마치 바로 명령을 내리는 것 같은 느낌을 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;컨테이너 관련 명령어 실습&lt;/strong&gt; &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너 생성 및 확인&lt;/strong&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;docker ps&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;컨테이너 목록을 확인하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;

            &lt;p&gt;현재 호스트에 존재하는 모든 컨테이너를 출력하고 싶다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-a&lt;/code&gt; 옵션을 추가하면 됩니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;web1 컨테이너 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web1 httpd:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;컨테이너를 생성하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker create&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;

            &lt;p&gt;생성할 컨테이너의 이름은 web1 이고 httpd:latest 이미지를 사용하여 컨테이너를 생성합니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;os1 컨테이너 생성&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker create &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os1 centos:latest 
 1457915352d8967c6a910d102481120b731329219d258144637302b321da2c3e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-i&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t&lt;/code&gt;를 동시에 사용한 것으로 터미널 입력을 위해 자주 사용되는 옵션입니다.&lt;/p&gt;

            &lt;p&gt;-i, –interactive=false: &lt;strong&gt;표준 입력(stdin)을 활성화&lt;/strong&gt;하며 컨테이너와 연결(attach)되어 있지 않더라도 표준 입력을 유지합니다. 보통 이 옵션을 사용하여 Bash에 명령을 입력합니다.&lt;/p&gt;

            &lt;p&gt;-t, –tty=false: &lt;strong&gt;TTY 모드(pseudo-TTY)를 사용&lt;/strong&gt;합니다. &lt;strong&gt;Bash를 사용하려면 이 옵션을 설정&lt;/strong&gt;해야 합니다. 이 옵션을 설정하지 않으면 명령을 입력할 수는 있지만 셸이 표시되지 않습니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;web1 컨테이너 시작&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker start web1
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect web1 | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;IPAddress
         &lt;span class=&quot;s2&quot;&gt;&quot;SecondaryIPAddresses&quot;&lt;/span&gt;: null,
         &lt;span class=&quot;s2&quot;&gt;&quot;IPAddress&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;172.17.0.2&quot;&lt;/span&gt;,
                 &lt;span class=&quot;s2&quot;&gt;&quot;IPAddress&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;172.17.0.2&quot;&lt;/span&gt;,

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl 172.17.0.2
 &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;It works!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker create&lt;/code&gt; 명령으로 생성한 컨테이너를 사용하려면 다음과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker start&lt;/code&gt; 명령으로 컨테이너를 시작해주어야 합니다.&lt;/p&gt;

            &lt;p&gt;web1 이름의 컨테이너를 시작하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker inspect&lt;/code&gt; 명령을 통해 web1 컨테이너의 ip 주소를 확인하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt; 명령을 통해 해당 ip 주소의 웹서버가 정상적으로 동작하는지 확인합니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;os1 컨테이너 시작&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker start &lt;span class=&quot;nt&quot;&gt;-ai&lt;/span&gt; os1
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@1457915352d8 /]#
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@1457915352d8 /]# &lt;span class=&quot;nb&quot;&gt;exit
 exit&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps
 CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES
 4a0638e6bea2        httpd:latest        &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;   10 minutes ago      Up 4 minutes        80/tcp              web1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;컨테이너를 시작할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-a&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-i&lt;/code&gt; 옵션을 추가하면 컨테이너를 시작시킨 후에 Bash 화면을 연결해줍니다. -a 옵션의 설명은 다음과 같습니다.&lt;/p&gt;

            &lt;p&gt;-a, –attach=[]: 컨테이너에 표준 입력(stdin), 표준 출력(stdout), 표준 에러(stderr)를 연결합니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker run 명령으로 web2 컨테이너 실행&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web2 httpd:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;이미지로 컨테이너를 생성할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 명령어를 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션의 설명은 다음과 같습니다.&lt;/p&gt;

            &lt;p&gt;-d, –detach=false: &lt;strong&gt;Detached 모드&lt;/strong&gt;입니다. 보통 데몬 모드라고 부르며 컨테이너가 백그라운드로 실행됩니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;os2 컨테이너 실행&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os2 centos:latest 
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@f20ddba876c2 /]#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;os3 컨테이너 실행하면서 hostname 명령 실행&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os3 centos:latest &lt;span class=&quot;nb&quot;&gt;hostname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;위 명령어는 os3 컨테이너의 hostname을 한 번 출력하고 프로세스가 종료됩니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;os4 컨테이너 실행 후 삭제&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os4 &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; centos:latest &lt;span class=&quot;nb&quot;&gt;hostname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;위 명령어는 os4 컨테이너의 hostname을 한 번 출력하고 프로세스가 종료된 후에 컨테이너가 삭제됩니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;컨테이너 삭제&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;os3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;컨테이너를 삭제하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rm&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;실행되는 컨테이너 외 전부 삭제&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker container prune
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES
f20ddba876c2        centos:latest       &lt;span class=&quot;s2&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt;          6 minutes ago       Up 6 minutes                            os2
60c84d29c6dc        httpd:latest        &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;   6 minutes ago       Up 6 minutes        80/tcp              web2
1457915352d8        centos:latest       &lt;span class=&quot;s2&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt;          44 minutes ago      Up 30 minutes                           os1
4a0638e6bea2        httpd:latest        &lt;span class=&quot;s2&quot;&gt;&quot;httpd-foreground&quot;&lt;/span&gt;   47 minutes ago      Up 41 minutes       80/tcp              web1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;실행되는 컨테이너 외의 모든 컨테이너를 삭제하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker container prune&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker stats&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker stats 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;컨테이너의 실시간 상태를 확인하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stats&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너 중지 및 제거&lt;/strong&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;os2 컨테이너 중지&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker stop os2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;os2 컨테이너 삭제&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;os2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;실행중인 컨테이너 삭제&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;os1 &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너 실행 시 유용한 설정&lt;/strong&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;환경변수&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os3 &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;LAB=docker&quot;&lt;/span&gt; centos:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@38b6ed0b4cdb /]# &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$LAB&lt;/span&gt;
 docker
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@38b6ed0b4cdb /]# &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;cpu 제한&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os3 &lt;span class=&quot;nt&quot;&gt;--cpus&lt;/span&gt; 0.3 centos:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@c2df3a13921e /]# &lt;span class=&quot;nb&quot;&gt;dd &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/zero &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--cpus 0.3&lt;/code&gt; 명령을 통해 컨테이너의 cpu 사용을 30%로 제한할 수 있습니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;메모리 제한&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-itd&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os5 &lt;span class=&quot;nt&quot;&gt;--memory&lt;/span&gt; 1024m centos:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--memory 1024m&lt;/code&gt; 명령을 통해 메모리 사용을 1GB로 제한할 수 있습니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;자원 제한 변경&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker update &lt;span class=&quot;nt&quot;&gt;--memory&lt;/span&gt; 2048m os5

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker update &lt;span class=&quot;nt&quot;&gt;--cpus&lt;/span&gt; 0.05 os5
 os5
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker attach os5
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@50c259122bc9 /]# &lt;span class=&quot;nb&quot;&gt;dd &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/zero &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker update&lt;/code&gt; 명령을 통해 cpu 혹은 메모리의 제한을 변경할 수 있습니다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너 접근 및 실행&lt;/strong&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;docker attach&lt;/p&gt;

            &lt;p&gt;표준 입력, 표준 출력/에러를 포함하는 컨테이너에 연결이 가능합니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker exec&lt;/p&gt;

            &lt;p&gt;실행중인 컨테이너에서 명령을 실행이 가능합니다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너 프로세스 및 로그 확인&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;컨테이너에서 실행 중인 프로세스와 로그를 확인할 수 있습니다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;docker top&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;컨테이너에서 실행되는 프로세스의 정보를 확인 가능&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;리눅스의 ps 옵션을 그대로 사용 가능함&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker logs&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; db1 mysql:5.7
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker logs db1
 2020-08-10 06:54:13+00:00 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ERROR] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Entrypoint]: Database is uninitialized and password option is not specified
     You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; db2 &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MYSQL_ROOT_PASSWORD=1234&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker logs&lt;/code&gt; 명령어를 통해 컨테이너의 로그를 확인할 수 있습니다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너에 파일 복사 및 확인&lt;/strong&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;docker cp&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /etc/passwd os5:/tmp
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;os5 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; /tmp/passwd
 &lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 root root 2304 Aug 10 02:15 /tmp/passwd
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;os5:/tmp/passwd /home/user/
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; passwd
 &lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 user user 2304  8월 10 11:15 passwd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker cp&lt;/code&gt; 명령어를 통해 호스트 파일을 컨테이너로 복사하거나 컨테이너의 파일을 호스트에 복사할 수 있습니다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker diff&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker diff os5
 C /tmp
 A /tmp/passwd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;컨테이너에서의 파일의 변경 상태를 체크하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker diff&lt;/code&gt; 명령어를 사용합니다.&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;docker diff 명령으로 출력되는 파일의 상태&lt;/p&gt;

                &lt;ul&gt;
                  &lt;li&gt;
                    &lt;p&gt;A : 파일이 추가됨&lt;/p&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;C : 파일이 변경됨&lt;/p&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;D : 파일이 삭제됨&lt;/p&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-도커-볼륨docker-volume---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;3. 도커 볼륨(Docker Volume)&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커에서 데이터 관리&lt;/strong&gt;  &lt;a name=&quot;list3_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;기본적으로 컨테이너에 생성되는 모든 파일은 컨테이너 레이어에 저장됨&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;컨테이너와 함께 삭제되는 런타임 데이터&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;이 데이터를 영구적으로 저장하려면 반드시 볼륨을 사용해야 함&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Bind Mount&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;초기 도커부터 사용했던 방식&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;호스트의 특정 디렉토리와 컨테이너의 디렉토리를 연결&lt;/strong&gt;하는 방식&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;따로 기록하지 않으면 관리하기 쉽지 않음&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;성능이 뛰어나지만 호스트의 파일 시스템에 대한 의존도가 높음&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;호스트의 민감한 파일까지 접근할 수 있음으로 보안 측면의 문제가 발생 가능함&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;볼륨&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;도커에 의해 관리되는 스토리지&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker 명령을 사용하여 생성 가능, 사용되지 않으면 한꺼번에 삭제 가능&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;이미지의 Volumes 부분에 어떤 값이 지정되어 있는 경우, 컨테이너로 실행할 때 볼륨을 지정해야 함&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;다양한 드라이버를 지원&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bind Mount 사용&lt;/strong&gt; &lt;a name=&quot;list3_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; ~/bm1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; ~/bm1/fileA.txt

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-dit&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os3 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; ~/bm1:/tmp/mount centos:latest

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;os3 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; /tmp/mount
  total 0
  &lt;span class=&quot;nt&quot;&gt;-rw-rw-r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 1000 1000 0 Aug 10 07:23 fileA.txt

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker ~]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/lib/docker/volumes/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker volumes]# &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;볼륨 사용 실습&lt;/strong&gt;    &lt;a name=&quot;list3_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;vol1 볼륨 생성&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker volume create vol1
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect vol1 
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;s2&quot;&gt;&quot;CreatedAt&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2020-08-18T16:28:04+09:00&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Driver&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;local&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Labels&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Mountpoint&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/docker/volumes/vol1/_data&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Name&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;vol1&quot;&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Options&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;,
         &lt;span class=&quot;s2&quot;&gt;&quot;Scope&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;local&quot;&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker ~]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/lib/docker/volumes/
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker volumes]# &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;vol1 볼륨을 os4의 /tmp/volume에 연결&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-itd&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; os4 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; vol1:/tmp/volume centos:latest

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;os4 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; /tmp/volume
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;os4 &lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; /tmp/volume/fileB.txt

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker ~]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/lib/docker/volumes/vol1/_data/
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker _data]# &lt;span class=&quot;nb&quot;&gt;ls
 &lt;/span&gt;fileB.txt

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@docker _data]# &lt;span class=&quot;nb&quot;&gt;exit
 logout&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker attach os4
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@f083223357e9 /]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tmp/volume/
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@f083223357e9 volume]# &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
 total 0
 &lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; 1 root root 0 Aug 10 07:31 fileB.txt
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@f083223357e9 volume]# &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; index.html
 Hello World!

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@f083223357e9 volume]# &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;escape sequence &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Ctrl + p + q&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web3 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; vol1:/usr/local/apache2/htdocs

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; web3 &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; vol1:/usr/local/apache2/htdocs:ro httpd:latest
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker inspect web3 | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ipaddress
             &lt;span class=&quot;s2&quot;&gt;&quot;SecondaryIPAddresses&quot;&lt;/span&gt;: null,
             &lt;span class=&quot;s2&quot;&gt;&quot;IPAddress&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;172.17.0.7&quot;&lt;/span&gt;,
                     &lt;span class=&quot;s2&quot;&gt;&quot;IPAddress&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;172.17.0.7&quot;&lt;/span&gt;,
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl 172.17.0.7
 Hello World! 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 01 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/infra/2020/09/01/docker2.html</link>
        <guid isPermaLink="true">http://localhost:4000/infra/2020/09/01/docker2.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>image</category>
        
        <category>container</category>
        
        <category>volume</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Docker] 도커 개요 및 설치 - CentOS 7</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 도커 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. 도커란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 가상머신과 컨테이너 비교&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. 도커의 특징&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_4&quot;&gt;   1.4. 도커의 구조 및 기능&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_5&quot;&gt;   1.5. 도커의 핵심 기술&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 도커 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 실습 환경&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 도커 설치 실습&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-도커-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 도커 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커란?&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Go 언어로 개발&lt;/strong&gt;된 컨테이너 기반의 오픈소스 가상화 플랫폼&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;다양한 OS 환경, 여러 프로그램들을 화물에 비유하여 컨테이너에 실어 여러 곳으로 운반하여 배포한다는 개념&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가상머신과 컨테이너 비교&lt;/strong&gt;    &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/vm_vs_container.png&quot; alt=&quot;vm_vs_container&quot; width=&quot;760&quot; height=&quot;330&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 컨테이너(왼쪽) vs 가상머신(오른쪽)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;가상머신(Virtual Machine)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host OS의 자원을 할당받아&lt;/code&gt; 하이퍼바이저를 이용해 Guest OS를 가상화 하여 사용하는 방식&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Host OS의 리소스 분할 또는 오버헤드와 OS 위에 또 OS를 설치하는 개념이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속도저하&lt;/code&gt;의 단점이 존재&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;컨테이너(Container)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host OS를 공유&lt;/code&gt;하며, 여러 개의 컨테이너들이 서로 영향을 미치지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적으로 실행&lt;/code&gt;되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가벼움&lt;/code&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;VM과의 가장 큰 차이점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스를 격리&lt;/code&gt; 하는 것&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;독립적으로 Host OS의 자원을 공유하며 각각 필요한 자원들을 할당받아 실행되기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오버헤드가 적음&lt;/code&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;즉, 가상 머신은 전체 하드웨어 서버를 추상화하는 반면 컨테이너는 운영 체제 커널을 추상화하여 &lt;strong&gt;훨씬 더 빠르고 가벼운 인스턴스를 제공&lt;/strong&gt;합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커의 특징&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;서버를 코드 형태로 정의&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;IaC(Infrastructure as Code)&lt;/strong&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;이미지를 제작할 때 코드 형태로 정의하여 작성 가능&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;이식성(portability)&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;개발 환경, 테스트 환경, 서비스 환경을 모두 동일하게 사용 가능&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;도커 컨테이너의 기반이 되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;도커 이미지&lt;/code&gt;가 있다면 애플리케이션을 동일한 환경에서 구동할 수 있다&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;상호운용성(interoperability)&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;다양한 벤더의 시스템 및 오픈소스와 연계하여 사용 가능&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;예를 들어, 상용 Linux 중 가장 많이 쓰이는 RHEL7에서도 도커를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기본으로 탑재&lt;/code&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;AWS에서도 Amazon EC2 Container Service를 통해 도커 실행 환경 운영 서비스를 제공&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커의 구조 및 기능&lt;/strong&gt;   &lt;a name=&quot;list1_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/docker_architecture.png&quot; alt=&quot;docker_architecture&quot; width=&quot;760&quot; height=&quot;390&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 도커 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;도커 데몬(Docker Deamon)&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;도커 API 요청을 지속적으로 수신 및 처리&lt;/strong&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;도커 이미지, 컨테이너, 네트워크 및 볼륨을 관리하는 지속적인 백그라운드 프로세스&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;도커 클라이언트(Docker Client)&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;도커 데몬과 상호 작용&lt;/strong&gt;하기 위한 CLI(Docker)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;컨테이너 인스턴스 관리 방법이 단순함&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;docker commit, docker export, docker import 등의 도커 관련 명령이 존재&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;도커 레지스트리(Docker Registry)&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;도커 이미지를 저장&lt;/code&gt;하기 위해 사용&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Docker Hub&lt;/code&gt;라는 퍼블릭 레지스트리로 설정되어 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Harbor&lt;/code&gt;와 같은 프라이빗 레지스트리도 사용 가능&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;도커 객체&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;이미지&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;컨테이너를 생성하기 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Read Only&lt;/code&gt; 템플릿&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;도커 이미지를 생성하고 실행하기 까지의 단계를 정의한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;을 통해 빌드 가능&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;새로운 컨테이너를 생성하면 변경된 레이어만 따로 체크하는 형태로 가볍고 빠름&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;컨테이너&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;이미지의 실행 형태, 이미지를 실행하여 메모리에 올려 동작하는 것&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 컨테이너&lt;/code&gt;에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 애플리케이션&lt;/code&gt;만 실행하는 것을 &lt;strong&gt;권장&lt;/strong&gt;&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;기본적으로 호스트 머신의 네트워크 연결을 통해 외부 네트워크와 연결 가능&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;네트워크&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;격리 되어 동작하는 모든 컨테이너가 통신하기 위한 통로로 사용되며 다음의 5 가지 네트워크 드라이버를 사용&lt;/p&gt;

                &lt;p&gt;1) Bridge&lt;/p&gt;

                &lt;p&gt;컨테이너의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기본 네트워크 드라이버&lt;/code&gt;입니다. 애플리케이션이 독립 실행형 컨테이너, 즉 동일한 도커 호스트와 통신하는 여러 컨테이너에서 실행될 때 이 네트워크를 사용합니다.&lt;/p&gt;

                &lt;p&gt;2) Host&lt;/p&gt;

                &lt;p&gt;이 드라이버는 도커 컨테이너와 도커 호스트 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;네트워크 격리를 제거&lt;/code&gt;합니다. 호스트와 컨테이너간에 네트워크 격리가 필요하지 않을 때 사용할 수 있습니다.&lt;/p&gt;

                &lt;p&gt;3) Overlay&lt;/p&gt;

                &lt;p&gt;이 네트워크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Swarm 서비스가 서로 통신&lt;/code&gt; 할 수 있도록합니다. 컨테이너가 다른 도커 호스트에서 실행되기를 원하거나 여러 애플리케이션에서 Swarm 서비스를 구성하려는 경우에 사용합니다.&lt;/p&gt;

                &lt;p&gt;4) None&lt;/p&gt;

                &lt;p&gt;이 드라이버는 &lt;strong&gt;모든 네트워킹을 비활성화&lt;/strong&gt;합니다.&lt;/p&gt;

                &lt;p&gt;5) macvlan&lt;/p&gt;

                &lt;p&gt;이 드라이버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨테이너에 MAC 주소를 할당&lt;/code&gt;하여 물리 장치처럼 보이게합니다. &lt;strong&gt;Mac 주소를 통해 컨테이너 간의 트래픽을 라우팅&lt;/strong&gt;합니다. 예를 들어, VM 설정을 마이그레이션하는 동안 컨테이너가 물리 장치처럼 보이게 하려는 경우에 이 네트워크를 사용합니다.&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;서비스&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;여러가지 도커 데몬들로 구성 및 확장 가능&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Docker Swarm&lt;/code&gt;과 같은 서비스를 통해 사용자에게는 단일 애플리케이션처럼 보임&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커의 핵심 기술&lt;/strong&gt;   &lt;a name=&quot;list1_5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;네임스페이스(Namespace)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;서로가 충돌하지 않는 독립된 컨테이너를 제공하기 위해&lt;/strong&gt; 네임스페이스라는 기술을 적용&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;리눅스에서는 다음 6 가지 네임스페이스를 지원&lt;/p&gt;

            &lt;p&gt;1) mnt (파일시스템 마운트): 호스트 파일시스템에 구애받지 않고 독립적으로 파일시스템을 마운트하거나 언마운트 가능&lt;/p&gt;

            &lt;p&gt;2) pid (프로세스): 독립적인 프로세스 공간을 할당&lt;/p&gt;

            &lt;p&gt;3) net (네트워크): namespace간에 network 충돌 방지 (중복 포트 바인딩 등)&lt;/p&gt;

            &lt;p&gt;4) ipc (SystemV IPC): 프로세스간의 독립적인 통신통로 할당&lt;/p&gt;

            &lt;p&gt;5) uts (hostname): 독립적인 hostname 할당&lt;/p&gt;

            &lt;p&gt;6) user (UID): 독립적인 사용자 할당&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;cgroups(Control Groups)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;리소스에 대한 제어를 가능&lt;/strong&gt;하게 해주는 리눅스 커널의 기능&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;도커 엔진(Docker Engine)이 사용 가능한 하드웨어 자원을 공유하도록 허용하거나 선택적으로 제한할 수 있음&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;다음 리소스를 제어할 수 있음&lt;/p&gt;

            &lt;p&gt;1) 메모리&lt;/p&gt;

            &lt;p&gt;2) CPU&lt;/p&gt;

            &lt;p&gt;3) I/O&lt;/p&gt;

            &lt;p&gt;4) 네트워크&lt;/p&gt;

            &lt;p&gt;5) device 노드(/dev/)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-도커-설치---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 도커 설치&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;실습 환경&lt;/strong&gt; &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;※ 본 포스트를 포함한 앞으로의 도커 관련 실습 환경은 다음과 같은 환경에서 진행됩니다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Host OS인 Ubuntu에서 Virtualbox를 통해 CentOS VM을 생성 및 접속하여 진행했습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Host OS - Ubuntu 18.04 LTS&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;IP : 192.168.56.1&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Username : son&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Hostname : ubuntu&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Guest OS - CentOS 7.8 (on Virtualbox)&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;IP : 192.168.56.100&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Username : user&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Hostname : docker&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;도커 설치 실습&lt;/strong&gt;    &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;docker-ce 설치&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; yum-utils &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; device-mapper-persistent-data &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; lvm2

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum-config-manager &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-repo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://download.docker.com/linux/centos/docker-ce.repo&quot;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-ce docker-ce-cli containerd.io

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;yum-config-manager를 통해 docker-ce 패키지 저장소를 추가하여 설치해줍니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;서비스 실행 및 활성화&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start docker
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;docker 서비스를 실행시키고, 부팅 시 docker 서비스가 자동으로 구동되도록 enable 시켜줍니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker 그룹 지정&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit

 &lt;/span&gt;son@ubuntu:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh user@192.168.56.100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;기본적으로 docker 명령어를 사용하기 위해서는 root 권한이 필요합니다.&lt;/p&gt;

        &lt;p&gt;$USER에는 현재 사용 중인 유저인 user가 들어가고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker 그룹에 user를 추가&lt;/code&gt;하여 &lt;strong&gt;권한 상승 없이도 docker 명령을 사용&lt;/strong&gt;할 수 있도록 해줍니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker 버전 확인&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker version
 Client: Docker Engine - Community
     Version:           19.03.12
     API version:       1.40
     Go version:        go1.13.10
     Git commit:        48a66213fe
     Built:             Mon Jun 22 15:46:54 2020
     OS/Arch:           linux/amd64
     Experimental:      &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hello world 컨테이너 실행&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;user@docker ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run hello-world
 Unable to find image &lt;span class=&quot;s1&quot;&gt;'hello-world:latest'&lt;/span&gt; locally
 latest: Pulling from library/hello-world
 0e03bdcc26d7: Pull &lt;span class=&quot;nb&quot;&gt;complete 
 &lt;/span&gt;Digest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5
 Status: Downloaded newer image &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;hello-world:latest

 Hello from Docker!
 This message shows that your installation appears to be working correctly.

 To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &lt;span class=&quot;s2&quot;&gt;&quot;hello-world&quot;&lt;/span&gt; image from the Docker Hub.
     &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;amd64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 3. The Docker daemon created a new container from that image which runs the
     executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
     to your terminal.

 To try something more ambitious, you can run an Ubuntu container with:
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; ubuntu bash

 Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

 For more examples and ideas, visit:
 https://docs.docker.com/get-started/

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/infra/2020/09/01/docker1.html</link>
        <guid isPermaLink="true">http://localhost:4000/infra/2020/09/01/docker1.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>vm</category>
        
        <category>overviwe</category>
        
        <category>install</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Project] Linux 취약점 진단 및 평가와 로깅</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 짧은 기간동안 진행된 세미 프로젝트입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.1. 프로젝트 목적&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 프로젝트 아키텍처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. 취약점 분석 평가 항목&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 프로젝트 구현&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 스크립트 디렉토리 구조&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 스크립트 실행&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. Kibana 대시보드 커스터마이징&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 결론&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-프로젝트-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 프로젝트 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 목적&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트는 KISA에서 작성된 &lt;a href=&quot;https://www.kisa.or.kr/public/laws/laws3_View.jsp?cPage=6&amp;amp;mode=view&amp;amp;p_No=259&amp;amp;b_No=259&amp;amp;d_No=106&amp;amp;ST=T&amp;amp;SV=&quot;&gt;주요정보통신기반시설 기술적 취약점 분석 평가 상세 가이드&lt;/a&gt; 문서를 참고하여 기술적인 취약 여부를 검사함으로써 악성코드 유포, 해킹 등 사이버 위협에 대응하기 위해 시작하게 된 프로젝트입니다.&lt;/p&gt;

    &lt;p&gt;가이드의 문서를 숙지하기 어려운 부분이 많기 때문에 보안 담당자들이 취약점 점검을 자동으로 손쉽게 취약점 진단을 진행할 수 있도록 운영체제 취약점 진단 자동화 스크립트를 개발하고 배포합니다.&lt;/p&gt;

    &lt;p&gt;취약점 점검을 손쉽게 진행할 수 있도록 자동화 스크립트를 개발하고 진단 결과를 한 눈에 확인할 수 있도록 가시화된 데이터를 제공하는 것을 목표로 합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 아키텍처&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음 [그림 1]은 진단 스크립트를 실행하는 것부터 Kibana에서 로그를 확인하는 일련의 과정을 테스트하기 위한 환경을 아키텍처로 나타낸 것입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_1.png&quot; alt=&quot;project_architecture&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 프로젝트 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;테스트는 Virtualbox에서 진행되었으며, ELK Stack이 설치되어 있는 VM과 진단할 여러 대의 VM을 구성하여 테스트까지 진행하였습니다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;명령어 하나로 [그림 1]의 과정이 모두 진행&lt;/strong&gt;되며, 스크립트를 실행하는 명령어의 &lt;strong&gt;매개변수에 입력되는 노드&lt;/strong&gt;들까지 모두 취약점 진단이 되어 Kibana에서 진단 결과를 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;취약점 분석 평가 항목&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;취약점 분석은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CentOS 7&lt;/code&gt; 환경에서 진행되며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;항목 중요도가 상&lt;/code&gt;인 진단 항목을 몇 가지 선택하여 진단 스크립트를 작성하였습니다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서 선택한 진단 항목은 다음 [그림 2]와 같습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_2.png&quot; alt=&quot;analysis_list&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 진단 항목 리스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-프로젝트-구현---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 프로젝트 구현&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스크립트 디렉토리 구조&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;son@elk linux_diagnosis]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tree &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  ├── lib
  │   ├── diagnosis_1
  │   ├── diagnosis_2
  │   └── &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;
  ├── log
  │   └── diagnosis_script.debug
  ├── main_diagnosis.sh
  └── U-13_filelist

  2 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서 취약점을 진단하기 위해 사용되는 스크립트의 디렉토리 구조를 나타낸다. 각 파일들에 대한 설명은 다음과 같습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;lib/diagnosis_1 : KISA 가이드 문서의 ‘계정 관리’ 진단 부분을 실행하는 파일&lt;/li&gt;
      &lt;li&gt;lib/diagnosis_2 : KISA 가이드 문서의 ‘파일 및 디렉토리 관리’ 진단 부분을 실행하는 파일&lt;/li&gt;
      &lt;li&gt;lib/function : 스크립트를 실행하면서 남겨지는 로그와 Elasticsearch로 데이터를 전송할 때 필요한 함수들을 정의한 파일&lt;/li&gt;
      &lt;li&gt;log/diagnosis_script.debug : main_diagnosis.sh 스크립트에서 실행되는 명령어와 실행 결과를 기록한 파일&lt;/li&gt;
      &lt;li&gt;main_diagnosis.sh : 취약점 진단을 위한 스크립트 실행 파일&lt;/li&gt;
      &lt;li&gt;U-13_filelist : U-13 항목에서 진단할 파일 리스트를 작성한 파일&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스크립트 실행&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;취약점 진단에는 시스템 파일을 확인하는 경우가 많기 때문에 root로 실행하거나 sudo를 앞에 삽입하여 실행하도록 구현했습니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 3]은 일반 유저로 스크립트를 실행했을 때의 결과입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_3.png&quot; alt=&quot;failed_execute&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] 일반 유저의 스크립트 실행 실패&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;스크립트가 재대로 실행되었을 때의 화면은 다음 [그림 4]와 같이 출력됩니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_4.png&quot; alt=&quot;succeed_execute&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] 정상적인 스크립트 실행 결과&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;root 권한과 함께 스크립트를 실행하면 정상적으로 취약점 진단이 실행되며, 항목 코드 별로 진단 결과가 출력됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color:green&quot;&gt;[Good]&lt;/span&gt;은 해당 항목에서 진단한 결과가 양호하다는 것입니다.&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;[Weak]&lt;/span&gt;는 진단 결과가 취약하게 나왔으므로 &lt;span style=&quot;color:blue&quot;&gt;[Info]&lt;/span&gt;를 통해 취약점을 보완해야 함을 의미합니다.&lt;/p&gt;

    &lt;p&gt;이러한 결과 로그는 스크립트 실행과 동시에 Elasticsearch에 전달되어 Kibana에서 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;위의 [그림 4]처럼 main_diagnosis.sh를 실행시킬 때 매개변수로 client.cccr.local의 호스트네임을 매개변수로 넣어서 실행시켰을 때 다음의 [그림 5]와 같이 elk.cccr.local 에서의 진단이 끝나면 곧바로 이어서 매개변수에 기입된 호스트에 대한 진단을 진행하게 됩니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_5.png&quot; alt=&quot;execute_with_ssh&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] ssh를 이용하여 매개변수에 기입된 호스트 진단&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;마찬가지로 client.cccr.local 호스트의 진단 결과도 Kibana에서 바로 확인할 수 있습니다. \&lt;/p&gt;

    &lt;p&gt;아래의 [그림 6]은 진단 스크립트를 실행시키면서 실행되는 명령어들이 재대로 수행되는지 xtrace를 통해 디버깅할 수 있도록 만든 것입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_6.png&quot; alt=&quot;debug_sample&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] diagnosis_script.debug 실행 샘플&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;진단하면서 실행되는 코드는 xtrace를 통해 디버깅해볼 수 있도록 log/diagnosis_script.debug 파일로 저장되어 진단이 끝난 후에 확인해볼 수 있습니다.&lt;/p&gt;

    &lt;p&gt;elk.cccr.local, client.cccr.local에서 실행되는 코드 모두 elk.cccr.local 호스트의 log/diagnosis_script.debug 파일을 통해 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;그리고 다음 [그림 7]은 다른 호스트까지 원격 진단할 수 있도록 개발한 코드입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_7.png&quot; alt=&quot;remote_execute_code&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] elk.cccr.local에서 다른 호스트로의 원격 진단 코드&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ sudo ./main_diagnosis.sh client&lt;/code&gt; 라고 명령어를 입력하면 호스트의 취약점 진단이 끝난 후에 /etc/hosts에 정의된 client 호스트네임을 가진 노드로 진단에 필요한 코드를 전송하여 ssh 접속을 통해 진단을 수행하도록 하였습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_8.png&quot; alt=&quot;output_log_code&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] 진단 로그 출력과 Elasticsearch로의 로그 전송 코드&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 8]은 진단 결과를 출력해주는 진단 로그를 출력해주는 함수와 Elasticsearch로 로그를 전송하는 함수를 정의한 것입니다.&lt;/p&gt;

    &lt;p&gt;콘솔에서 진단 결과를 출력해주는 함수는 print_good(), print_weak(), print_info() 로 정의되어 있고, 콘솔에 출력하는 동시에 Elasticsearch로 로그를 보내게 됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Kibana 대시보드 커스터마이징&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Elasticsearch와 Kibana의 설치가 정상적으로 끝나고나면 스크립트를 실행하여 진단 결과 데이터를 Elasticsearch로 전송시켜주면 Kibana에서 인덱스 패턴을 생성할 수 있게 됩니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_9.png&quot; alt=&quot;create_index_pattern&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] Kibana에서 인덱스 패턴 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Kibana에 접속하여 &lt;strong&gt;Management &amp;gt; Stack Management &amp;gt; Kibana &amp;gt; Index Patterns 탭&lt;/strong&gt;에 들어가서 &lt;strong&gt;Create index pattern 버튼&lt;/strong&gt;을 누르면 위의 [그림 9]과 같이 인덱스 패턴을 생성할 수 있는 화면이 나옵니다.&lt;/p&gt;

    &lt;p&gt;인덱스 패턴을 정의할 때 해당 패턴에 일치하는 인덱스가 Elasticsearch 내에 존재해야 합니다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 &lt;strong&gt;인덱스 이름을 diagnosis&lt;/strong&gt;라고 정의하였고, 진단 스크립트가 실행되면서 diagnosis 인덱스에 정형화된 컬럼 필드 내용들이 Elasticsearch로 전송되어 스크립트로 생성된 diagnosis라는 인덱스에 대한 인덱스 패턴을 생성할 수 있게 됩니다.&lt;/p&gt;

    &lt;p&gt;인덱스 패턴 이름을 적는 란에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diagnosis*&lt;/code&gt; 이라고 입력하여 인덱스 패턴을 생성해줍니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인덱스 패턴을 생성하고 나면 해당 인덱스 패턴에 대한 로그를 확인할 수 있게 되고, 로그는 &lt;strong&gt;Kibana &amp;gt; Discover 탭&lt;/strong&gt;에서 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;해당 탭에 들어가면 아래의 [그림 10]처럼 전송된 진단 로그를 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_10.png&quot; alt=&quot;kibana_discover_log&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] Kibana Discover 로그 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;스크립트에서 전송되는 로그에 대한 컬럼은 &lt;strong&gt;{“timestamp”, “ip_addr”, “hostname”, “os_version”, “vul_item”, “result_code”, “messages”}&lt;/strong&gt;의 형태로 되어 있습니다.&lt;/p&gt;

    &lt;p&gt;취약점 진단 스크립트를 실행을 통해 생성된 로그를 Discover 탭에서 가시화되어 확인할 수 있고, 왼쪽에 필드 내용을 검색해서 데이터를 필터링해서 확인할 수도 있습니다.&lt;/p&gt;

    &lt;p&gt;예를 들어, 취약점으로 나온 로그만 확인하고 싶다면 Add filter를 눌러 result_code: Weak를 입력하면 result_code 값이 Weak라고 되어있는 로그들을 쉽게 필터링하여 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로, Kibana에서 로그를 한눈에 확인할 수 있도록 다양한 모형을 통해 로그를 확인해봅니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 11]는 로그를 Visualization하여 확인한 것입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_11.png&quot; alt=&quot;kibana_visualize_custom&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] Kibana Visualize 탭 커스터마이징&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Kibana &amp;gt; Visualize 탭&lt;/strong&gt;에서 로그를 Visualization할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;로그들에 대한 Visualization할 수 있는 모형들이 다양하게 존재하는데, [그림 11]에서 보여지는 모형은 Pie를 사용했으며, 로그 필드는 hostname, result_code, vul_item을 순서로 &lt;strong&gt;드래그 앤 드랍&lt;/strong&gt;하여 커스터마이징 한 것입니다.&lt;/p&gt;

    &lt;p&gt;Pie 뿐만 아니라 Bar, Line, Area, Data table, Metric, Donut, Treemap 등 다양한 모형을 통해 로그를 Visualization 하여 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-결론---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;3. 결론&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;KISA의 ‘기술적 취약점 분석 평가 상세 가이드’ 문서를 참고하여 CentOS 환경에서 Bash 스크립트를 기반으로 취약점 진단을 자동으로 진행한 후에 로그를 Elasticsearch에 저장하고 Kibana를 통해 가시화된 데이터를 확인하는 작업과 테스트 방식 및 결과를 기술하였습니다.&lt;/p&gt;

&lt;p&gt;취약점 진단 자동화 스크립트를 실행하여 진단 로그를 생성하고, Elasticsearch에 저장한 후에 Kibana에서 각 노드 별로 진단 결과를 한 눈에 확인하는 [그림 1]의 일련의 과정들이 정상적으로 동작되는 것을 확인하였습니다.&lt;/p&gt;

&lt;p&gt;다만 개발 기간이 짧아 KISA의 문서에 기술된 방대한 진단 항목을 모두 개발하지 못하고 일부만 구현한 부분이 아쉽고 나머지 진단 항목에 대해서는 추가 개발이 필요합니다.&lt;/p&gt;

&lt;p&gt;그리고 진단 결과 취약하다고 나온 결과에 대해서는 자동으로 조치할 수 있는 스크립트를 개발하는 것도 향후 과제로 남기며 본 포스트를 마칩니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/08/30/linux_vulnerability_diagnosis_project.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/08/30/linux_vulnerability_diagnosis_project.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>linux</category>
        
        <category>bulnerability</category>
        
        <category>diagnosis</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] GCP를 활용한 웹사이트 구축과 모너터링 및 부하 테스트</title>
        <description>&lt;p&gt;본 프로젝트는 클라우드컴퓨팅연구조합(CCCR)에서 GCP(Google Cloud Platform)를 공부하며 짧은 기간 진행된 토이 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;구현 과정 및 설정까지 작성하여 글이 다소 길 수 있지만 하나의 프로젝트로 진행되어 포스팅을 따로 나누지 않았습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.1. 프로젝트 목적&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 프로젝트 아키텍처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 프로젝트 구현&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. Cloud SQL 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. VM 인스턴스 생성 및 워드프레스 구축&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. VM 인스턴스와 Cloud SQL 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_4&quot;&gt;   2.4. 관리형 로드 밸런싱 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_5&quot;&gt;   2.5. Bucket 생성 및 백업 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_6&quot;&gt;   2.6. Stack Driver를 활용한 모니터링 및 로깅 시스템 구축&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 프로젝트 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_1&quot;&gt;   3.1. Cloud SQL 로깅 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_2&quot;&gt;   3.2. 오토 스케일링 및 부하 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-프로젝트-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 프로젝트 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 목적&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트는 GCP의 전반적인 환경을 이해하고 흔하게 사용할 수 있는 기능들을 사용하여 GCP 환경에서 워드프레스(Wordpress)를 구축합니다.&lt;/p&gt;

    &lt;p&gt;구축된 워드프레스 서버를 Google Cloud Console을 사용해 서비스와 상호작용하는 방법 등 GCP의 기본적인 기능들을 사용해보는 것을 목표로 진행된 프로젝트입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;프로젝트 진행 당시에 notion을 통해 정리했었던 프로젝트 진행 순서는 다음 [그림 1]과 같습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_1.png&quot; alt=&quot;What_we_did&quot; width=&quot;560&quot; height=&quot;310&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 프로젝트 진행 순서&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 아키텍처&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹서비스는 CentOS 인스턴스를 생성하여 워드프레스를 구축하였고, 구축한 웹서비스에 GCP의 기능을 최대한 활용하는 형태로 프로젝트를 진행했습니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 2]는 본 프로젝트의 구조를 쉽게 나타낼 수 있도록 아키텍처를 그린 것입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_2.png&quot; alt=&quot;project_architecture&quot; width=&quot;850&quot; height=&quot;470&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 프로젝트 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위와 같이 Compute Engine을 통한 인스턴스 생성, 로드 밸런싱, Cloud SQL 및 Bucket 연동, Stack Driver를 통한 로깅과 모니터링하는 부분까지 진행하였습니다.&lt;/p&gt;

    &lt;p&gt;Cloud DNS를 이용하여 도메인을 설정해보고 싶었지만, 도메인을 구입하고 등록하는 과정이 필요하여 생략하였습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-프로젝트-구현---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 프로젝트 구현&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cloud SQL 구성&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;GCP 콘솔 페이지에 접속하면 상단 바에 제품 및 리소스를 검색할 수 있는 텍스트 박스가 있습니다.&lt;/p&gt;

    &lt;p&gt;해당 검색창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cloud SQL Admin API&lt;/code&gt;를 입력하여 다음 [그림 3]에 보이는 &lt;strong&gt;사용&lt;/strong&gt; 버튼을 눌러 &lt;strong&gt;Cloud SQL를 활성화&lt;/strong&gt; 시켜줍니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_3.png&quot; alt=&quot;enable_cloudsql&quot; width=&quot;320&quot; height=&quot;132&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Cloud SQL Admin API 활성화&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Cloud SQL Admin API를 활성화 했다면 GCP 콘솔 페이지의 왼쪽 상단에 있는 탐색 메뉴에서 &lt;strong&gt;[SQL] 탭&lt;/strong&gt;을 눌러 다음 [그림 4]와 같이 &lt;strong&gt;Cloud SQL 인스턴스를 생성&lt;/strong&gt;했습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_4.png&quot; alt=&quot;create_cloudsql_instance&quot; width=&quot;450&quot; height=&quot;552&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Cloud SQL 인스턴스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 MySQL 5.7을 선택하여 데이터베이스를 생성하였고, 리전은 성능 향상을 위해 비교적 가까운 &lt;strong&gt;서울 리전&lt;/strong&gt;을 선택하였습니다.&lt;/p&gt;

    &lt;p&gt;다음으로 GCP 콘솔 기능인 Cloud Shell 화면에서 웹서버에서 사용할 데이터베이스의 설정을 진행합니다.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;  crisis51526@cloudshell:~ (cccr-gcp-project)$ gcloud sql connect mysql-wordpress --user=root --quiet
  Allowlisting your IP for incoming connection for 5 minutes...done.
  Connecting to database with SQL user [root].Enter password: Input Your Password

  Your MySQL connection id is 187
  Server version: 5.7.25-google-log (Google)

  Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.

  Oracle is a registered trademark of Oracle Corporation and/or its
  affiliates. Other names may be trademarks of their respective
  owners.

  Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.

  mysql&amp;gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'Input Your Password' WITH GRANT OPTION;
  Query OK, 0 rows affected, 1 warning (0.05 sec)

  mysql&amp;gt; CREATE DATABASE wordpress CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
  Query OK, 1 row affected (0.05 sec)

  mysql&amp;gt; GRANT ALL ON wordpress.* TO 'wordpressuser'@'%' IDENTIFIED BY 'Input Your Password';
  Query OK, 0 rows affected, 1 warning (0.06 sec)

  mysql&amp;gt; FLUSH PRIVILEGES;
  Query OK, 0 rows affected (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VM 인스턴스 생성 및 워드프레스 구축&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹서버에 연동할 Cloud SQL의 구성이 모두 끝난 후에 워드프레스를 설치할 VM 인스턴스를 생성합니다.&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[Compute Engine] - [VM 인스턴스]&lt;/strong&gt; 탭을 눌러 &lt;strong&gt;만들기&lt;/strong&gt; 버튼을 클릭하여 다음 [그림 5]와 같이 인스턴스를 생성합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_5.png&quot; alt=&quot;create_instance&quot; width=&quot;450&quot; height=&quot;1040&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] VM 인스턴스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;먼저, 인스턴스를 생성할 때 앞서 생성한 Cloud SQL 인스턴스와 같은 리전(서울 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asia-northeast3-a&lt;/code&gt;)을 선택하도록 합니다.&lt;/p&gt;

    &lt;p&gt;flavor는 실제 서비스를 운영할 목적이 아니기에 VM 사양이 낮은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n1-standard-1&lt;/code&gt;을 선택하였고,&lt;/p&gt;

    &lt;p&gt;OS는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CentOS 7&lt;/code&gt;, 웹서버의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP 트래픽을 허용&lt;/code&gt;해주도록 체크하였습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;생성한 인스턴스에 워드프레스를 설치하기 위해 터미널에 입력한 명령어는 다음과 같습니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;crisis51526@instance-wordpress ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;su -

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;https://rpms.remirepo.net/enterprise/remi-release-7.rpm 
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;epel-release yum-utils

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# setenforce 0

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum-config-manager &lt;span class=&quot;nt&quot;&gt;--disable&lt;/span&gt; remi-php54
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum-config-manager &lt;span class=&quot;nt&quot;&gt;--enable&lt;/span&gt; remi-php74
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;php php-fpm
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;php-cli php-redis php-brotli php-intl php-gd php-gmp php-imap php-bcmath &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      php-interbase php-json php-mbstring php-mysqlnd php-odbc php-opcache php-memcached php-tidy php-pdo php-pdo-dblib &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      php-pear php-pgsql php-process php-pecl-apcu php-pecl-geoip php-pecl-imagick php-pecl-hrtime php-pecl-json &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      php-pecl-memcache php-pecl-rar php-pecl-pq php-pecl-redis4 php-pecl-yaml php-pecl-zip
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;httpd
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl restart httpd
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;php-fpm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start php-fpm
    
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;redis memcached
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;redis &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;memcached 
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl start redis &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start memcached
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim /etc/sysconfig/memcached
  &lt;span class=&quot;nv&quot;&gt;OPTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-l 127.0.0.1&quot;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl restart memcached
    
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# wget http://wordpress.org/latest.tar.gz
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-xvzf&lt;/span&gt; latest.tar.gz &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; /var/www/html
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-R&lt;/span&gt; apache: /var/www/html/wordpress
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim /etc/httpd/conf.d/wordpress.conf
  &amp;lt;VirtualHost &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;:80&amp;gt;
      DocumentRoot /var/www/html/wordpress
      ServerName lls.wordpress.com
      ServerAlias www.lls.wordpress.com
    
      &amp;lt;Directory /var/www/html/wordpress/&amp;gt;
          Options +FollowSymlinks
          AllowOverride All
      &amp;lt;/Directory&amp;gt;
    
      ErrorLog /var/log/httpd/tecminttest-error-log
      CustomLog /var/log/httpd/tecminttest-acces-log common
  &amp;lt;/VirtualHost&amp;gt;
    
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl restart httpd.service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/www/html/wordpress/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;wp-config-sample.php wp-config.php 
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# vim wp-config.php
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'DB_NAME'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'wordpress'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'DB_USER'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'wordpressuser'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'DB_PASSWORD'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'Input Your Password.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'DB_HOST'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'localhost'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VM 인스턴스와 Cloud SQL 연동&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;워드프레스를 설치한 인스턴스에서 Cloud SQL Proxy를 통해 Cloud SQL에 연결하기 위해서는 권한이 필요하다.&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[IAM 및 관리자] - [IAM]&lt;/strong&gt; 탭을 눌러 다음 [그림 6]와 같이 새로운 구성원을 추가합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_6.png&quot; alt=&quot;iam_create&quot; width=&quot;800&quot; height=&quot;627&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] 서비스 계정 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;역할에서 &lt;strong&gt;Cloud SQL -&amp;gt; Cloud SQL 편집자&lt;/strong&gt;를 선택하고 서비스 키도 생성해줍니다.&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;service_account&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;project_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cccr-gcp-project&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;private_key_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;3ef41c7827f3524bc358d489313f6084c229cf2f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;private_key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-----BEGIN PRIVATE KEY-----&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCVnSNgrX4B+Vi1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nYoTpCMXSl/p/tSjfhGaIUprWzCSfl3mVVQJlnN9mDQ8GTvg4l5UpGxvuaftV3MDN&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;npwBkZ/tCKE7h/DTRx1cay28paXGV/vKZt8OwwWCCmm5Uk5ZvIvmel/oGho9TC886&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nJ1DvWSqjZL+aRwFxWJqGwpF4zxXOFjStcqhCdnT9UipCfOgqx2xBoN4N0mhkUEby&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nfqLqo7AqEYh/5/zXWR9PTm7bESbqtz2i+VUOGwDDt5U0PVatGpFahNL8qUj4lJlO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nOzltgNICedHdUMa9B+GuSi5NOKHkuR5lOJZGcqziZFQLw3UpUyGMPVdsupcn6ZQm&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nLwdl/lpfAgMBAAECgf8TSS5GSBb2Ki5FM23unDLj8rNXwwKBzY9qAzvydF5ENEJ3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n/X1Rm+cwQH6vUX6tzNxtcBEpqn+7kblIyT5DsyOwY4HHn7svT4Lq8U5jCDScIUEk&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nj4uqPUMzkrSmMmAx81A6IV0Zej7/dYZA+NB2Cgh1B4erW3vUIJfKx0n5SLiG2CN9&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nSRC2L3YlwKPrmGiKXSvt6p2qezDjwycooph5s8EWjZ4Wyy5lP2bjaIGqs+QzIN3s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nYAMf3KTNF8EHNs4jJYmFiwIuz8q4zscnt3z7TF5vsgcBSgKqnE5rSa2UiyXx/8um&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nw7gU5taZh32o0Xk8AYTrVW7vYx9PkAz7g77yVFkCgYEAxQSTYZmkPxXKYs9aGeyi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nYCRnBNgNr1WjvQ5DQGBAUQS4OiZEb6JoWDqlOvcMqvF1Vu2CPv5MTgEWrs2+mAmj&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n8xWvySm97oJ2FfnYX2rl/SmGmxbWq2CKzsU56jJNDUGBiC4/3Ot8hsy/cnzEec54&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nhU1yW+mEwq0Ew50Ab5IldcsCgYEAwmeFo8XoI86Y8MakIoW6rL9zredwf+B9qYjI&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n7VHGcEnAcCfnRevLj7kK/QFswox/cfGmIbOxd1BPBH4D6nVKmRWqIzkpnCPkVRJ8&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n5BuImNhzfurPUgJWf0lNkrRaSwbsBYf12ZQ01J5t4Bg8ArQ5nNNT4ieC9dptpYTL&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n2hFSuz0CgYAMkzEw/pR8LlDfo6p1kyP+DPTCW2PsOAQecgWa20nfofR8Sar+kRgl&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n4YBgVhpp4sWBieFRUfve0rT27Uzn+V2Mi2rP5SkpSwxsdKj51iHd2cOsrHWBNMVH&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nU1FSAGnombDB12neGO220OS7UvlbaPFKWNoewbXmkxKFxcScWnCnpwKBgQCIiwub&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nhzLQi5hybSL1uHXwRZxrhgZHWxcID7IItgop7jNC01QmkUJt1St5nxmT3/jXwEHO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;npBa+1eJaJmR7thxKP6Q7jzfBmpgShKTB1vDvYgBlIWmykT/NsV/R7ekJj3gRPniY&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ndPdSa2CDKKJlx847b1cYnmXmZp/ixM4lgUtZhQKBgQC7GBZxRh4dx6JWqQ8J2Vaq&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n1sE83o0/K0i4i2MqEw70CG4nFs5831fnV6DSVWpyvxlN9M8Ce19ZcpVLP4UD0pE6&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ndTKGhvdIkQeat9yWBr4J/+d9jz3uleXGZCmVYrR/f2Ge8Vb/DWEUf2Ps9s0QZkoO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;nN6xZ+UJBHIwBp+i3pLqXOw==&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n-----END PRIVATE KEY-----&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;n&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;client_email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wpmanager@cccr-gcp-project.iam.gserviceaccount.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;client_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;116608554003641610764&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;auth_uri&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;https://accounts.google.com/o/oauth2/auth&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;token_uri&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;https://oauth2.googleapis.com/token&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;auth_provider_x509_cert_url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;https://www.googleapis.com/oauth2/v1/certs&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;client_x509_cert_url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;https://www.googleapis.com/robot/v1/metadata/x509/wpmanager%40cccr-gcp-project.iam.gserviceaccount.com&amp;gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;생성된 서비스 키의 샘플입니다. Cloud SQL Proxy를 통해 Cloud SQL에 접속할 때 필요합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그리고 다음 [그림 7]과 같이 Cloud SQL 인스턴스에서 접근을 허용할 네트워크를 추가해주어야 합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_7.png&quot; alt=&quot;cloudsql_configuration&quot; width=&quot;650&quot; height=&quot;442&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] Cloud SQL 인스턴스 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;연결 방식을 &lt;strong&gt;공개 IP&lt;/strong&gt;에 체크하여 프록시를 통해 Cloud SQL에 접근할 수 있도록 설정하고,&lt;/p&gt;

    &lt;p&gt;아래쪽의 네트워크 추가 버튼을 눌러 워드프레스 &lt;strong&gt;웹서버의 공개 IP 주소를 등록&lt;/strong&gt;합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 워드프레스 웹서버에서 Cloud SQL에 접속하는 과정을 정리한 명령어입니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mysql
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; 34.64.148.237
  Enter password: 
  Welcome to the MariaDB monitor.  Commands end with &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; or &lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;g.
  Your MySQL connection &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;is 343
  Server version: 5.7.25-google-log &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Google&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2000, 2018, Oracle, MariaDB Corporation Ab and others.

  Type &lt;span class=&quot;s1&quot;&gt;'help;'&lt;/span&gt; or &lt;span class=&quot;s1&quot;&gt;'\\h'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;help. Type &lt;span class=&quot;s1&quot;&gt;'\\c'&lt;/span&gt; to clear the current input statement.

  MySQL &lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;none&lt;span class=&quot;o&quot;&gt;)]&amp;gt;&lt;/span&gt; show databases&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  +--------------------+
  | Database           |
  +--------------------+
  | information_schema |
  | mysql              |
  | performance_schema |
  | sys                |
  | wordpress          |
  +--------------------+
  5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.01 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  MySQL &lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;none&lt;span class=&quot;o&quot;&gt;)]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit
  &lt;/span&gt;Bye

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /cloudsql
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;777 /cloudsql
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; cloud_sql_proxy
  &lt;span class=&quot;nt&quot;&gt;--2020-08-02&lt;/span&gt; 10:39:20--  https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64
  Resolving dl.google.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dl.google.com&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;... 172.217.161.238, 2404:6800:400a:80c::200e
  Connecting to dl.google.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dl.google.com&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;|172.217.161.238|:443... connected.
  HTTP request sent, awaiting response... 200 OK
  Length: 14492253 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;14M&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;application/octet-stream]
  Saving to: ‘cloud_sql_proxy’

  100%[&lt;span class=&quot;o&quot;&gt;=========================================================================&amp;gt;]&lt;/span&gt; 14,492,253  22.0MB/s   &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.6s   

  2020-08-02 10:39:21 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;22.0 MB/s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; - ‘cloud_sql_proxy’ saved &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;14492253/14492253]

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x cloud_sql_proxy
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim wordpress-key.json
  &lt;span class=&quot;c&quot;&gt;# wpmanager 서비스 계정에서 키를 만들 때 생성된 json 내용 입력&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# ./cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;nt&quot;&gt;-credential_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/root/wordpress-key.json &amp;amp;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 15932
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# 2020/08/02 15:23:07 Rlimits &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;file descriptors &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;to &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;8500 8500&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
  2020/08/02 15:23:07 using credential file &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;authentication&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wpmanager@cccr-gcp-project.iam.gserviceaccount.com
  2020/08/02 15:23:07 Listening on /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress
  2020/08/02 15:23:07 Ready &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;new connections&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress 
  Enter password: 
  2020/08/02 10:52:05 New connection &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;cccr-gcp-project:asia-northeast3:mysql-wordpress&quot;&lt;/span&gt;
  Welcome to the MariaDB monitor.  Commands end with &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; or &lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;g.
  Your MySQL connection &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;is 429
  Server version: 5.7.25-google-log &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Google&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2000, 2018, Oracle, MariaDB Corporation Ab and others.

  Type &lt;span class=&quot;s1&quot;&gt;'help;'&lt;/span&gt; or &lt;span class=&quot;s1&quot;&gt;'\\h'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;help. Type &lt;span class=&quot;s1&quot;&gt;'\\c'&lt;/span&gt; to clear the current input statement.

  MySQL &lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;none&lt;span class=&quot;o&quot;&gt;)]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit
  &lt;/span&gt;Bye
  2020/08/02 10:52:24 Client closed &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;connection on /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# ps
  PID TTY          TIME CMD
  1467 pts/0    00:00:00 &lt;span class=&quot;nb&quot;&gt;sudo
  &lt;/span&gt;1469 pts/0    00:00:00 su
  1470 pts/0    00:00:00 bash
  16476 pts/0    00:00:00 cloud_sql_proxy
  16517 pts/0    00:00:00 ps
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-9&lt;/span&gt; 16476
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]+  Killed                  ./cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;nt&quot;&gt;-credential_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wordpress-key.json
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /opt/cloudsqlproxy/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;cloud_sql_proxy /opt/cloudsqlproxy/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim ~/cloudsqlproxy.service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Unit]
  &lt;span class=&quot;nv&quot;&gt;Description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Google Cloud SQL Proxy
  &lt;span class=&quot;nv&quot;&gt;After&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;syslog.target network.target auditd.service

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Service]
  &lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/opt/cloudsqlproxy/cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;nt&quot;&gt;-credential_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/root/wordpress-key.json
  &lt;span class=&quot;nv&quot;&gt;ExecStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/bin/kill &lt;span class=&quot;nt&quot;&gt;-TERM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$MAINPID&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Install]
  &lt;span class=&quot;nv&quot;&gt;WantedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;multi-user.target

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; ~/cloudsqlproxy.service /etc/systemd/system/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl daemon-reload
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl start cloudsqlproxy
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;cloudsqlproxy
  Created symlink from /etc/systemd/system/multi-user.target.wants/cloudsqlproxy.service to /etc/systemd/system/cloudsqlproxy.service.
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl status cloudsqlproxy
  ● cloudsqlproxy.service - Google Cloud SQL Proxy
      Loaded: loaded &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/etc/systemd/system/cloudsqlproxy.service&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; disabled&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; vendor preset: disabled&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      Active: active &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;running&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; since Sun 2020-08-02 10:55:53 UTC&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 13s ago
  Main PID: 16524 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cloud_sql_proxy&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      CGroup: /system.slice/cloudsqlproxy.service
              └─16524 /opt/cloudsqlproxy/cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3...

  Aug 02 10:55:53 instance-wordpress systemd[1]: Started Google Cloud SQL Proxy.
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 Rlimits &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;file descriptors s...0&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 using credential file &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;auth...com
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 Listening on /cloudsql/cccr-gc...ess
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 Ready &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;new connections
  Hint: Some lines were ellipsized, use &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; to show &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;full.

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# vim /var/www/html/wordpress/wp-config.php
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'DB_HOST'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'localhost:/cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Cloud SQL Proxy가 정상적으로 동작하는지 테스트 한 후에 데몬을 생성하여 cloudsqlproxy 서비스가 실행되도록 했습니다.&lt;/p&gt;

    &lt;p&gt;wordpress-key.json 파일의 내용에는 위에서 wpmanager 서비스 계정의 키를 만들 때 생성된 json 내용을 입력하면 됩니다.&lt;/p&gt;

    &lt;p&gt;워드프레스의 설정파일에서 데이터베이스 설정 값에 cloudsqlproxy 서비스로 생겨난 소켓 파일의 경로를 적어주고 정상적으로 연결되는지 확인합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Cloud SQL에 정상적으로 연결되었다면 워드프레스를 설치하고 워드프레스 데이터베이스와 테이블이 정상적으로 생성되었는지 확인하도록 합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_8.png&quot; alt=&quot;wordpress_installation&quot; width=&quot;750&quot; height=&quot;554&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] 워드프레스 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_9.png&quot; alt=&quot;wordpress_theme&quot; width=&quot;1000&quot; height=&quot;541&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] 워드프레스 테마 적용&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;워드프레스 설치 및 테마 적용이 정상적으로 이루어진 후에 Cloud SQL에서 워드프레스 데이터베이스의 테이블이 정상적으로 생성되었는지 확인합니다.&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordpress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# mysql -u root -p -S /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Enter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;Welcome&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MariaDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Commands&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; \\&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Your&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1478&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Copyright&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2018&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Oracle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MariaDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Corporation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ab&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;others&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'help;'&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;h'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;c'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordpress&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Reading&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;You&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startup&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordpress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;+-----------------------+&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tables_in_wordpress&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;+-----------------------+&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_commentmeta&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_comments&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_links&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_options&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_postmeta&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_posts&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_term_relationships&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_term_taxonomy&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_termmeta&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_terms&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_usermeta&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_users&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;+-----------------------+&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.00&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;관리형 로드 밸런싱 구성&lt;/strong&gt;   &lt;a name=&quot;list2_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;GCLB(Google Cloud Load Balancing)을 구성하기 위해서는 기본적으로 대상으로 할 인스턴스 그룹이 존재해야 합니다. 인스턴스 그룹은 &lt;strong&gt;오토 스케일링(Auto-scaling)을 위한&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리형 인스턴스 그룹&lt;/code&gt;과 &lt;strong&gt;템플릿을 사용하지 않고 직접 VM 인스턴스를 추가할 수 있는&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비관리형 인스턴스 그룹&lt;/code&gt;으로 나뉩니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 관리형 인스턴스 그룹을 구성하고 부하 분산기를 생성하여 로스 밸런싱 환경을 구축합니다.&lt;/p&gt;

    &lt;p&gt;먼저 VM 인스턴스에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스냅샷을 생성&lt;/code&gt;하고, 생성한 스냅샷으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이미지를 생성&lt;/code&gt;합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_10.png&quot; alt=&quot;create_snapshot&quot; width=&quot;400&quot; height=&quot;566&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] 스냅샷 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_11.png&quot; alt=&quot;create_image&quot; width=&quot;400&quot; height=&quot;689&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] 이미지 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이미지까지 정상적으로 생성되었다면 다음으로 관리형 인스턴스 그룹을 만들기 전에 다음 [그림 12]과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인스턴스 템플릿을 생성&lt;/code&gt;합니다.&lt;/p&gt;

    &lt;p&gt;그룹에 속한 VM의 종류가 여러 개라면 모든 VM의 운영체제의 이미지를 지정해야 합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_12.png&quot; alt=&quot;create_instance_template&quot; width=&quot;400&quot; height=&quot;881&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] 인스턴스 템플릿 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인스턴스 템플릿을 정상적으로 생성한 후에 다음 [그림 13]과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리형 인스턴스 그룹을 생성&lt;/code&gt;합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_13.png&quot; alt=&quot;create_instance_group&quot; width=&quot;700&quot; height=&quot;1114&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] 인스턴스 그룹 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인스턴스 그룹까지 정상적으로 생성되었다면 부하 분산기를 생성할 준비가 끝났습니다.&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[네트워크 서비스] - [부하 분산]&lt;/strong&gt; 탭에 들어와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부하 분산기 만들기&lt;/code&gt;를 눌러줍니다.&lt;/p&gt;

    &lt;p&gt;HTTP(S), TCP, UDP에 대한 부하 분산기를 만들 수 있으며 본 프로젝트에서는 워드프레스를 통한 웹서버 인스턴스를 부하 분산 시켜주기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP(S) 부하 분산기&lt;/code&gt;를 선택하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터넷 트래픽을 VM으로 분산&lt;/code&gt;을 눌러줍니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음 단계로 넘어오면 백엔드 서비스와 프런트엔드 서비스를 생성하는 화면으로 넘어오게 됩니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_14.png&quot; alt=&quot;create_lb_backend&quot; width=&quot;400&quot; height=&quot;589&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 14] 백엔드 서비스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;기존에 만들어둔 백엔드 서비스가 없기 때문에 새로운 서비스 생성을 선택하고 백앤드 서비스의 이름과 앞에서 생성한 인스턴스 그룹을 선택하면 됩니다. 다음으로는 로드밸런서에서 들어온 트래픽을 인스턴스 그룹의 인스턴스들의 어느 포트로 전달할 것인지를 포트 번호에 정의하는데, 여기서는 HTTP 트래픽을 전달하는 것이기 때문에 80을 선택합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;백엔드 서비스를 생성할 때 상태 확인(Health check)을 선택하는 항목이 있는데 마찬가지로 기존에 만들어둔 상태 확인이 없기 때문에 새로 생성합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_15.png&quot; alt=&quot;create_lb_check&quot; width=&quot;400&quot; height=&quot;465&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 15] 상태 확인 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;상태 확인은 인스턴스 그룹 내의 인스턴스가 양호한지를 체크하고 만약에 정상적이지 않으면 비정상 노드는 부하 분산에서 빼버리는 기능을 수행합니다. 프로토콜은 HTTP를 입력하고, 포트에는 HTTP 포트인 80포트, 그리고 서비스가 정상인지를 확인하는 확인 간격은 체크 주기이고, 제한 시간은 이 시간(초)내에 응답이 없으면 장애라고 판단을 합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_16.png&quot; alt=&quot;create_lb_frontend&quot; width=&quot;400&quot; height=&quot;493&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 16] 프런트엔드 서비스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;마지막으로 프런트엔드 서비스를 설정하는데, 여기서는 어떤 프로토콜을 어떤 IP와 포트로 받을 것인지, HTTPS의 경우에는 SSL 인증서를 설정하는 작업을 합니다. 본 프로젝트에서는 HTTP 프로토콜을 80 포트로 설정하기 때문에 [그림 16]과 같이 설정하고, 부하 분산 이름을 입력하여 생성을 완료합니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 부하 분산기가 생성이 되면 다음 [그림 17]과 같이 백엔드 서비스에 지정된 인스턴스 그룹에 해당하는 인스턴스가 모두 정상 동작하는 화면을 볼 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_17.png&quot; alt=&quot;lb_detail&quot; width=&quot;800&quot; height=&quot;404&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 17] 부하 분산기 세부 정보&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bucket 생성 및 백업 설정&lt;/strong&gt;   &lt;a name=&quot;list2_5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[Storage] - [브라우저]&lt;/strong&gt; 탭을 눌러 &lt;strong&gt;버킷 생성&lt;/strong&gt; 버튼을 클릭하여 버킷을 생성합니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_18.png&quot; alt=&quot;create_bucket&quot; width=&quot;900&quot; height=&quot;145&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 18] 버킷 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;버킷 이름을 입력하고 리전을 아시아로 설정한 후에 나머지는 기본 값으로 생성하게 되면 위의 [그림 18]과 같이 버킷이 생성된 모습을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;생성한 버킷의 권한 탭에 들어오면 버킷에 접근 가능한 구성원들과 역할을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 19]에서 보이는 &lt;strong&gt;추가&lt;/strong&gt; 버튼을 클릭하여 새로운 구성원을 추가해줍니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_19.png&quot; alt=&quot;bucket_allUsers&quot; width=&quot;500&quot; height=&quot;223&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 19] 버킷 allUsers 구성원 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allUsers&lt;/code&gt; 구성원에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;저장소 개체 관리자&lt;/code&gt; 역할을 주어 모든 사용자들이 저장소에 접근할 수 있도록 설정했습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 Cloud SQL에 저장된 wordpress 데이터베이스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump&lt;/code&gt;하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crontab&lt;/code&gt;을 통해 주기적으로 백업하기 위한 명령어입니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim /etc/my.cnf
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;mysqldump]
  &lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root
  &lt;span class=&quot;nv&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Input Your Password

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim cloudsql_backup.sh
  &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;db_instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql-wordpress
  &lt;span class=&quot;nv&quot;&gt;db_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wordpress
  &lt;span class=&quot;nv&quot;&gt;db_user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root
  &lt;span class=&quot;nv&quot;&gt;bucket_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gs://bucket-mysql-wordpress
  &lt;span class=&quot;nv&quot;&gt;socket_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress
  &lt;span class=&quot;nv&quot;&gt;date_YYYYMMDDHHMMSS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'+%Y%m%d%H%M%S'&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;backupfile_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wordpress_&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;date_YYYYMMDDHHMMSS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;.sql

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Cloud SQLl daily backup start..&quot;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;#gcloud sql export csv $db_instance $bucket_name/test.csv --database=$db_name --query=$sql_query&lt;/span&gt;
  mysqldump &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$db_user&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$socket_path&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--databases&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$db_name&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--hex-blob&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--single-transaction&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--default-character-set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;utf8mb4 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backupfile_name&lt;/span&gt;

  gsutil &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backupfile_name&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$bucket_name&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Cloud SQL daily backup stop..&quot;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# crontab &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt;
  0 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/3 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; /root/cloudsql_backup.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Cloud SQL을 백업하는 쉘 스크립트를 작성하여 crontab에 등록하여 3시간 주기로 mysqldump가 실행되도록 설정해두고 일정 시간이 지난 후에 버킷에 정상적으로 백업되어 저장됐는지 확인하였습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_20.png&quot; alt=&quot;cloudsql_bucket_backup1&quot; width=&quot;800&quot; height=&quot;323&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 20] crontab을 사용한 Cloud SQL의 주기적인 백업&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 20]에서 최종 수정 날짜를 확인해보면 3시간 주기로 저장되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;같은 형태로 이번에는 syslog를 백업하는 쉘 스크립트를 작성하여 crontab에 등록합니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim apache_log_backup.sh
  &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;syslog daily backup start..&quot;&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /var/log/messages | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-iE&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;apache|wordpress&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /root/apache_log_backup_&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'+%y-%m-%d'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;.log
  gsutil &lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /root/apache_log_backup_&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.log gs://bucket-mysql-wordpress/apache_log_backup/
  &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt; /root/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.log

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;syslog daily backup stop..&quot;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# crontab &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; /root/apache_log_backup.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이번에는 매 분마다 쉘 스크립트를 실행하도록 crontab에 등록하고 버킷을 확인해보았습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_21.png&quot; alt=&quot;syslog_bucket_backup&quot; width=&quot;800&quot; height=&quot;383&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 21] crontab을 사용한 syslog의 주기적인 백업&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Stack Driver를 활용한 모니터링 및 로깅 시스템 구축&lt;/strong&gt;   &lt;a name=&quot;list2_6&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;VM 인스턴스에 monitoring-agent 설치&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sSO&lt;/span&gt; https://dl.google.com/cloudagents/add-monitoring-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;bash add-monitoring-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;stackdriver-agent

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start stackdriver-agent
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;stackdriver-agent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;VM 인스턴스에 logging-agent 설치&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sSO&lt;/span&gt; https://dl.google.com/cloudagents/add-logging-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;bash add-logging-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;google-fluentd
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;google-fluentd-catch-all-config-structured

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start google-fluentd
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;google-fluentd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;모니터링과 로깅을 할 VM 인스턴스에 에이전트를 설치하고 &lt;strong&gt;[모니터링] - [대시보드]&lt;/strong&gt; 탭을 눌러 들어갑니다.&lt;/p&gt;

    &lt;p&gt;대시보드 페이지에 들어오면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create Dashboard&lt;/code&gt; 버튼을 통해 새로운 대시보드를 생성할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;원하는 대시보드의 이름을 입력하고 대시보드를 생성하면 우측 상단에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add Chart&lt;/code&gt; 버튼을 눌러 원하는 차트들을 추가하여 대시보드를 커스터마이징할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_22.png&quot; alt=&quot;add_chart&quot; width=&quot;800&quot; height=&quot;402&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 22] 대시보드 차트 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 22]와 같이 차트에 나타낼 CPU, Memory, I/O 등 모니터링할 항목들의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Metric&lt;/code&gt;과 Instance, Group 등 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resource 타입&lt;/code&gt;을 지정하고 차트를 생성할 수 있습니다. 원하는 차트를 추가하고 대시보드를 확인하면 다음 [그림 23]과 같이 monitoring-agent을 통해 VM 인스턴스의 Metric들을 모니터링할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_23.png&quot; alt=&quot;monitoring_dashboard&quot; width=&quot;1000&quot; height=&quot;744&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 23] 모니터링 대시보드 완성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 로깅 시스템은 &lt;strong&gt;[로그 기록] - [로그 뷰어]&lt;/strong&gt; 탭에 들어오면 다음 [그림 24]와 같이 logging-agent를 통해 수집된 로그들을 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_24.png&quot; alt=&quot;log_viewer&quot; width=&quot;900&quot; height=&quot;294&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 24] 로그 뷰어 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_25.png&quot; alt=&quot;log_query&quot; width=&quot;900&quot; height=&quot;316&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 25] 로그 뷰어 쿼리 빌더&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-프로젝트-테스트---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;3. 프로젝트 테스트&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cloud SQL 로깅 테스트&lt;/strong&gt;   &lt;a name=&quot;list3_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;서비스 중인 워드프레스 서버에서 Cloud SQL에 대한 접속을 시도하는데 다음 [그림 26]과 같이 패스워드를 잘못 입력한 상황입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_26.png&quot; alt=&quot;cloudsql_connection_failure&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 26] Cloud SQL 접속 실패&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;패스워드를 잘못 입력하여 접속을 실패하여 쉘에 나타나는 로그를 다음 [그림 27]처럼 GCP의 로그 뷰어에서도 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_27.png&quot; alt=&quot;cloudsql_log_viewer&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 27] Cloud SQL 접속 실패 로그 뷰어&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;오토 스케일링 및 부하 테스트&lt;/strong&gt;   &lt;a name=&quot;list3_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 아파치(Apache)의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JMeter&lt;/code&gt;라는 툴을 사용하여 부하 테스트를 진행합니다.&lt;/p&gt;

    &lt;p&gt;JMeter에서 핵심 기능은 웹 HTTP/HTTPS 프로토콜을 통해 클라이언트의 요청을 수행하여 부하를 발생시키는 것입니다.&lt;/p&gt;

    &lt;p&gt;요청에 대한 성공/실패, 소요 시간 등의 정보를 기록하여 제공해줍니다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 28]은 테스트할 사용자 수 및 반복 횟수 등을 설정해 웹 사이트 서버의 성능을 테스트한 내용입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_28.png&quot; alt=&quot;jmeter&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 28] JMeter로 부하 테스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기서 &lt;strong&gt;스레드를 300개와 1000개 두 번의 부하 테스트를 진행&lt;/strong&gt;하였고, 300개의 스레드로 요청을 보냈을 때 오토 스케일링 기능으로 인해 인스턴스의 갯수가 2개에서 3개로 늘어났고, 1000개의 스레드로 부하를 주었을 때 3개에서 4개로 인스턴스가 자동 확장되는 것을 확인할 수 있었습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_29.png&quot; alt=&quot;instance_upscale&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 29] 인스턴스 자동 확장&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 29]는 인스턴스가 3개에서 4개로 확장되는 장면을 캡처한 것입니다.&lt;/p&gt;

    &lt;p&gt;다음으로 부하 테스트를 진행하면서 인스턴스가 자동 생성되는 부분을 모니터링을 통해 확인하였습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_30.png&quot; alt=&quot;instance_upscale_monitoring&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 30] 인스턴스 확장 모니터링&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 30]에서 볼 수 있듯이 부하 테스트를 수행한 시점에 &lt;strong&gt;CPU, Memory, Network traffic이 확 늘어난 것을 확인&lt;/strong&gt;할 수 있고, 그와 동시에 인스턴스가 각각 하나씩 생겨난 것을 확인할 수 있습니다. 메모리 사용량을 확인하는 부분에서 측정 항목(인스턴스)가 새로 생겨난 것을 쉽게 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;그 후 &lt;strong&gt;마지막 10분&lt;/strong&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정화 기간&lt;/code&gt;이라고 하는데, 안정화 기간동안 관찰된 최대 부하를 기준으로 관리형 인스턴스 그룹이 유지되면 자동으로 인스턴스가 축소 되는 것을 확인할 수 있습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_31.png&quot; alt=&quot;instance_downscale&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 31] 인스턴스 자동 축소&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;물론 안정화 기간에 대한 설정은 로드밸런싱을 구성할 때 따로 설정이 가능하고, 인스턴스는 생성된지 가장 오래된 인스턴스를 우선으로 삭제되는 것 같았습니다.&lt;/p&gt;

    &lt;p&gt;이로써 GCP의 기능을 활용한 서버 구성과 로깅 및 테스트까지 정상적으로 끝났습니다!&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 16 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/08/16/gcp_project.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/08/16/gcp_project.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>gcp</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] ssustack_installer</title>
        <description>&lt;p&gt;본 프로젝트는 숭실대학교에서 김명호 교수님의 지도하에 진행 된 프로젝트입니다.&lt;/p&gt;

&lt;h2 id=&quot;ssustack_installer&quot;&gt;ssustack_installer&lt;/h2&gt;

&lt;p&gt;ssustack_installer 프로젝트는 ssustack 설치를 웹 브라우저에서 더욱 쉽게 설치할 수 있도록 도와줍니다.&lt;/p&gt;

&lt;p&gt;ssustack_installer를 실행하면 웹 브라우저가 뜨게되고, 필요한 설정을 입력 및 선택하면 ssustack 스크립트를 기반으로 설치가 시작됩니다.&lt;/p&gt;

&lt;p&gt;사용자의 선택에 따라 싱글노드 혹은 멀티호스트로 자유롭게 설치가 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;environment&quot;&gt;Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OpenStack : Rokcy Release&lt;/li&gt;
  &lt;li&gt;OS : Ubuntu 18.04 LTS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;다음 설명할 설치 방법은 모든 노드가 Ubuntu 18.04 운영체제만 설치된 환경이라 가정하고 진행해야 할 작업을 설명합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-ssustack--ssustack_installer-클론&quot;&gt;1. ssustack &amp;amp; ssustack_installer 클론&lt;/h4&gt;

&lt;p&gt;OpenStack 환경을 구성하는 모든 노드에서 진행합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone http://git.dotstack.io/crisis513/ssustack.git
$ git clone http://git.dotstack.io/dotstack/ssustack_installer.git
$ cd ssustack/bin
$ ./ssustack_user_creation.sh
$ cp -r &amp;lt;your_controller_path&amp;gt;/ssustack/ .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성할 유저의 패스워드를 설정하여 ssustack 유저가 생성되면 ssustack 폴더를 ssustack 유저의 홈 디렉토리로 복사합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-network-설정&quot;&gt;2. network 설정&lt;/h4&gt;

&lt;p&gt;모든 노드의 네트워크 인터페이스를 수정 후 재부팅해주어야 합니다. 먼저 Controller node의 경우, 외부와의 통신을 위한 네트워크와 오픈스택 컴포넌트들이 서로 API를 호출할 때 사용하는 내부 네트워크, VM 인스턴스들이 외부와 통신하기 위한 메뉴얼 네트워크를 설정해주어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/network/interfaces
auto &amp;lt;INTERFACE_NAME_1&amp;gt;
iface &amp;lt;INTERFACE_NAME_1&amp;gt; inet static
    address &amp;lt;PUBLIC_IP&amp;gt;
    netmask &amp;lt;PUBLIC_IP_NETMASK&amp;gt;
    gateway &amp;lt;PUBLIC_IP_GATEWAY&amp;gt;
    dns-servernames &amp;lt;DNS_NAMESERVERS&amp;gt;
auto &amp;lt;INTERFACE_NAME_2&amp;gt;
iface &amp;lt;INTERFACE_NAME_2&amp;gt; inet static
    address 10.10.10.11
    netmask 255.255.255.0
auto &amp;lt;INTERFACE_NAME_3&amp;gt;
iface &amp;lt;INTERFACE_NAME_3&amp;gt; inet manual
up ip link set dev $IFACE up
down ip link set dev $IFACE down
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compute node의 경우, 메뉴얼 네트워크가 필요없다. 오픈스택 설치가 정상적으로 설치되고나면 외부와의 통신은 필요없어 외부 네트워크를 OSD들 간의 통신을 위한 스토리지 네트워크로 설정하여 사용해도 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/network/interfaces
auto &amp;lt;INTERFACE_NAME_1&amp;gt;
iface &amp;lt;INTERFACE_NAME_1&amp;gt; inet static
    address &amp;lt;PUBLIC_IP&amp;gt;
    netmask &amp;lt;PUBLIC_IP_NETMASK&amp;gt;
    gateway &amp;lt;PUBLIC_IP_GATEWAY&amp;gt;
    dns-servernames &amp;lt;DNS_NAMESERVERS&amp;gt;
auto &amp;lt;INTERFACE_NAME_2&amp;gt;
iface &amp;lt;INTERFACE_NAME_2&amp;gt; inet static
    address 10.10.10.21
    netmask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-hosts-및-ssh-설정&quot;&gt;3. hosts 및 SSH 설정&lt;/h4&gt;

&lt;p&gt;위의 작업이 끝나면 Controller node에서 hosts 및 SSH 설정합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/hosts
10.10.10.11 controller-node
10.10.10.21 compute-node1 
10.10.10.22 compute-node2
10.10.10.23 compute-node3
    
$ cd ssustack/bin/
$ ./creating_ssh_keys.sh [&amp;lt;host_name&amp;gt; ... ]
ex) ./creating_ssh_keys.sh compute-node1 compute-node2 compute-node3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-ssustack_installer-실행&quot;&gt;4. ssustack_installer 실행&lt;/h4&gt;

&lt;p&gt;ssustack_installer는 Controller node에서 실행시킵니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ssustack_installer/
$ ./app.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;app.sh를 실행시키고나면 우분투 기본 브라우저로 사용되는 파이어폭스가 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-welcome-페이지&quot;&gt;5. Welcome 페이지&lt;/h4&gt;

&lt;p&gt;권장 사양과 현재 PC의 사양을 확인해보고 설치 전 작업이 재대로 되었는지 확인하고 다음으로 넘어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-enable-services-페이지&quot;&gt;6. Enable Services 페이지&lt;/h4&gt;

&lt;p&gt;Controller node 및 Compute node에서 설치할 서비스를 선택하고 넘어갑니다. 필수로 설치되어야하는 패키지의 경우 이미 체크되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-environment-settings-페이지&quot;&gt;7. Environment Settings 페이지&lt;/h4&gt;

&lt;p&gt;각각의 Controller node 및 Compute node에서 설정되어야 할 ip, subnet, hostname, password 등을 설정하고 다음으로 넘어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-installing-페이지&quot;&gt;8. Installing 페이지&lt;/h4&gt;

&lt;p&gt;앞의 설정이 재대로 되어있는지 확인해보고 Start 버튼을 눌러주고 설치 로그를 확인해줍니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 번만 누르고 브라우저를 종료하면 안됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-finished-페이지&quot;&gt;9. Finished 페이지&lt;/h4&gt;

&lt;p&gt;정상적으로 설치되었는지 확인하고 종료합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;10-추가-설정&quot;&gt;10. 추가 설정&lt;/h4&gt;

&lt;p&gt;아래 비디오에서 Ceph OSD를 추가하고, Horizon에서 네트워크를 생성하고, 우분투 이미지를 업로드하여 인스턴스 생성 및 테스트하는 부분까지 보여줍니다. (10:30)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;testing-video&quot;&gt;Testing video&lt;/h3&gt;

&lt;video width=&quot;840&quot; height=&quot;480&quot; src=&quot;/static/assets/video/ssustack_working.mp4&quot; controls=&quot;&quot;&gt;&lt;/video&gt;

&lt;blockquote&gt;
  &lt;p&gt;영상이 재생되지 않는다면 IE 환경에서 다시 재생해보세요.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 30 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/04/30/ssustack_installer.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/04/30/ssustack_installer.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>ssustack</category>
        
        <category>installer</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] ssustack</title>
        <description>&lt;p&gt;본 프로젝트는 숭실대학교에서 김명호 교수님, 김영종 교수님의 지도하에 진행되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;ssustack&quot;&gt;ssustack&lt;/h2&gt;

&lt;p&gt;ssustack 프로젝트는 Ubuntu 환경에서 OpenStack을 자동으로 설치하여 클라우드 컴퓨팅을 손쉽게 구축할 수 있도록 만들어졌습니다.&lt;/p&gt;

&lt;p&gt;OpenStack에서 사용할 기본적인 설정을 정의한 후에 설치스크립트를 이용하여 간편하게 설치가 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;environment&quot;&gt;Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OpenStack : Rokcy Release&lt;/li&gt;
  &lt;li&gt;OS : Ubuntu 18.04 LTS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;minimum-hardware-requirements&quot;&gt;Minimum hardware requirements&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Controller node
    &lt;ul&gt;
      &lt;li&gt;Processor: 1 Core&lt;/li&gt;
      &lt;li&gt;Ram: 4GB&lt;/li&gt;
      &lt;li&gt;Storage: 5GB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Compute node
    &lt;ul&gt;
      &lt;li&gt;Processor: 1 Core&lt;/li&gt;
      &lt;li&gt;Ram: 2GB&lt;/li&gt;
      &lt;li&gt;Storage: 10GB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;노드별-설치-패키지&quot;&gt;노드별 설치 패키지&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/node_packages.png&quot; alt=&quot;node_packages&quot; width=&quot;600&quot; height=&quot;280&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;다음 설명할 설치 방법은 모든 노드가 Ubuntu 18.04 운영체제만 설치된 환경이라 가정하고 진행해야 할 작업을 설명합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-ssustack-클론&quot;&gt;1. ssustack 클론&lt;/h4&gt;

&lt;p&gt;OpenStack 환경을 구성하는 모든 노드에서 진행&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone http://git.dotstack.io/crisis513/ssustack.git
$ cd ssustack/bin
$ ./ssustack_user_creation.sh
$ cp -r &amp;lt;your_controller_path&amp;gt;/ssustack/ .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성할 유저의 패스워드를 설정하여 ssustack 유저가 생성되면 ssustack 폴더를 ssustack 유저의 홈 디렉토리로 복사합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-hosts-및-ssh-설정&quot;&gt;2. hosts 및 SSH 설정&lt;/h4&gt;

&lt;p&gt;위의 작업이 끝나면 controller node에서 hosts 및 SSH 설정&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/hosts
10.10.10.11 controller-node
10.10.10.21 compute-node1 
10.10.10.22 compute-node2
10.10.10.23 compute-node3
    
$ cd ssustack/bin/
$ ./creating_ssh_keys.sh [&amp;lt;host_name&amp;gt; ... ]
ex) ./creating_ssh_keys.sh compute-node1 compute-node2 compute-node3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-openstack-설치-스크립트-설정&quot;&gt;3. OpenStack 설치 스크립트 설정&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ..
$ vi local.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-localconf-설정을-기반으로-각-노드별-스크립트-생성&quot;&gt;4. local.conf 설정을 기반으로 각 노드별 스크립트 생성&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./ssustack.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-ssustacktmp-경로에서-각-노드에-맞는-스크립트-실행&quot;&gt;5. ssustack/tmp 경로에서 각 노드에 맞는 스크립트 실행&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## controller-node Case
$ cd tmp/controller/
$ ./controller.sh

## compute-node1 Case
$ cd tmp/compute/
$ ./compute_1.sh
 
## compute-node2 Case
$ cd tmp/compute/
$ ./compute_2.sh
 
## compute-node3 Case
$ cd tmp/compute/
$ ./compute_3.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;현재는 각 스크립트를 직접 수정하여 rbd_secret_uuid 값을 수동으로 맞춰주어야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-controller-node에서-ceph-추가-설정&quot;&gt;6. controller node에서 ceph 추가 설정&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ../../bin/ # ssustack/bin/
$ ./ceph_configuration.sh [&amp;lt;host_name&amp;gt; ... ]
ex) ./ceph_configuration.sh compute-node1 compute-node2 compute-node3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-각-compute-node에서-ceph-osd-및-ceph-mon-설정&quot;&gt;7. 각 compute node에서 ceph osd 및 ceph mon 설정&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ../../bin/ # ssustack/bin/
$ ./add_ceph_osd.sh /dev/sdb    # /dev/sdb는 각 컴퓨터 노드에서 추가할 osd 장치명
$ ./add_ceph_mon.sh 10.10.10.21 # 10.10.10.21은 각 컴퓨터 노드에서 management network로 사용하는 ip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-controller-node에서-compute-호스트를-찾도록-스크립트-실행&quot;&gt;8. controller node에서 compute 호스트를 찾도록 스크립트 실행&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./add_compute_node.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 29 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/04/29/ssustack.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/04/29/ssustack.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>ssustack</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] naver-news-scraper</title>
        <description>&lt;h1 id=&quot;naver-news-scraper&quot;&gt;naver-news-scraper&lt;/h1&gt;

&lt;p&gt;nn-scraper 프로젝트는 원하는 키워드에 해당하는 네이버 뉴스 속보를 스크랩하여 텔레그램 봇 혹은 카카오톡 봇으로 알림받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;environment&quot;&gt;Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OS : Ubuntu 18.04 LTS&lt;/li&gt;
  &lt;li&gt;Python : 2.7.17&lt;/li&gt;
  &lt;li&gt;pip : 9.0.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;h4 id=&quot;1-naver-news-scraper-클론&quot;&gt;1. naver-news-scraper 클론&lt;/h4&gt;

&lt;p&gt;naver-news-scraper 소스를 다운로드 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/crisis513/naver-news-scraper.git
$ cd naver-news-scraper
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-실행환경-설정&quot;&gt;2. 실행환경 설정&lt;/h4&gt;

&lt;p&gt;nn-scraper 실행을 위해 python 및 pip를 설치하고, 필요한 pip 패키지를 설치합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install -y python python-pip
$ pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-봇-설정&quot;&gt;3. 봇 설정&lt;/h4&gt;

&lt;p&gt;nn-scraper에서 사용할 수 있는 봇은 카카오톡, 텔레그램 두 종류가 있습니다.&lt;/p&gt;

&lt;p&gt;사용할 봇을 설정하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;1) config.py 파일에서 USE_BOT 값을 카카오톡일 경우 kakaotalk, 텔레그램일 경우 telegram으로 입력합니다.&lt;/p&gt;

&lt;p&gt;2) 아래 Testing images에서 선택한 플랫폼에 맞게 토큰 값을 얻어 config.py 파일에서 요구하는 토큰 혹은 키 값을 입력합니다.&lt;/p&gt;

&lt;p&gt;3) app.py 파일을 실행하면 1분 주기로 SEARCH_LIST 값에 설정된 키워드에 맞는 네이버 속보 뉴스를 스크랩하여 보내줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;testing-images&quot;&gt;Testing images&lt;/h3&gt;

&lt;h4 id=&quot;telegram-bot&quot;&gt;[Telegram bot]&lt;/h4&gt;

&lt;p&gt;텔레그램 봇을 사용하기 위해서는 @botfather 를 검색하여 아래 사진과 같이 새로운 봇을 만들고 봇의 TOKEN을 획득해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/telegrambot.png&quot; alt=&quot;use_telegrambot&quot; width=&quot;360&quot; height=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에서 획득한 TOKEN 값을 config.py 파일에서 TELEGRAM_TOKEN 값에 넣어줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/telegrambot2.jpg&quot; alt=&quot;use_telegrambot&quot; width=&quot;350&quot; height=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;kakaotalk-bot&quot;&gt;[Kakaotalk bot]&lt;/h4&gt;

&lt;p&gt;카카오톡 봇을 사용하기 위해서는 Kakao Developer 사이트에서 카카오 API KEY를 발급 받아야 합니다.&lt;/p&gt;

&lt;p&gt;https://developers.kakao.com/&lt;/p&gt;

&lt;p&gt;해당 사이트로 들어가서 로그인을 하고 애플리케이션을 만들어줍니다.&lt;/p&gt;

&lt;p&gt;여기서는 NN-SCRAPER 라는 앱 이름으로 생성하였고, 정상적으로 설치되면 아래 사진처럼 각종 앱 키가 보이는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/kakaotalkbot.png&quot; alt=&quot;use_kakaotalkbot&quot; width=&quot;700&quot; height=&quot;460&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 앱 키 중에서 REST API 키를 config.py 파일에서 RESTAPI_KEY 값에 넣어줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/kakaotalkbot2.png&quot; alt=&quot;use_kakaotalkbot&quot; width=&quot;360&quot; height=&quot;780&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/project/2020/04/08/nn_scraper.html</link>
        <guid isPermaLink="true">http://localhost:4000/project/2020/04/08/nn_scraper.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>nn-scraper</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Patent] 히스토그램을 이용한 영상 처리 방법 및 이를 수행하기 위한 기록매체</title>
        <description>&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;히스토그램을 이용한 고속 유사도 측정 방법 및 이를 수행할 수 있는 유사도 측정 장치가 제공된다. 본 발명의 실사례에 따른 고속 유사도 측정 방법은 유사도 측정 대상 영상의 히스토그램을 생성하는 히스토그램 생성 단계, 상기 히스토그램을 기반으로 상기 유사도 측정 대상 영상의 이진수 열을 생성하는 메타데이터 생성 단계, 메타데이터 데이터베이스로부터 기준 영상의 이진수 열을 획득하여 상기 유사도 측정 대상 영상의 이진수 열과 매칭(matching)하는 매칭 단계 및 상기 매칭 결과를 출력하는 출력 단계를 포함한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 특허증&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;   1.1. 특허&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;   1.2. 출원번호&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;   1.3. 출원일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;   1.4. 등록일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list6&quot;&gt;   1.5. 발명의 명칭&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list7&quot;&gt;   1.6. KIPRIS 검색&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;특허증----&quot;&gt;특허증    &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h5 id=&quot;certificate-of-patent&quot;&gt;CERTIFICATE OF PATENT&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특허&quot;&gt;특허&lt;/h3&gt;
&lt;h6 id=&quot;patent-number&quot;&gt;PATENT NUMBER&lt;/h6&gt;
&lt;p&gt;10-1957610&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원번호&quot;&gt;출원번호&lt;/h3&gt;
&lt;h6 id=&quot;application-number&quot;&gt;Application Number&lt;/h6&gt;
&lt;p&gt;10-2017-0173938&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원일&quot;&gt;출원일&lt;/h3&gt;
&lt;h6 id=&quot;filing-date&quot;&gt;Filing Date&lt;/h6&gt;
&lt;p&gt;2017년 12월 18일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;등록일&quot;&gt;등록일&lt;/h3&gt;
&lt;h6 id=&quot;registration-date&quot;&gt;Registration Date&lt;/h6&gt;
&lt;p&gt;2019년 03월 06일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;발명의-명칭&quot;&gt;발명의 명칭&lt;/h3&gt;
&lt;h6 id=&quot;title-of-the-invention&quot;&gt;Title of the Invention&lt;/h6&gt;
&lt;p&gt;히스토그램을 이용한 영상 처리 방법 및 이를 수행하기 위한 기록매체&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kipris-검색&quot;&gt;KIPRIS 검색&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/patent2.png&quot; alt=&quot;patent2&quot; width=&quot;675&quot; height=&quot;150&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/patent/2020/04/03/patent2.html</link>
        <guid isPermaLink="true">http://localhost:4000/patent/2020/04/03/patent2.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>patent</category>
        
        <category>histogram</category>
        
        
        <category>Patent</category>
        
      </item>
    
      <item>
        <title>[Patent] 타이핑 속도 정보를 이용한 사용자 인증 시스템 및 방법, 이를 수행하기 위한 기록매체</title>
        <description>&lt;h3 id=&quot;abstact&quot;&gt;Abstact&lt;/h3&gt;

&lt;p&gt;타이핑 속도 정보를 이용한 사용자 인증 시스템 및 방법을 개시한다. 사용자 단말로부터 수신한 ID와 패스워드를 이용하여 웹 서버에서 사용자 인증을 수행하는 사용자 인증 시스템에 있어서, 상기 사용자 단말은, 사용자로부터 ID 및 패스워드를 입력받는 입력부; 상기 입력부를 통해 패스워드를 입력받을 때, 패스워드를 구성하는 각각의 문자에 대해 키 입력이 시작되는 시간 및 키 입력이 종료되는 시간, 마지막 엔터키가 입력되는 시간을 감지하여 키 입력 정보를 생성하는 키 입력 정보 생성부; 및 상기 입력부를 통해 입력받은 ID 및 패스워드와 상기 키 입력 정보 생성부에서 생성된 키 입력 정보를 상기 웹 서버로 전송하는 전송부;를 포함하고, 상기 웹 서버는, 상기 사용자 단말로부터 ID 및 패스워드와 키 입력 정보를 수신하는 수신부; 사용자별로 사용자 인증에 필요한 ID 및 패스워드와 타이핑 속도 허용 범위를 저장하는 사용자 인증 DB; 상기 수신한 키 입력 정보를 이용하여 패스워드를 구성하는 문자열의 입력에 대한 타이핑 속도를 산출하는 타이핑 속도 산출부; 상기 수신한 ID 및 패스워드와 상기 사용자 인증 DB에 저장되어 있는 ID 및 패스워드를 비교하여 사용자 인증을 수행하는 제1사용자 인증부; 및 상기 제1사용자 인증부에서 사용자 인증에 성공하면, 상기 산출된 타이핑 속도와 상기 ID에 매핑되어 상기 사용자 인증 DB에 저장되어 있는 타이핑 속도 허용 범위를 비교하여 사용자 인증을 수행하는 제2사용자 인증부;를 포함하는 것이 바람직하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 특허증&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;   1.1. 특허&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;   1.2. 출원번호&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;   1.3. 출원일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;   1.4. 등록일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list6&quot;&gt;   1.5. 발명의 명칭&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list7&quot;&gt;   1.6. KIPRIS 검색&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;특허증----&quot;&gt;특허증    &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h5 id=&quot;certificate-of-patent&quot;&gt;CERTIFICATE OF PATENT&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특허----&quot;&gt;특허    &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;patent-number&quot;&gt;PATENT NUMBER&lt;/h6&gt;
&lt;p&gt;10-1959219&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원번호----&quot;&gt;출원번호    &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;application-number&quot;&gt;Application Number&lt;/h6&gt;
&lt;p&gt;10-2017-0120224&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원일--&quot;&gt;출원일  &lt;a name=&quot;list4&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;filing-date&quot;&gt;Filing Date&lt;/h6&gt;
&lt;p&gt;2017년 09월 19일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;등록일--&quot;&gt;등록일  &lt;a name=&quot;list5&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;registration-date&quot;&gt;Registration Date&lt;/h6&gt;
&lt;p&gt;2019년 03월 12일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;발명의-명칭-&quot;&gt;발명의 명칭 &lt;a name=&quot;list6&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;title-of-the-invention&quot;&gt;Title of the Invention&lt;/h6&gt;
&lt;p&gt;타이핑 속도 정보를 이용한 사용자 인증 시스템 및 방법, 이를 수행하기 위한 기록매체&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kipris-검색-&quot;&gt;KIPRIS 검색 &lt;a name=&quot;list7&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/patent.png&quot; alt=&quot;patent1&quot; width=&quot;675&quot; height=&quot;150&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/patent/2020/04/03/patent1.html</link>
        <guid isPermaLink="true">http://localhost:4000/patent/2020/04/03/patent1.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>patent</category>
        
        <category>authentication</category>
        
        <category>tps</category>
        
        
        <category>Patent</category>
        
      </item>
    
      <item>
        <title>[Thesis] 클라우드 컴퓨팅 환경에서 블록체인 기반의 인증 키 관리 시스템 설계 및 구현</title>
        <description>&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;클라우드 컴퓨팅은 컴퓨팅 자원을 유연하게 사용할 수 있어 프로비저닝이 빠르고 편리하며 확장성이 높은 등 많은 장점을 제공하고 있다. 하지만 해킹을 통한 중요 데이터가 유출되는 사고가 발생한 사례들이 많아 클라우드 보안 위협은 꾸준히 제기되고 있다. 그 중에서도 클라우드 인증에 사용되는 토큰과 이 토큰의 정보를 보호하기 위해 사용되는 암호 키를 관리하는 것은 보안에 있어 항상 중요한 문제이다. 암호 키가 재대로 관리되지 않으면 무단 접근을 허용하여 조직 혹은 사용자에게 심각한 피해가 생기게 된다. 보안 강도가 높은 암호화 알고리즘을 사용하더라도 키가 노출된다면 자유롭게 데이터를 복호화할 수 있게 되기 때문에 키 관리는 매우 중요하다. 기존에는 대부분 중앙집중식으로 키를 관리하여 확장성이 낮고 분산된 키 관리 서비스를 제공하지 않아 항상 잠재적인 단일 장애점의 문제를 갖고 있다. 그리고 키 보안 공급 업체를 통해 암호 키를 관리하더라도 단일 보안 위반 상태가 된다.&lt;/p&gt;

&lt;p&gt;본 논문에서는 프라이빗 블록체인을 구축하여 허가형 비공개 네트워크에서 안전하게 암호 키를 분산 저장 및 관리하는 환경을 통해 클라우드 컴퓨팅 인증을 수행하는 시스템을 제안한다. 제안하는 시스템은 기존에 항상 잠재적으로 존재해왔던 단일 장애점의 문제를 해결하고 분산 저장을 통해 확장성을 높일 수 있다. 제안하는 시스템을 구현한 결과 기존의 키 관리 방식에 비해 성능에 큰 차이가 없고 기본적인 키 관리 요구사항들을 충족시키면서 단일 장애점의 문제를 해결했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 논문 제목&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;   1.1. 저자&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;   1.2. 발행연도&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;   1.3. 주제어&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;   1.4. URL&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;논문-제목---&quot;&gt;논문 제목   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;클라우드 컴퓨팅 환경에서 블록체인 기반의 인증 키 관리 시스템 설계 및 구현 = Design and Implementation of Blockchain-based Authentication Key Management System in Cloud Computing Environment&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;저자----&quot;&gt;저자    &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;손한기&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;발행연도----&quot;&gt;발행연도    &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2020.02&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;주제어----&quot;&gt;주제어    &lt;a name=&quot;list4&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;클라우드 컴퓨팅, 블록체인, 키 관리 시스템&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;url---&quot;&gt;URL   &lt;a name=&quot;list5&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;http://www.riss.kr/search/detail/DetailView.do?p_mat_type=be54d9b8bc7cdb09&amp;amp;control_no=648f5d72e457c232ffe0bdc3ef48d419&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/thesis/2020/04/01/bkms.html</link>
        <guid isPermaLink="true">http://localhost:4000/thesis/2020/04/01/bkms.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>thesis</category>
        
        <category>bkms</category>
        
        <category>blockchain</category>
        
        <category>cloud</category>
        
        
        <category>Thesis</category>
        
      </item>
    
      <item>
        <title>Blog sample</title>
        <description>&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 헤더(Header)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 목록(List)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 이미지(Images)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;4. 하이퍼링크(Links)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;5. 인용 상자(Blockquotes)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list6&quot;&gt;6. 강조(Emphasis)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list7&quot;&gt;7. 테이블(Tables)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list8&quot;&gt;8. 체크 박스(Task Lists)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list9&quot;&gt;9. 인라인 코드(Inline code)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list10&quot;&gt;10. 수평선(hr)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list11&quot;&gt;11. 탈출 문자(Backslash Escapes)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list12&quot;&gt;12. 이모지(Emoji)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list13&quot;&gt;13. 코드 블록(Code Blocks)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list14&quot;&gt;14. 배지(Badge) 만들기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;헤더header----&quot;&gt;헤더(Header)    &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h1 id=&quot;헤더-크기-h1&quot;&gt;헤더 크기 (h1)&lt;/h1&gt;
&lt;h2 id=&quot;헤더-크기-h2&quot;&gt;헤더 크기 (h2)&lt;/h2&gt;
&lt;h3 id=&quot;헤더-크기-h3&quot;&gt;헤더 크기 (h3)&lt;/h3&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목록list----&quot;&gt;목록(List)    &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Unordered&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2
    &lt;ul&gt;
      &lt;li&gt;Item 2a&lt;/li&gt;
      &lt;li&gt;Item 2b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ordered&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3
    &lt;ol&gt;
      &lt;li&gt;Item 3a&lt;/li&gt;
      &lt;li&gt;Item 3b&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;이미지images----&quot;&gt;이미지(Images)    &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;첫번째 방법&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/markdown_logo.jpg&quot; alt=&quot;Github logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Format: &lt;img src=&quot;url 링크&quot; alt=&quot;이미지 alt명&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두번째 방법&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;https://github.com/..각자절대경로../images/markdown_syntax.jpg&quot; width=&quot;400px&quot; alt=&quot;sample image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Format: img 태그 사용 - 이미지경로는 상대경로 or 절대경로&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;하이퍼링크links----&quot;&gt;하이퍼링크(Links)    &lt;a name=&quot;list4&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;깃허브&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;인용-상자blockquotes----&quot;&gt;인용 상자(Blockquotes)    &lt;a name=&quot;list5&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As Grace Hopper said:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’ve always been more interested. 
in the future than in the past.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;강조emphasis----&quot;&gt;강조(Emphasis)    &lt;a name=&quot;list6&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;This text will be italic&lt;/em&gt; 
&lt;em&gt;This will also be italic&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This text will be bold&lt;/strong&gt; 
&lt;strong&gt;This will also be bold&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;You &lt;strong&gt;can&lt;/strong&gt; combine them&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;테이블tables----&quot;&gt;테이블(Tables)    &lt;a name=&quot;list7&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;First Header&lt;/th&gt;
      &lt;th&gt;Second Header&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Content cell 1&lt;/td&gt;
      &lt;td&gt;Content cell 2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content column 1&lt;/td&gt;
      &lt;td&gt;Content column 2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;체크-박스task-lists----&quot;&gt;체크 박스(Task Lists)    &lt;a name=&quot;list8&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;this is a complete item&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;this is an incomplete item&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;@mentions, #refs, &lt;a href=&quot;&quot;&gt;links&lt;/a&gt;, &lt;strong&gt;formatting&lt;/strong&gt;, and &lt;del&gt;tags&lt;/del&gt; supported&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;list syntax required (any unordered or ordered list supported)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;인라인-코드inline-code----&quot;&gt;인라인 코드(Inline code)    &lt;a name=&quot;list9&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;문단 중간에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code&lt;/code&gt;를 넣을 수 있습니다. 
예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf(&quot;hello world!&quot;);&lt;/code&gt; 이런 식으로 들어갑니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;수평선hr----&quot;&gt;수평선(hr)    &lt;a name=&quot;list10&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;탈출-문자backslash-escapes----&quot;&gt;탈출 문자(Backslash Escapes)    &lt;a name=&quot;list11&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;＼&lt;em&gt;literal asterisks＼&lt;/em&gt; 
&lt;em&gt;literal asterisks&lt;/em&gt; 
&lt;strong&gt;＼&lt;em&gt;＼&lt;/em&gt;Text＼&lt;em&gt;＼&lt;/em&gt;&lt;/strong&gt; 
_＼_Tom＼__&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;이모지emoji----&quot;&gt;이모지(Emoji)    &lt;a name=&quot;list12&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;GitHub supports emoji!&lt;/p&gt;

&lt;p&gt;:+1: :sparkles: :camel: :tada: 
:rocket: :metal: :octocat:&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;코드-블록code-blocks----&quot;&gt;코드 블록(Code Blocks)    &lt;a name=&quot;list13&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;코드 내용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;배지bedge-만들기----&quot;&gt;배지(Bedge) 만들기    &lt;a name=&quot;list14&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;https://shields.io&lt;/p&gt;

&lt;p&gt;작성 예시
&lt;a href=&quot;https://img.shields.io/badge/license-mit-green.svg&amp;quot;&quot;&gt;https://img.shields.io/badge/license-mit-green.svg&quot;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;https://img.shields.io/badge/–.svg&lt;/p&gt;

&lt;p&gt;APM: /apm/l/:packageName.svg&lt;/p&gt;

&lt;p&gt;AUR license: /aur/license/:packageName.svg&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Mar 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/sample/2020/03/07/sample.html</link>
        <guid isPermaLink="true">http://localhost:4000/sample/2020/03/07/sample.html</guid>
        
        <category>Son</category>
        
        <category>blog</category>
        
        
        <category>Sample</category>
        
      </item>
    
      <item>
        <title>code snippet test</title>
        <description>&lt;p&gt;This is a raw snippet:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello world
123
This is a text snippet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is a JavaScript snippet:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b
const minus = (a, b) =&amp;gt; a - b

console.log(add(100,200))  // 300
console.log(minus(100,200))  // -100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is a Python snippet:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def say_hello():
    print(&quot;hello world!&quot;)

say_hello()   // &quot;hello world!&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Side note comment: applied a bug fix similar to &lt;a href=&quot;https://github.com/Atlas7/atlas7.github.io/commit/6659f4a47f6ec66987adb0f683a9c6f3842252ae#diff-818954a41dbfb01af70050a459c603b9&quot;&gt;this commit&lt;/a&gt; to ensure code snippet does not collapse unexpectly upon clicking on it. This issue is tracked &lt;a href=&quot;https://github.com/jarrekk/Jalpc/issues/97&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/sample/2017/12/21/test_code_snippets.html</link>
        <guid isPermaLink="true">http://localhost:4000/sample/2017/12/21/test_code_snippets.html</guid>
        
        <category>Jalpc</category>
        
        <category>Jekyll</category>
        
        
        <category>Sample</category>
        
      </item>
    
      <item>
        <title>3 Steps (2 minutes) to Setup Your Personal Website with Jalpc</title>
        <description>&lt;p&gt;Everyone wants to have a personal website, you can display your infomation to public, post blogs and make friends. If you are CS engineer, haveing a self website will benefit your interview.&lt;/p&gt;

&lt;p&gt;So, if you like this website &lt;a href=&quot;https://jarrekk.github.io/Jalpc/&quot;&gt;https://jarrekk.github.io/Jalpc/&lt;/a&gt; or &lt;a href=&quot;http://www.jarrekk.com&quot;&gt;http://www.jarrekk.com&lt;/a&gt; and are willing to have a website, here is a way to build your website in 3 steps(2 minutes). Following are steps to setup your website(make sure you have basic knowledge of &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; and &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;, if you want to custom css/js &lt;a href=&quot;https://github.com/npm/npm&quot;&gt;NPM&lt;/a&gt; is needed):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Fork &lt;a href=&quot;https://github.com/jarrekk/Jalpc&quot;&gt;this project – Jalpc&lt;/a&gt; at &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt;. If you want to edit website at github, do it as following gif or clone forked repository. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone git@github.com:github_username/Jalpc.git&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;!-- ![edit](/crisis513.github.io/static/assets/img/blog/3steps/edit.gif) --&gt;
 &lt;img src=&quot;/crisis513.github.io/static/assets/img/blog/3steps/edit.gif&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enter into repository directory and edit following file list:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;: edit ‘Website settings’, ‘author’, ‘comment’ and ‘analytics’ items.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;_data/landing.yml&lt;/strong&gt;: custom sections of index page.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;_data/index/&lt;/strong&gt;: edit sections’ data to yours at index page, please notice comment at each file.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;_data/blog.yml&lt;/strong&gt;: edit navbar(categories) of blog page, if you have different/more blog page, copy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blog/python.html&lt;/code&gt; and change it to your category HTML file, and edit &lt;strong&gt;Python&lt;/strong&gt;, &lt;strong&gt;/python/&lt;/strong&gt; to your category name at items &lt;strong&gt;title&lt;/strong&gt; and &lt;strong&gt;permalink&lt;/strong&gt;, make sure title is the same as permalink but capitalized first letter(except HTML).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;CNAME&lt;/strong&gt;: If you wanna release website at your own domain name: edit it and create &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt; branch; if you want to use &lt;em&gt;github_username.github.io&lt;/em&gt;: leave it blank.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Go to repo’s settings panel, config &lt;strong&gt;GitHub Pages&lt;/strong&gt; section to make sure website is released.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Push changes to your github repository and view your website, done!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;From now on, you can post your blog to this website by creating md files at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;post/&lt;/code&gt; directory and push it to GitHub, you can clear files at this directory before you post blogs.&lt;/p&gt;

&lt;p&gt;If you like this repository, I appreciate you star this repository. Please don’t hesitate to mail me or post issues on GitHub if you have any questions. Hope you have a happy blog time!😊&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Jan 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/sample/2017/01/31/3_steps_to_setup_website_with_Jalpc.html</link>
        <guid isPermaLink="true">http://localhost:4000/sample/2017/01/31/3_steps_to_setup_website_with_Jalpc.html</guid>
        
        <category>Jalpc</category>
        
        <category>Jekyll</category>
        
        
        <category>Sample</category>
        
      </item>
    
      <item>
        <title>파이썬 크롤링</title>
        <description>&lt;h3 id=&quot;크롤링-관련-용어-정리&quot;&gt;크롤링 관련 용어 정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스크랩핑(scraping) : 데이터를 수집하는 행위&lt;/li&gt;
  &lt;li&gt;크롤링(Crawling) : 조직적 자동화된 방법으로 월드와이드웹을 탐색 하는 것&lt;/li&gt;
  &lt;li&gt;파싱(parsing) : 문장 혹은 문서를 구성 성분으로 분해하고 위계관계를 분석하여 문장의 구조를 결정하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;os 모듈 - 시스템 명령어를 실행시킬 수 있는 모듈&lt;/p&gt;

&lt;h3 id=&quot;파이썬-크롤링에-사용되는-모듈&quot;&gt;파이썬 크롤링에 사용되는 모듈&lt;/h3&gt;

&lt;h3 id=&quot;1-requests&quot;&gt;1. requests&lt;/h3&gt;
&lt;p&gt;requests 모듈은 Apache License 2.0에 따라 배포 된 HTTP 파이썬 라이브러리&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$ pip install requests&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2-beautifulsoup4&quot;&gt;2. BeautifulSoup4&lt;/h3&gt;
&lt;p&gt;BeautifulSoup 모듈은 HTML과 XML을 파싱하는 데에 사용되는 파이썬 라이브러리&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$ pip install bs4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3-selenium&quot;&gt;3. selenium&lt;/h3&gt;
&lt;p&gt;selenium은 웹 애플리케이션 테스트를 위한 포터블 프레임워크&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$ pip install selenium&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사용할 브라우저의 드라이버를 설치
https://chromedriver.storage.googleapis.com/index.html?path=83.0.4103.14/&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;from selenium import webdriver
import time&lt;/p&gt;

  &lt;p&gt;driver = webdriver.Chrome(‘chromedriver’)
driver.get(“https://www.youtube.com/”)&lt;/p&gt;

  &lt;p&gt;time.sleep(3)&lt;/p&gt;

  &lt;p&gt;search = driver.find_element_by_xpath(‘//*[@id=”search”]’)&lt;/p&gt;

  &lt;p&gt;search.send_keys(‘검색’)
time.sleep(1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[1 to 50 게임 자동화]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;num = 1&lt;/p&gt;

  &lt;p&gt;def clickBtn():
    global num
    btns = driver.find_elements_by_xpath(‘//&lt;em&gt;[@id=”grid”]/div[&lt;/em&gt;]’)&lt;/p&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for btn in btns:
    print(btn.text, end='\t')
    if btn.text == str(num):
        btn.click()
        prunt(true)
        num += 1
        return
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;while num &amp;lt;= 50:
    clickBtn()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특수문자-치환&quot;&gt;특수문자 치환&lt;/h3&gt;
&lt;p&gt;re.sub(‘[^0-9a-zA-Zr-힗]’, ‘’, title)&lt;/p&gt;

&lt;h3 id=&quot;다운로드&quot;&gt;다운로드&lt;/h3&gt;
&lt;p&gt;urlretrive(img_src, title + ‘.jpg’)&lt;/p&gt;

</description>
        <pubDate>Sat, 01 Jan 2000 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2000/01/01/python_crawling.html</link>
        <guid isPermaLink="true">http://localhost:4000/2000/01/01/python_crawling.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>python</category>
        
        <category>crawling</category>
        
        
      </item>
    
  </channel>
</rss>
