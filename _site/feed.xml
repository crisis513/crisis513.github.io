<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>son</title>
    <description>son&apos;s blog, use Jekyll and github pages.</description>
    <link>http://192.168.116.128:4000/</link>
    <atom:link href="http://192.168.116.128:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 01 Nov 2022 06:17:11 +0900</pubDate>
    <lastBuildDate>Tue, 01 Nov 2022 06:17:11 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>[Infra] Kubernetes Canary 배포 전략 실습</title>
        <description>&lt;p&gt;본 포스팅에서는 Kubernetes의 여러 배포 전략 중 Canary에 대해 알아보고 실습해볼 것이다. 실습 진행은 &lt;a href=&quot;&amp;quot;https://github.com/ContainerSolutions/k8s-deployment-strategies&amp;quot;&quot;&gt;해당 깃허브 내용&lt;/a&gt;을 참고하였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. Canary 배포&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Canary란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Canary 실습&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. Grafana dashboard 확인&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-canary-배포-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. Canary 배포&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-canary란-&quot;&gt;1.1. Canary란? &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Canary 배포는 특정 서버나 소수의 유저들에게만 새로운 버전을 배포하여 테스트하면서 추후 안전하다는 판단이 되면 모든 서버들에 새로운 버전을 배포하는 방식이다. 배포 방식을 그림으로 살펴보자면 다음 [그림 1]과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/canary1.png&quot; alt=&quot;canary&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Canary 배포 과정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 기법은 Blue/Green 배포 방식과 유사하게 라벨을 이용하고, A/B 테스트 방식과 성능 모니터링에 유용하다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-canary-실습-&quot;&gt;1.2. Canary 실습 &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;실습은 이전 포스팅에서 진행했던 blue-green/single-service 폴더에서 canary/native 폴더로 이동하여 진행한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../../canary/native
  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;app-v1.yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: my-app
    labels:
      app: my-app
  spec:
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
    ports:
    - name: http
      port: 80
      targetPort: http
    selector:
      app: my-app
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: my-app-v1
    labels:
      app: my-app
  spec:
    replicas: 10
    selector:
      matchLabels:
        app: my-app
        version: v1.0.0
    template:
      metadata:
        labels:
          app: my-app
          version: v1.0.0
        annotations:
          prometheus.io/scrape: &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
          prometheus.io/port: &lt;span class=&quot;s2&quot;&gt;&quot;9101&quot;&lt;/span&gt;
      spec:
        containers:
        - name: my-app
          image: crisis513/strategies-test
          ports:
          - name: http
            containerPort: 8080
          - name: probe
            containerPort: 8086
          &lt;span class=&quot;nb&quot;&gt;env&lt;/span&gt;:
          - name: VERSION
            value: v1.0.0
          livenessProbe:
            httpGet:
              path: /live
              port: probe
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /ready
              port: probe
            periodSeconds: 5
  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;app-v2.yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: my-app-v2
    labels:
      app: my-app
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: my-app
        version: v2.0.0
    template:
      metadata:
        labels:
          app: my-app
          version: v2.0.0
        annotations:
          prometheus.io/scrape: &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
          prometheus.io/port: &lt;span class=&quot;s2&quot;&gt;&quot;9101&quot;&lt;/span&gt;
      spec:
        containers:
        - name: my-app
          image: crisis513/strategies-test
          ports:
          - name: http
            containerPort: 8080
          - name: probe
            containerPort: 8086
          &lt;span class=&quot;nb&quot;&gt;env&lt;/span&gt;:
          - name: VERSION
            value: v2.0.0
          livenessProbe:
            httpGet:
              path: /live
              port: probe
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /ready
              port: probe
            periodSeconds: 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;매니페스트를 살펴보면 Blue/Green과 크게 다를 것이 없다. 다른 점은 replicas의 갯수 차이이다. app-v1.yaml에서는 replicas가 10으로 설정되어 있고, app-v2.yaml에는 1로 설정되어 있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;먼저 app-v1.yaml을 배포해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v1.yaml
  service/my-app created
  deployment.apps/my-app-v1 created

  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get all
  NAME                            READY   STATUS    RESTARTS   AGE
  pod/my-app-v1-9b99b584b-5kc4w   1/1     Running   0          114s
  pod/my-app-v1-9b99b584b-5ksm4   1/1     Running   0          113s
  pod/my-app-v1-9b99b584b-8gdzk   1/1     Running   0          113s
  pod/my-app-v1-9b99b584b-bxlsx   1/1     Running   0          113s
  pod/my-app-v1-9b99b584b-fvmwf   1/1     Running   0          114s
  pod/my-app-v1-9b99b584b-ng5jn   1/1     Running   0          114s
  pod/my-app-v1-9b99b584b-qqm2f   1/1     Running   0          113s
  pod/my-app-v1-9b99b584b-sqhsf   1/1     Running   0          113s
  pod/my-app-v1-9b99b584b-wlz4n   1/1     Running   0          113s
  pod/my-app-v1-9b99b584b-xxkd5   1/1     Running   0          113s

  NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        AGE
  service/kubernetes   ClusterIP   10.96.0.1      &amp;lt;none&amp;gt;        443/TCP        15d
  service/my-app       NodePort    10.103.42.11   &amp;lt;none&amp;gt;        80:32631/TCP   117s

  NAME                        READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/my-app-v1   10/10   10           10          116s

  NAME                                  DESIRED   CURRENT   READY   AGE
  replicaset.apps/my-app-v1-9b99b584b   10        10        10      115s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서비스가 올라가고 pod 10개가 정상적으로 만들어졌다면 이전 포스팅의 배포 전략들과 마찬가지로 메트릭을 생성해내기 위해 해당 애플리케이션으로 지속적인 요청을 보내보도록 하겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sleep &lt;/span&gt;0.1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /dev/null &lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.49.2:32631&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마찬가지로 요청은 계속 보내도록 두고 약간의 시간이 지나고나서 새로운 터미널을 열어 app-v2.yaml을 배포할 것이다. 배포를 하고나면 my-app-v2 pod가 하나 생성되기 때문에 my-app-v1의 replicas를 하나 줄인 9개로 설정할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v2.yaml
  deployment.apps/my-app-v2 created
  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k scale &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;9 deploy my-app-v1
  deployment.apps/my-app-v1 scaled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기까지 진행됐다면 현재 9개의 my-app-v1 pod가 9개, my-app-v2 pod가 1개로 Running 중일 것이다. 즉, 전체 트래픽의 90%는 기존 버전의 애플리케이션으로, 나머지 10%는 새로운 버전의 애플리케이션으로 이동하게 될 것이다. curl을 통한 요청이 지속 되고 있으므로 이 상태로도 일정 시간 지나고나서 my-app-v2의 replicas를 10개로 늘리고 기존 버전인 my-app-v1을 모두 제거할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k scale &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10 deploy my-app-v2
  deployment.apps/my-app-v2 scaled
  son@son-localhost ~/k8s-deployment-strategies/canary/native &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k delete deploy my-app-v1
  deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;my-app-v1&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 영상은 app-v1.yaml 파일이 배포되어 있고 위의 app-v2.yaml을 배포하는 과정에서 pod가 어떻게 변화하는지를 살펴볼 수 있도록 촬영해보았다.&lt;/p&gt;

&lt;video width=&quot;100%&quot; preload=&quot;auto&quot; muted=&quot;&quot; controls=&quot;&quot;&gt;
      &lt;source src=&quot;/static/assets/video/blog/canary.mp4&quot; type=&quot;video/mp4&quot; /&gt;
  &lt;/video&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;13-grafana-dashboard-확인-&quot;&gt;1.3. Grafana dashboard 확인 &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Canary 배포를 통해 정상적으로 새로운 버전으로 배포 되었다면 마찬가지로 Grafana를 통해 Canary 배포 과정에 대한 지속적인 요청 메트릭을 확인해볼 것이다. 이전 포스팅에서 배포해 두었던 Grafana에 접속하기 위해 localhost:3000으로 접근하여 만들어 둔 패널을 &lt;strong&gt;refresh&lt;/strong&gt;해보자. 다음 [그림 2]와 같은 화면을 볼 수 있을 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/canary2.png&quot; alt=&quot;request_total_panel&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Request Total 패널 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;my-app-v2가 배포되었을 때는 약 10%의 메트릭이 점진적으로 발생한 것을 볼 수 있고, 그 후에 my-app-v2의 replicas를 10으로 올리고, my-app-v1을 삭제하고나서부터는 점진적으로 my-app-v2로 교체되는 것을 확인할 수 있다. Blue/Green과 매니페스트는 유사하지만 이렇게 가능한 이유는 위의 두 버전의 deployment는 동일한 app selector를 가지기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기까지 Kubernetes에서 무중단 배포 전략들의 구현 방법과 Grafana를 통한 배포 과정에 대한 메트릭을 확인해보는 시간을 가져보았다. 우리가 운영하는 서비스의 특징 혹은 배포할 때 필요한 요구사항들을 잘 고려하여 어떤 전략으로 배포할지 잘 결정해야할 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Oct 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/infra/2022/10/24/canary.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/infra/2022/10/24/canary.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>minikube</category>
        
        <category>kubernetes</category>
        
        <category>grafana</category>
        
        <category>canary</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Infra] Kubernetes Blue/Green 배포 전략 실습</title>
        <description>&lt;p&gt;본 포스팅에서는 Kubernetes의 여러 배포 전략 중 Blue/Green에 대해 알아보고 실습해볼 것이다. 실습 진행은 &lt;a href=&quot;&amp;quot;https://github.com/ContainerSolutions/k8s-deployment-strategies&amp;quot;&quot;&gt;해당 깃허브 내용&lt;/a&gt;을 참고하였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. Blue/Green 배포&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Blue/Green이란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Blue/Green 실습&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. Grafana dashboard 확인&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-bluegreen-배포-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. Blue/Green 배포&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-bluegreen이란-&quot;&gt;1.1. Blue/Green이란? &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;이전 포스팅에서 살펴본 Rolling Update는 기존 버전과 새로운 버전이 같이 배포되는 시간이 어느정도 있다는 문제가 있다. 이러한 문제를 해결하기 위해 사용되는 방법이 Blue/Green 배포이다. Blue/Green 배포는 서버를 기존 버전과 새로운 버전을 동시에 배포하여 한꺼번에 교체하는 방법이다. 그림으로 살펴보자면 다음 [그림 1]과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/bluegreen1.png&quot; alt=&quot;blue_green&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Blue/Green 배포 과정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;새로운 버전이 요구 사항을 충족하는지 테스트한 후 selector 필드의 version 레이블을 교체하여 새로운 버전으로 트래픽을 보내도록 업데이트하는 방식이다. 즉각적인 롤아웃/롤백이 가능하고 버전 관리 문제를 피하고 전체 클러스터 상태를 한 번에 변경할 수 있는 장점이 있지만, 두 버전이 동시에 올라가야 하기 때문에 두 배의 자원이 필요하고, 프로덕션에 출시하기 전에 전체 플랫폼에 대한 적절한 테스트를 수행하는 과정이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-bluegreen-실습-&quot;&gt;1.2. Blue/Green 실습 &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;실습은 이전 포스팅의 Rolling Update를 진행했던 ramped 폴더에서 blue-green/single-service 폴더로 이동하여 진행한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../blue-green/single-service
  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
  &lt;/span&gt;app-v1.yaml  app-v2.yaml  README.md
  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;app-v1.yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: my-app
    labels:
      app: my-app
  spec:
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
    ports:
    - name: http
      port: 80
      targetPort: http
    selector:
      app: my-app
      version: v1.0.0
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: my-app-v1
    labels:
      app: my-app
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: my-app
        version: v1.0.0
    template:
      metadata:
        labels:
          app: my-app
          version: v1.0.0
        annotations:
          prometheus.io/scrape: &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
          prometheus.io/port: &lt;span class=&quot;s2&quot;&gt;&quot;9101&quot;&lt;/span&gt;
      spec:
        containers:
        - name: my-app
          image: crisis513/strategies-test
          ports:
          - name: http
            containerPort: 8080
          - name: probe
            containerPort: 8086
          &lt;span class=&quot;nb&quot;&gt;env&lt;/span&gt;:
          - name: VERSION
            value: v1.0.0
          livenessProbe:
            httpGet:
              path: /live
              port: probe
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /ready
              port: probe
            periodSeconds: 5
  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;app-v2.yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: my-app-v2
    labels:
      app: my-app
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: my-app
        version: v2.0.0
    template:
      metadata:
        labels:
          app: my-app
          version: v2.0.0
        annotations:
          prometheus.io/scrape: &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
          prometheus.io/port: &lt;span class=&quot;s2&quot;&gt;&quot;9101&quot;&lt;/span&gt;
      spec:
        containers:
        - name: my-app
          image: crisis513/strategies-test
          ports:
          - name: http
            containerPort: 8080
          - name: probe
            containerPort: 8086
          &lt;span class=&quot;nb&quot;&gt;env&lt;/span&gt;:
          - name: VERSION
            value: v2.0.0
          livenessProbe:
            httpGet:
              path: /live
              port: probe
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /ready
              port: probe
            periodSeconds: 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Blue/Green도 컨테이너 이미지 부분을 이전에 미리 컨테이너 이미지를 빌드 및 Docker Hub에 푸시했던 &lt;strong&gt;crisis513/strategies-test&lt;/strong&gt;로 바꾸었다. 매니페스트가 Rolling Update와 다른 점은 strategy 부분이 없고, selector &amp;gt; matchLabels &amp;gt; version이 추가된 점이다. 사실 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl patch service&lt;/code&gt; 명령어로 어떤 selector의 요소를 바라보게 할 것인지를 바꿔주면 되는 것이고, 본 포스팅에서는 selector &amp;gt; matchLabels &amp;gt; version 부분으로 컨트롤 하는 것 뿐이다.&lt;/p&gt;

&lt;p&gt;먼저 app-v1.yaml을 배포해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v1.yaml
  service/my-app created
  deployment.apps/my-app-v1 created
  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get all
  NAME                             READY   STATUS    RESTARTS   AGE
  pod/my-app-v1-69b978c757-9wtgt   1/1     Running   0          69s
  pod/my-app-v1-69b978c757-g2bfr   1/1     Running   0          69s
  pod/my-app-v1-69b978c757-kcwn7   1/1     Running   0          69s

  NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        AGE
  service/kubernetes   ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP        15d
  service/my-app       NodePort    10.104.28.204   &amp;lt;none&amp;gt;        80:32448/TCP   69s

  NAME                        READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/my-app-v1   3/3     3            3           69s

  NAME                                   DESIRED   CURRENT   READY   AGE
  replicaset.apps/my-app-v1-69b978c757   3         3         3       69s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서비스가 정상적으로 올라갔다면 Rolling Update 때와 마찬가지로 해당 애플리케이션으로 지속적인 요청을 보내보도록 하겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /dev/null &lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.49.2:32448&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요청은 계속 보내도록 그대로 두고 어느 정도 시간이 지나고나서 새로운 터미널을 열어 app-v2.yaml을 배포하겠다.&lt;/p&gt;

&lt;p&gt;새로운 터미널을 열어 다음 명령어를 통해 pod가 롤아웃 되는 과정을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;$ watch kubectl get po&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v2.yaml
  deployment.apps/my-app-v2 created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 그림은 app-v1.yaml과 app-v2.yaml을 함께 배포한 것을 확인해본 것으로, 함께 배포되어 있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/bluegreen2.png&quot; alt=&quot;watch_pod&quot; width=&quot;70%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] watch kubectl get po 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 kubectl patch service 명령으로 어느 버전의 애플리케이션을 가리키느냐에 따라 트래픽의 이동 방향이 정해지는 것이고, 새로운 버전의 애플리케이션을 가리킨 후에 이전 버전의 애플리케이션을 삭제해주면 Blue/Green 배포가 완료되는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k patch service my-app &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;{&quot;spec&quot;:{&quot;selector&quot;:{&quot;version&quot;:&quot;v2.0.0&quot;}}}&apos;&lt;/span&gt;
  service/my-app patched
  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k delete deploy my-app-v1
  deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;my-app-v1&quot;&lt;/span&gt; deleted

  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get pod
  NAME                             READY   STATUS    RESTARTS   AGE
  pod/my-app-v2-69b978c757-jf9dn   1/1     Running   0          10m
  pod/my-app-v2-69b978c757-2mdfj   1/1     Running   0          10m
  pod/my-app-v2-69b978c757-ms9dn   1/1     Running   0          10m

  son@son-localhost ~/k8s-deployment-strategies/blue-green/single-service &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k describe service/my-app
  Name:                     my-app
  Namespace:                default
  Labels:                   &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;my-app
  Annotations:              &amp;lt;none&amp;gt;
  Selector:                 &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;my-app,version&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v2.0.0
  Type:                     NodePort
  IP Family Policy:         SingleStack
  IP Families:              IPv4
  IP:                       10.109.224.206
  IPs:                      10.109.224.206
  Port:                     http  80/TCP
  TargetPort:               http/TCP
  NodePort:                 http  30427/TCP
  Endpoints:                172.17.0.10:8080,172.17.0.11:8080,172.17.0.7:8080
  Session Affinity:         None
  External Traffic Policy:  Cluster
  Events:                   &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;app-v2.yaml을 배포하고 kubectl patch service 명령어를 통해 새로 배포된 애플리케이션으로 트래픽을 보내도록 설정한 후에 기존 버전의 애플리케이션을 삭제해 주었다. v2에 해당하는 pod들이 Running되고 있는 것을 확인할 수 있고, 서비스 정보를 살펴보니 Selector의 version도 2.0.0으로 바뀐 것을 확인할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;반대로 롤백하고 싶다면 다음 명령어를 사용하면 된다.&lt;/p&gt;

  &lt;p&gt;$ kubectl patch service my-app -p ‘{“spec”:{“selector”:{“version”:”v1.0.0”}}}’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;13-grafana-dashboard-확인-&quot;&gt;1.3. Grafana dashboard 확인 &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;새로운 버전으로의 배포가 정상적으로 완료되었다면 Grafana를 통해 Blue/Green 배포 과정에 대한 지속적인 요청 메트릭을 확인하겠다. 마찬가지로 이전 포스팅에서 배포해 두었던 Grafana에 접속하기 위해 localhost:3000으로 접근하여 만들어 둔 패널을 &lt;strong&gt;refresh&lt;/strong&gt;해보자. 다음 [그림 3]과 같은 화면을 볼 수 있을 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/bluegreen3.png&quot; alt=&quot;request_total_panel&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Request Total 패널 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;시각화된 데이터를 보면 기존 버전에서 새로운 버전으로 한 번에 교체하기 때문에 점진적으로 롤아웃하던 Rolling Update 때와는 다르게 단번에 롤아웃 되는 것을 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Oct 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/infra/2022/10/23/blue-green.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/infra/2022/10/23/blue-green.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>minikube</category>
        
        <category>kubernetes</category>
        
        <category>grafana</category>
        
        <category>blue/green</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Infra] Kubernetes Rolling Update 배포 전략 실습</title>
        <description>&lt;p&gt;본 포스팅에서는 Kubernetes의 여러 배포 전략 중 Rolloing Update에 대해 알아보고 실습해볼 것이다. 실습 진행은 &lt;a href=&quot;&amp;quot;https://github.com/ContainerSolutions/k8s-deployment-strategies&amp;quot;&quot;&gt;해당 깃허브 내용&lt;/a&gt;을 참고하였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 무중단 배포 전략&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. Rolling Update 배포&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. Rolling Update란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;list2_2&quot;&gt;   2.2. Rolling Update 실습&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. Grafana dashboard 확인&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-무중단-배포-전략-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 무중단 배포 전략&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;무중단 배포는 실제로 &lt;strong&gt;서버를 운영할 때 서비스가 중단되지 않고, 서비스적인 장애를 최소화시킬 수 있도록 배포&lt;/strong&gt;하는 것을 의미한다. 얼마 전 2022년 10월 15일에 C&amp;amp;C 데이터센터에 화재가 발생하여 역대 최악의 서비스 중단 사태를 맞았었다. 10시간이 지나서야 일부 기능이 복구되기 시작되었고 공식적으로는 127시간 30분만에 모든 서비스가 정상화 되었다고 알려져있는데, 이번 사태로 유료서비스 사용자에 대한 보상액과 서비스 중단에 대한 매출액 피해 등을 합하면 수백 수천억의 손실을 입었을 것이다. 서비스의 규모가 클 수록 정상적으로 서비스를 운영할 수 있는 인프라 및 환경을 갖추는 것이 매우 중요하다. 데이터센터가 이원화가 재대로 되지 않아 발생한 문제여서 이번 포스팅에서 다룰 쿠버네티스 무중단 배포 전략과는 약간 다른 문제이긴 하지만 그만큼 서비스가 중단되지 않고 정상 서비스하는 것이 매우 중요하다는 것을 강조하고 싶었다.&lt;/p&gt;

&lt;p&gt;쿠버네티스 서비스 환경에서 새로운 버전으로 롤아웃 하면서 스테이지에서 없던 문제가 운영에서 생겨나면서 서비스가 중단되는 상황도 있기 때문에 일관된 환경을 제공하는 것도 중요한 이슈이다. 다시 돌아와서, 쿠버네티스에서 기본적으로 제공하는 Rolling Update와 Blue/Green, Canary 등 새로운 버전으로 롤아웃하기 위한 여러 가지 무중단 배포 전략이 존재한다. 본 포스팅에서는 대표적인 3가지 방법 중 Rolling Update에 대해 알아보고 실습해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-rolling-update-배포-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. Rolling Update 배포&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-rolling-update란-&quot;&gt;2.1. Rolling Update란? &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Rolling Update란 새로운 버전을 배포하면서 새로운 버전의 인스턴스를 하나씩 올리고 기존 버전의 인스턴스를 하나씩 줄여나가는 방식이다. 이런 방식으로 배포하면 서비스가 중단되지 않으며 배포할 수 있다는 장점이 있지만, 새로운 버전의 인스턴스로 트래픽이 이전되기 전까지 이전 버전과 새로운 버전의 인스턴스가 동시에 존재할 수 있다는 단점이 있다. 배포하는 기간 동안 어떤 사용자는 이전 버전을 사용하게 되고, 또다른 사용자는 새로운 버전을 사용할 수도 있다는 것이다. 그림으로 표현하자면 다음 [그림 1]과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/rollingupdate1.png&quot; alt=&quot;rolling_update&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Rolling Update 배포 과정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그림의 예시에서는 Deployment가 replicas를 3으로 설정하여 3개의 pod가 배포되었다고 가정한다. 우측의 Running, Terminating, Container Creating는 Pod의 Status를 어떠한 과정으로 변화하는지를 의미하며, X는 pod가 존재하지 않는다는 의미이다. 설명을 보태자면, &lt;strong&gt;기존 버전의 pod 집합에서 pod를 하나씩 제거하고 새로운 버전의 pod를 하나씩 추가하는 과정이 반복&lt;/strong&gt;되는 것이다. 위에서도 언급하였듯 Deployment의 배포 전략에 아무런 설정하지 않으면 기본적으로 Rolling Update로 설정된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-rolling-update-실습-&quot;&gt;2.2. Rolling Update 실습 &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;먼저 Rolling Update 실습에 필요한 자료를 다운받아 오겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/ContainerSolutions/k8s-deployment-strategies.git
  Cloning into &lt;span class=&quot;s1&quot;&gt;&apos;k8s-deployment-strategies&apos;&lt;/span&gt;...
  remote: Enumerating objects: 452, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  remote: Counting objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;20/20&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  remote: Compressing objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;20/20&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  remote: Total 452 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;delta 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, reused 8 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;delta 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, pack-reused 432
  Receiving objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;452/452&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 3.70 MiB | 923.00 KiB/s, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  Resolving deltas: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;236/236&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;k8s-deployment-strategies/
  son@son-localhost ~/k8s-deployment-strategies &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
  &lt;/span&gt;ab-testing  app  blue-green  canary  decision-diagram.png  grafana-dashboard.json  ramped  README.md  recreate  shadow
  son@son-localhost ~/k8s-deployment-strategies &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;app/
  son@son-localhost ~/k8s-deployment-strategies/app &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
  &lt;/span&gt;Dockerfile  Gopkg.lock  Gopkg.toml  main.go  Makefile  README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 깃 폴더를 살펴보면 recreate, ramped, blue/green, canary, a/b testing 배포 전략을 실습해볼 수 있도록 폴더가 나뉘어져있고, app에는 배포 테스트를 진행하면서 애플리케이션 버전을 확인해볼 수 있도록 GO 언어로 간단하게 구현되어 있다. 그리고 Dockerfile을 통해 컨테이너 이미지로 만들 수 있기 때문에 빌드하여 Docker Hub에서 새로운 레포지토리를 만든 후에 해당 레포지토리로 푸시해볼 것이다. Docker Hub에서 리포지토리명은 다음 [그림 2]와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strategies-test&lt;/code&gt;로 만들었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/rollingupdate2.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Grafana 접속 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/app &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; crisis513/strategies-test &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  Sending build context to Docker daemon  15.36kB
  Step 1/9 : FROM golang:1.9-alpine AS build
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; b0260be938c6
  Step 2/9 : RUN apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; add git &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;   go get &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; github.com/golang/dep/cmd/dep
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;fbf1fd7871e4
  fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/main/x86_64/APKINDEX.tar.gz
  fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/community/x86_64/APKINDEX.tar.gz
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1/6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Installing nghttp2-libs &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1.39.2-r0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2/6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Installing libssh2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1.9.0-r1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3/6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Installing libcurl &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;7.61.1-r3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4/6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Installing expat &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2.2.8-r0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5/6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Installing pcre2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;10.31-r0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;6/6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Installing git &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2.18.4-r0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  Executing busybox-1.28.4-r0.trigger
  OK: 19 MiB &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;20 packages
  Removing intermediate container fbf1fd7871e4
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; af88bec1e59a
  Step 3/9 : COPY &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$GOPATH&lt;/span&gt;/src/app
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; ea2deb243f50
  Step 4/9 : WORKDIR &lt;span class=&quot;nv&quot;&gt;$GOPATH&lt;/span&gt;/src/app
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;3e98a321c375
  Removing intermediate container 3e98a321c375
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 32abad570106
  Step 5/9 : RUN dep ensure &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;nv&quot;&gt;GOOS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux go build &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-installsuffix&lt;/span&gt; cgo &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; app &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;bd96701a0b9c
  Removing intermediate container bd96701a0b9c
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; e6584e1d6bd4
  Step 6/9 : FROM scratch
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  Step 7/9 : COPY &lt;span class=&quot;nt&quot;&gt;--from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;build /go/src/app/app /app
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Using cache
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; a12284a9dd08
  Step 8/9 : EXPOSE 8080 8086 9101
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Using cache
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 5a912ba846b7
  Step 9/9 : CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/app&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Using cache
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 9bdd1b95aae3
  Successfully built 9bdd1b95aae3
  Successfully tagged crisis513/strategies-test:latest

  son@son-localhost ~/k8s-deployment-strategies/app &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker login
  Authenticating with existing credentials...
  WARNING! Your password will be stored unencrypted &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/son/.docker/config.json.
  Configure a credential helper to remove this warning. See
  https://docs.docker.com/engine/reference/commandline/login/#credentials-store

  Login Succeeded

  son@son-localhost ~/k8s-deployment-strategies/app &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker push crisis513/strategies-test
  Using default tag: latest
  The push refers to repository &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;docker.io/crisis513/strategies-test]
  a6412e70ba42: Pushed
  latest: digest: sha256:9f281584fa169d7a045d0fa17f3125871783b0dc5340eb0abe22ebc8f54c1c85 size: 528
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;푸시가 정상적으로 되었다면 예제 애플리케이션 코드와 컨테이너 이미지로 만들 Dockerfile, 컨테이너 이미지를 저장할 Docker Hub 레포지토리까지 생기게 되고, 코드를 수정하여 새롭게 배포할 수 있는 모든 환경이 만들어 진 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 Prometheus와 Grafana를 배포해야 하는데, 이전 포스팅에서 Istio를 설치하여 addons를 배포하는 과정에서 Prometheus와 Grafana가 이미 Running 상태이다. 따라서 필자는 Grafana에 접속할 수 있도록 포트포워딩만 해줄 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;혹시나 블로그 내용을 따라오고 있지 않아 Istio가 구성되어 있지 않다면 &lt;a href=&quot;&amp;quot;https://github.com/ContainerSolutions/k8s-deployment-strategies#readme&amp;quot;&quot;&gt;해당 readme&lt;/a&gt;를 참고하여 Prometheus와 Grafana 환경을 구성하면 될 것 같다.&lt;/p&gt;

  &lt;p&gt;그리고 Grafana에 접속할 때마다 포트포워딩을 해주기 귀찮다면 NodePort를 올려도 상관 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/app &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system
  NAME                                        READY   STATUS    RESTARTS   AGE
  pod/grafana-56bdf8bf85-ff924                1/1     Running   0          3d
  pod/istio-egressgateway-fffc799cf-fw5cv     1/1     Running   0          3d
  pod/istio-ingressgateway-7d68764b55-8sq9l   1/1     Running   0          3d
  pod/istiod-5456fd558d-dpkvc                 1/1     Running   0          3d
  pod/jaeger-c4fdf6674-56w7h                  1/1     Running   0          3d
  pod/kiali-5ff49b9f69-c9fxt                  1/1     Running   0          3d
  pod/prometheus-85949fddb-csxkd              2/2     Running   0          3d

  NAME                           TYPE           CLUSTER-IP       EXTERNAL-IP      PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                                                                      AGE
  service/grafana                ClusterIP      10.96.226.7      &amp;lt;none&amp;gt;           3000/TCP                                                                     3d
  service/istio-egressgateway    ClusterIP      10.110.60.52     &amp;lt;none&amp;gt;           80/TCP,443/TCP                                                               3d
  service/istio-ingressgateway   LoadBalancer   10.111.160.6     192.168.49.100   15021:32528/TCP,80:30521/TCP,443:32312/TCP,31400:32156/TCP,15443:31761/TCP   3d
  service/istiod                 ClusterIP      10.102.30.48     &amp;lt;none&amp;gt;           15010/TCP,15012/TCP,443/TCP,15014/TCP                                        3d
  service/jaeger-collector       ClusterIP      10.102.207.195   &amp;lt;none&amp;gt;           14268/TCP,14250/TCP,9411/TCP                                                 3d
  service/kiali                  ClusterIP      10.109.43.201    &amp;lt;none&amp;gt;           20001/TCP,9090/TCP                                                           3d
  service/prometheus             ClusterIP      10.96.52.254     &amp;lt;none&amp;gt;           9090/TCP                                                                     3d
  service/tracing                ClusterIP      10.105.237.18    &amp;lt;none&amp;gt;           80/TCP,16685/TCP                                                             3d
  service/zipkin                 ClusterIP      10.96.209.177    &amp;lt;none&amp;gt;           9411/TCP                                                                     3d

  NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/grafana                1/1     1            1           3d
  deployment.apps/istio-egressgateway    1/1     1            1           3d
  deployment.apps/istio-ingressgateway   1/1     1            1           3d
  deployment.apps/istiod                 1/1     1            1           3d
  deployment.apps/jaeger                 1/1     1            1           3d
  deployment.apps/kiali                  1/1     1            1           3d
  deployment.apps/prometheus             1/1     1            1           3d

  NAME                                              DESIRED   CURRENT   READY   AGE
  replicaset.apps/grafana-56bdf8bf85                1         1         1       3d
  replicaset.apps/istio-egressgateway-fffc799cf     1         1         1       3d
  replicaset.apps/istio-ingressgateway-7d68764b55   1         1         1       3d
  replicaset.apps/istiod-5456fd558d                 1         1         1       3d
  replicaset.apps/jaeger-c4fdf6674                  1         1         1       3d
  replicaset.apps/kiali-5ff49b9f69                  1         1         1       3d
  replicaset.apps/prometheus-85949fddb              1         1         1       3d

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system port-forward &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system get pod &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;grafana &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;{.items[0].metadata.name}&apos;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; 3000:3000 &amp;amp;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 15635
  Forwarding from 127.0.0.1:3000 -&amp;gt; 3000
  Forwarding from &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;::1]:3000 -&amp;gt; 3000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;app 폴더의 main.go 코드를 살펴보면 HTTP Request가 올 때마다 /metrics 경로와 9101포트를 통해 Prometheus 서버에서 매트릭을 수집하도록 작성되어 있는 것을 확인할 수 있다. 혹시나 매트릭이 정상적으로 수집되지 않아 Grafana에서 재대로 보이지 않는다면 Prometheus가 정상적으로 배포되어 있는지, health check 했을 때 서비스가 잘 동작하고 있는지, 포트 번호가 다르진 않는지, 로그에서 에러가 확인되는지 등을 확인해보면 될 것 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;k는 별칭을 설정하여 kubectl을 의미한다.&lt;/p&gt;

  &lt;p&gt;$ alias k=”kubectl”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Grafana 포트포워딩을 하고 &lt;strong&gt;localhost:3000&lt;/strong&gt;으로 접속했을 때 정상적으로 접속되면 다음 [그림 2]와 같은 화면을 볼 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/rollingupdate3.png&quot; alt=&quot;grafana_home&quot; width=&quot;80%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Grafana 접속 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Grafana에 정상적으로 접근이 된다면 준비가 다 되었다. 다음으로 Rolling Update 실습을 진행해보자. Rolling Update 실습에 사용되는 매니페스트는 ramped 폴더에 있다. ramped 폴더 안에 있는 app-v1.yaml 파일과 app-v2.yaml의 내용을 비교해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/app &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../ramped/
  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;app-v1.yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: my-app
    labels:
      app: my-app
  spec:
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
    ports:
    - name: http
      port: 80
      targetPort: http
    selector:
      app: my-app
  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: my-app
    labels:
      app: my-app
  spec:
    replicas: 10
    selector:
      matchLabels:
        app: my-app
    template:
      metadata:
        labels:
          app: my-app
          version: v1.0.0
        annotations:
          prometheus.io/scrape: &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
          prometheus.io/port: &lt;span class=&quot;s2&quot;&gt;&quot;9101&quot;&lt;/span&gt;
      spec:
        containers:
        - name: my-app
          image: crisis513/strategies-test
          ports:
          - name: http
            containerPort: 8080
          - name: probe
            containerPort: 8086
          &lt;span class=&quot;nb&quot;&gt;env&lt;/span&gt;:
          - name: VERSION
            value: v1.0.0
          livenessProbe:
            httpGet:
              path: /live
              port: probe
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /ready
              port: probe
            periodSeconds: 5
  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;app-v2.yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: my-app
    labels:
      app: my-app
  spec:
    replicas: 10
    strategy:
      &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: RollingUpdate
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 0
    selector:
      matchLabels:
        app: my-app
    template:
      metadata:
        labels:
          app: my-app
          version: v2.0.0
        annotations:
          prometheus.io/scrape: &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
          prometheus.io/port: &lt;span class=&quot;s2&quot;&gt;&quot;9101&quot;&lt;/span&gt;
      spec:
        containers:
        - name: my-app
          image: crisis513/strategies-test
          ports:
          - name: http
            containerPort: 8080
          - name: probe
            containerPort: 8086
          &lt;span class=&quot;nb&quot;&gt;env&lt;/span&gt;:
          - name: VERSION
            value: v2.0.0
          livenessProbe:
            httpGet:
              path: /live
              port: probe
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /ready
              port: probe
            initialDelaySeconds: 15
            periodSeconds: 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선, 컨테이너 이미지 부분을 위에서 빌드 및 푸시해서 Docker Hub에 저장한 &lt;strong&gt;crisis513/strategies-test&lt;/strong&gt;로 바꾸었다. app-v1.yaml 파일과 다르게 app-v2.yaml에서는 버전을 의미하는 부분들이 v1.0.0에서 v2.0.0으로 버전업 되었고, spec &amp;gt; strategy 부분이 추가된 것을 확인할 수 있다. type을 RollingUpdate로 설정하고 maxSurge, maxUnavailable 두 파라미터를 설정해야 한다. &lt;strong&gt;maxSurge는 의도한 pod 수에 대해 생성할 수 있는 최대 pod 수를 지정할 수 있고, maxUnavailable는 Rolling Update 중에 사용할 수 없는 최대 파드의 수를 지정할 수 있다.&lt;/strong&gt; [그림 1]에서는 pod 집합을 하나씩 제거한다고 설명했지만 실제로는 maxUnavailable에서 설정된 값만큼 기존 버전의 pod들을 제거하고 새로운 버전의 pod들을 생성하게 된다. maxSurge, maxUnavailable 두 파라미터의 값은 직접적인 &lt;strong&gt;수치(ex: 1)&lt;/strong&gt;를 지정하거나 &lt;strong&gt;비율(ex: 10%)&lt;/strong&gt;로도 지정이 가능하다.&lt;/p&gt;

&lt;p&gt;app-v1.yaml부터 배포하여 서비스와 디플로이먼트, 파드들이 정상적으로 동작하는지 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v1.yaml
  service/my-app created
  deployment.apps/my-app created
  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get all
  NAME                         READY   STATUS    RESTARTS   AGE
  pod/my-app-9b99b584b-7m8mw   1/1     Running   0          46s
  pod/my-app-9b99b584b-b9q6d   1/1     Running   0          46s
  pod/my-app-9b99b584b-gjd2p   1/1     Running   0          46s
  pod/my-app-9b99b584b-hzqcf   1/1     Running   0          46s
  pod/my-app-9b99b584b-jbjq8   1/1     Running   0          46s
  pod/my-app-9b99b584b-pldbh   1/1     Running   0          46s
  pod/my-app-9b99b584b-s8ts9   1/1     Running   0          46s
  pod/my-app-9b99b584b-sdn9q   1/1     Running   0          46s
  pod/my-app-9b99b584b-smg9k   1/1     Running   0          46s
  pod/my-app-9b99b584b-zkf7s   1/1     Running   0          46s

  NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        AGE
  service/kubernetes   ClusterIP   10.96.0.1        &amp;lt;none&amp;gt;        443/TCP        15d
  service/my-app       NodePort    10.103.204.108   &amp;lt;none&amp;gt;        80:30738/TCP   46s

  NAME                     READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/my-app   10/10   10           10          46s

  NAME                               DESIRED   CURRENT   READY   AGE
  replicaset.apps/my-app-9b99b584b   10        10        10      46s

  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl http://192.168.49.2:30738
  Host: my-app-744d48b664-d5qqn, Version: v1.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 배포되어 curl 요청에 대해 1.0.0 버전을 사용하고 있다는 애플리케이션 응답을 확인할 수 있다. curl을 통해 request를 보낼 때 192.168.49.2는 필자가 구성한 Kubernetes 클러스터 노드의 IP이다. 이 주소는 환경에 따라 달라질 수 있으니 상황에 맞게 수정하면 된다. 30738 포트번호는 app-v1.yaml에서 NodePort를 생성하면서 임의로 설정된 포트번호이다. 서비스를 지웠다가 다시 생성하면 해당 포트번호는 달라질 것이니 참고 바란다.&lt;/p&gt;

&lt;p&gt;그리고 다음과 같이 &lt;strong&gt;while 명령어를 통해 Ctrl + C를 누르기 전까지 계속해서 해당 서비스로 요청을 보낼 것&lt;/strong&gt;이다. 그래야 지속적인 요청에 대한 메트릭이 쌓이게 되고, v2.0.0으로 바뀌는 과정의 메트릭을 볼 수 있게 된다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /dev/null &lt;span class=&quot;s2&quot;&gt;&quot;http://192.168.49.2:30738&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;필자는 약 6분정도 요청을 계속 보내도록 두었고, 그동안 Grafana에서 메트릭이 수집된 내용을 시각화하여 볼 수 있도록 대시보드를 추가하였다. k8s-deployment-strategies 폴더 내의 grafana-dashboard.json 파일에서 대시보드를 어떻게 만들었는지에 대한 설정 내용이 들어있어 쉽게 시각화 시킬 수 있다. &lt;strong&gt;New Dashboard&lt;/strong&gt;를 통해 대시보드를 생성하고, 우측 상단의 톱니바퀴 모양의 아이콘을 눌러 설정 창에 들어가면 다음 [그림 4]와 같이 좌측의 &lt;strong&gt;JSON Model&lt;/strong&gt; 탭을 눌러 대시보드 설정을 json 형태로 관리할 수 있는 창이 나오게 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/rollingupdate4.png&quot; alt=&quot;dashboard_settings&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Grafana dashboard 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;대시보드 명은 예시와 같이 &lt;strong&gt;k8s-deployment-strategies dashboard&lt;/strong&gt;로 하였고, panel 부분만 grafana-dashboard.json 파일의 30~130라인에 해당하는 panel부분으로 대체하여 저장하였다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다시 터미널로 돌아와 curl 요청 중인 터미널 말고 새로운 터미널을 열어 app-v2.yaml 파일을 배포하고나서 배포했던 app-v1.yaml을 제거해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v2.yaml
  deployment.apps/my-app configured

  son@son-localhost ~/k8s-deployment-strategies/ramped &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; app-v1.yaml
  service &lt;span class=&quot;s2&quot;&gt;&quot;my-app&quot;&lt;/span&gt; deleted
  deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;my-app&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일정 시간이 지나면 기존에 배포했던 v1.0.0 애플리케이션이 모두 제거되고 v2.0.0에 해당하는 새로운 애플리케이션으로 버전업 되어 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-grafana-dashboard-확인-&quot;&gt;2.3. Grafana dashboard 확인 &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;현재 Rolling Update를 통해 새로운 버전으로 버전업시키는 과정을 curl을 통해 계속해서 요청을 보내는 메트릭을 수집하고 있는 상황&lt;/strong&gt;이고, 일정 시간이 지난 후에 위에서 만들어둔 Grafana 패널을 확인해보면 [그림 5]와 같이 보일 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/rollingupdate5.png&quot; alt=&quot;request_total_panel1&quot; width=&quot;80%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Request Total 패널 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;pod 인스턴스를 차례로 교체하여 애플리케이션 버전을 천천히 롤아웃하는 과정을 수집된 메트릭을 통해 확인할 수 있다. 패널을 누르고 &lt;strong&gt;e&lt;/strong&gt;키를 누르면 edit 화면으로 넘어갈 수 있는데 [그림 6]과 같이 &lt;strong&gt;Full Opacity 옵션을 100&lt;/strong&gt;으로 설정하여 바 안쪽의 색을 채울 수 있고, &lt;strong&gt;Stack series 옵션을 100%&lt;/strong&gt;로 설정하면 모든 series 합이 100%가 되도록 백분율로 표현할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/rollingupdate6.png&quot; alt=&quot;request_total_panel2&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] Request Total 패널 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;시각화된 데이터를 보면 기존 버전이 사라지고 새로운 버전이 올라오는 과정이 점진적으로 롤아웃 되는 것을 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Oct 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/infra/2022/10/22/rolling-update.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/infra/2022/10/22/rolling-update.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>minikube</category>
        
        <category>kubernetes</category>
        
        <category>grafana</category>
        
        <category>rolling update</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Infra] Minikube에서 Istio 사용기</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://crisis513.github.io/infra/2021/10/13/install.istio.html&amp;quot;이전 포스팅&amp;quot;&quot;&gt;이전 포스팅&lt;/a&gt;과 이어지는 내용으로, &lt;a href=&quot;http://crisis513.github.io/infra/2021/10/13/install_minikube.html#list1_2&quot; title=&quot;개발 환경&quot;&gt;개발 환경&lt;/a&gt;은 해당 포스팅을 참고 바란다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. Istio 사용기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. addons 배포&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. helloworld 예제 앱 배포&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. Kiali dashboard 사용&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-istio-사용기-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. Istio 사용기&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-addons-배포-&quot;&gt;1.1. addons 배포 &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;이전 포스팅과 같이 정상적으로 istio 설치되었다면 이번 포스팅에서는 istio 폴더에서 샘플로 제공되는 addons에 존재하는 모든 매니페스트를 쿠버네티스에 배포해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls &lt;/span&gt;istio-1.15.2/samples/addons
  extras  grafana.yaml  jaeger.yaml  kiali.yaml  prometheus.yaml  README.md
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; istio-1.15.2/samples/addons
  serviceaccount/grafana created
  configmap/grafana created
  service/grafana created
  deployment.apps/grafana created
  configmap/istio-grafana-dashboards created
  configmap/istio-services-grafana-dashboards created
  deployment.apps/jaeger created
  service/tracing created
  service/zipkin created
  service/jaeger-collector created
  serviceaccount/kiali created
  configmap/kiali created
  clusterrole.rbac.authorization.k8s.io/kiali-viewer created
  clusterrole.rbac.authorization.k8s.io/kiali created
  clusterrolebinding.rbac.authorization.k8s.io/kiali created
  role.rbac.authorization.k8s.io/kiali-controlplane created
  rolebinding.rbac.authorization.k8s.io/kiali-controlplane created
  service/kiali created
  deployment.apps/kiali created
  serviceaccount/prometheus created
  configmap/prometheus created
  clusterrole.rbac.authorization.k8s.io/prometheus created
  clusterrolebinding.rbac.authorization.k8s.io/prometheus created
  service/prometheus created
  deployment.apps/prometheus created

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system
  NAME                                        READY   STATUS    RESTARTS   AGE
  pod/grafana-56bdf8bf85-2ccqf                1/1     Running   0          2m58s
  pod/istio-egressgateway-fffc799cf-kd26t     1/1     Running   0          9m35s
  pod/istio-ingressgateway-7d68764b55-ckkc5   1/1     Running   0          9m35s
  pod/istiod-5456fd558d-x6jpf                 1/1     Running   0          10m
  pod/jaeger-c4fdf6674-gz6fg                  1/1     Running   0          2m58s
  pod/kiali-5ff49b9f69-tlbrj                  1/1     Running   0          2m58s
  pod/prometheus-85949fddb-gwqkl              2/2     Running   0          2m57s

  NAME                           TYPE           CLUSTER-IP       EXTERNAL-IP     PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                                                                      AGE
  service/grafana                ClusterIP      10.104.101.157   &amp;lt;none&amp;gt;          3000/TCP                                                                     2m58s
  service/istio-egressgateway    ClusterIP      10.105.237.74    &amp;lt;none&amp;gt;          80/TCP,443/TCP                                                               18m
  service/istio-ingressgateway   LoadBalancer   10.97.166.77     192.168.49.100  15021:32414/TCP,80:30295/TCP,443:30180/TCP,31400:30731/TCP,15443:30050/TCP   18m
  service/istiod                 ClusterIP      10.109.182.176   &amp;lt;none&amp;gt;          15010/TCP,15012/TCP,443/TCP,15014/TCP                                        18m
  service/jaeger-collector       ClusterIP      10.104.197.76    &amp;lt;none&amp;gt;          14268/TCP,14250/TCP,9411/TCP                                                 2m58s
  service/kiali                  ClusterIP      10.109.226.241   &amp;lt;none&amp;gt;          20001/TCP,9090/TCP                                                           2m58s
  service/prometheus             ClusterIP      10.100.195.182   &amp;lt;none&amp;gt;          9090/TCP                                                                     2m58s
  service/tracing                ClusterIP      10.100.65.84     &amp;lt;none&amp;gt;          80/TCP,16685/TCP                                                             2m58s
  service/zipkin                 ClusterIP      10.108.103.68    &amp;lt;none&amp;gt;          9411/TCP                                                                     2m58s

  NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/grafana                1/1     1            1           2m58s
  deployment.apps/istio-egressgateway    1/1     1            1           18m
  deployment.apps/istio-ingressgateway   1/1     1            1           18m
  deployment.apps/istiod                 1/1     1            1           18m
  deployment.apps/jaeger                 1/1     1            1           2m58s
  deployment.apps/kiali                  1/1     1            1           2m58s
  deployment.apps/prometheus             1/1     1            1           2m57s

  NAME                                              DESIRED   CURRENT   READY   AGE
  replicaset.apps/grafana-56bdf8bf85                1         1         1       2m58s
  replicaset.apps/istio-egressgateway-fffc799cf     1         1         1       9m35s
  replicaset.apps/istio-ingressgateway-7d68764b55   1         1         1       9m35s
  replicaset.apps/istiod-5456fd558d                 1         1         1       10m
  replicaset.apps/jaeger-c4fdf6674                  1         1         1       2m58s
  replicaset.apps/kiali-5ff49b9f69                  1         1         1       2m58s
  replicaset.apps/prometheus-85949fddb              1         1         1       2m57s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;istio 디렉토리에서 samples/addons 경로에는 istio와 통합되는 다양한 addon의 샘플이 포함되어 있다. istio의 일부가 아닌 서드파티 형태의 툴이지만 istio의 기능을 최대한 활용할 수 있기 때문에 필수로 사용되고 있다.&lt;/p&gt;

&lt;p&gt;각각의 툴에 대해 간단하게 정리하자면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Prometheus&lt;/p&gt;

    &lt;p&gt;오픈 소스 모니터링 시스템 및 시계열 데이터베이스로, istio와 함께 Prometheus를 사용하여 서비스 메시 내에서 &lt;strong&gt;애플리케이션의 상태를 추적하는 메트릭을 기록&lt;/strong&gt;한다. Prometheus로 수집된 메트릭은 Grafana 및 Kiali와 같은 도구를 사용하여 시각화 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Grafana&lt;/p&gt;

    &lt;p&gt;istio용 대시보드를 구성할 수 있는 오픈 소스 모니터링 도구로, Grafana를 사용하여 서비스 메시 내에서 &lt;strong&gt;애플리케이션의 상태를 모니터링&lt;/strong&gt; 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kiali&lt;/p&gt;

    &lt;p&gt;서비스 메시 구성 기능이 있는 istio용 observability 콘솔로, &lt;strong&gt;토폴로지를 유추하여 서비스 메시의 구조를 이해하고 상태를 확인하기 용이&lt;/strong&gt;하다. Jaeger를 통합하여 분산 추적을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jaeger&lt;/p&gt;

    &lt;p&gt;오픈 소스 종단 간 &lt;strong&gt;분산 추적 시스템&lt;/strong&gt;으로, 사용자가 복잡한 복잡한 마이크로서비스 환경을 모니터링하고 문제를 해결하는데 사용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Zipkin&lt;/p&gt;

    &lt;p&gt;Jaeger와 같은 분산 추적 시스템으로, &lt;strong&gt;Jaeger의 대안이며 기본적으로 배포되지 않는다&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;성공적으로 &lt;strong&gt;istio-system&lt;/strong&gt; 네임스페이스가 생기고 모든 리소스가 정상적으로 작동하는 것을 확인하고, ingress 및 egress 트래픽을 제어하기 위해 각 파드에 istio-proxy 컨테이너를 추가할 것이다. 다음 명령을 통해 &lt;strong&gt;default 네임스페이스에 대한 사이드카 삽입을 활성화&lt;/strong&gt; 해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl label namespace default istio-injection&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;enabled &lt;span class=&quot;nt&quot;&gt;--overwrite&lt;/span&gt;
  namedefault labeled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 default 네임스페이스에 배포하는 서비스는 istio-proxy가 사이드카로 같이 올라가기 때문에 트래픽 제어나 보안 등 다양한 istio 의 기능을 사용할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-helloworld-예제-앱-배포-&quot;&gt;1.2. helloworld 예제 앱 배포 &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;다음은 default 네임스페이스에 샘플 앱인 helloworld를 배포하고 helloworld 서비스(service), 게이트웨이(gateways)와 가상 서비스(virtualservices) 리소스를 생성해보겠다. 해당 매니페스트는 istio 폴더 내의 samples/helloworld 폴더에 helloworld.yaml과 helloworld-gateway.yaml 파일로 존재한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; istio-1.15.2/samples/helloworld/helloworld.yaml
  service/helloworld created
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all
  NAME                                 READY   STATUS    RESTARTS   AGE
  pod/helloworld-v1-78b9f5c87f-tljjx   2/2     Running   0          62s
  pod/helloworld-v2-54dddc5567-sd9td   2/2     Running   0          62s

  NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;    AGE
  service/helloworld   ClusterIP   10.98.206.190   &amp;lt;none&amp;gt;        5000/TCP   62s
  service/kubernetes   ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP    154m

  NAME                            READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/helloworld-v1   1/1     1            1           62s
  deployment.apps/helloworld-v2   1/1     1            1           62s

  NAME                                       DESIRED   CURRENT   READY   AGE
  replicaset.apps/helloworld-v1-78b9f5c87f   1         1         1       62s
  replicaset.apps/helloworld-v2-54dddc5567   1         1         1       62s

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; istio-1.15.2/samples/helloworld/helloworld-gateway.yaml
  gateway.networking.istio.io/helloworld-gateway created
  virtualservice.networking.istio.io/helloworld created
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get gateways,virtualservices
  NAME                                             AGE
  gateway.networking.istio.io/helloworld-gateway   30s

  NAME                                            GATEWAYS                 HOSTS   AGE
  virtualservice.networking.istio.io/helloworld   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;helloworld-gateway&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;   30s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹시나 스크립트로 서버를 관리하거나 작업을 자동화시킨다면 다음 명령어들을 통해 서비스 IP 주소나 포트 번호 등 리소스들의 정보를 가져올 수 있으니 참고바란다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INGRESS_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get service &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    istio-ingressgateway &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;{.status.loadBalancer.ingress[0].ip}&apos;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$INGRESS_HOST&lt;/span&gt;
  192.168.49.100

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INGRESS_PORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get service &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    istio-ingressgateway &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;{.spec.ports[?(@.name==&quot;http2&quot;)].port}&apos;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$INGRESS_PORT&lt;/span&gt;
  80

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SECURE_INGRESS_PORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get service &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    istio-ingressgateway &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;{.spec.ports[?(@.name==&quot;https&quot;)].port}&apos;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$SECURE_INGRESS_PORT&lt;/span&gt;
  443

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;GATEWAY_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INGRESS_HOST&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INGRESS_PORT&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$GATEWAY_URL&lt;/span&gt;
  192.168.49.100:80

  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get virtualservice helloworld &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;{.spec.http[0].match[0].uri}{&quot;\n&quot;}&apos;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;exact&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;/hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령들을 통해 GATEWAY_URL 환경 변수에 helloworld 서비스의 External IP와 port가 조합되어 있을 것 이다. 해당 환경변수를 넣어 curl 명령을 통해 helloworld 서비스가 정상 동작하는지 확인해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-vk&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# &quot;http://${GATEWAY_URL}/hello&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;   Trying 192.168.49.100:80...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Connected to 192.168.49.100 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;192.168.49.100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; port 80 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#0)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; GET /hello HTTP/1.1
  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Host: 192.168.49.100
  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; User-Agent: curl/7.81.0
  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Accept: &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Mark bundle as not supporting multiuse
  &amp;lt; HTTP/1.1 200 OK
  &amp;lt; content-type: text/html&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;charset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;utf-8
  &amp;lt; content-length: 60
  &amp;lt; server: istio-envoy
  &amp;lt; &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;: Thu, 13 Oct 2022 15:24:24 GMT
  &amp;lt; x-envoy-upstream-service-time: 243
  &amp;lt;
  Hello version: v1, instance: helloworld-v1-78b9f5c87f-tljjx
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Connection &lt;span class=&quot;c&quot;&gt;#0 to host 192.168.49.100 left intact&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;curl 명령을 통해 http://192.168.49.100:80/hello url로 접근해보니 상태코드 200과 함께 &lt;strong&gt;Hello version: v1, instance: helloworld-v1-78b9f5c87f-tljjx&lt;/strong&gt; 이라는 응답이 왔다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl exec -it pod/helloworld-v1-78b9f5c87f-tljjx cat app.py&lt;/code&gt; 명령을 입력하여 helloworld 애플리케이션의 코드를 확인할 수 있는데, /hello 경로로 요청했던 것에 대해 정상적으로 응답받은 것을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;#!/usr/bin/python
&lt;/span&gt;  &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;
  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;SERVICE_VERSION&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;# do some cpu intensive computation
&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0001&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Hello version: %s, instance: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;HOSTNAME&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/health&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;health&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Helloworld is healthy&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;0.0.0.0&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threaded&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;13-kiali-dashboard-사용-&quot;&gt;1.3. Kiali dashboard 사용 &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;kiali dashboard를 사용하기 전에 helloworld 서비스에 트래픽을 발생시키기 위해 새로운 터미널을 열어 loadgen.sh 파일을 실행해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;^#&apos;&lt;/span&gt; istio-1.15.2/samples/helloworld/loadgen.sh

  &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /dev/null &lt;span class=&quot;s2&quot;&gt;&quot;http://&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$GATEWAY_URL&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done
  &lt;/span&gt;son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./istio-1.15.2/samples/helloworld/loadgen.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;loadgen.sh에서는 프로세스가 멈출 때까지 &lt;strong&gt;http://$GATEWAY_URL/hello&lt;/strong&gt; url에 접근하는데, GATEWAY_URL 환경변수가 설정되어 있지 않다면 위의 내용을 참고하여 설정을 하거나 loadgen.sh 파일 내용을 $GATEWAY_URL 대신 INGRESS_HOST:INGRESS_PORT 형식의 값으로 바꿔넣어주면 된다.&lt;/p&gt;

&lt;p&gt;일정 시간이 지나 프로세스를 멈추려면 &lt;strong&gt;Ctrl + C&lt;/strong&gt; 키를 누르면 된다. 다음으로 kiali dashboard를 구동시켜보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;istioctl dashboard kiali
  http://localhost:20001/kiali
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;kiali로 접속할 수 있는 주소가 안내되고, 해당 주소로 접속하면 [그림 1]과 같은 화면을 볼 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/istio3.png&quot; alt=&quot;kiali-dashboard&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] kiali dashboard 접속&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Application 탭에는 istio 수신 게이트웨이, 애플리케이션 서비스 및 요청을 처리하는 파드 간의 연결이 표시된다. Applications를 클릭하고 default 네임스페이스를 선택 후 helloworld 애플리케이션 이름을 클릭하면 다음 [그림 2]와 같이 나올 것이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/istio4.png&quot; alt=&quot;kiali-applications-overview&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] kiali Applications Overview 탭 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inbound Metrics 탭을 클릭하면 네트워크 트래픽 그래프가 업데이트되면 [그림 3]과 같이 Inbound Metrics가 표시되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/istio5.png&quot; alt=&quot;kiali-applications-inbound&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] kiali Applications Inbound Metrics 탭 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Workloads 탭을 클릭한 다음 배포 이름인 &lt;strong&gt;helloworld-v1&lt;/strong&gt;을 클릭한다. Logs 탭을 클릭하면 파드 컨테이너에 대한 로그를 확인할 수 있고, helloworld 애플리케이션 또는 istio-proxy 컨테이너에 대한 로그를 필터링할 수도 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/istio6.png&quot; alt=&quot;kiali-workloads-logs&quot; width=&quot;100%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] kiali Workloads Logs 탭 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;짧게나마 istio를 사용해보니 모든 컨테이너에 대한 로깅, 메트릭 측정, 정책 등을 통합하여 관리하기 때문에 쿠버네티스의 복잡함을 줄여 효율적으로 관리할 수 있는 것 같다. 대규모 시스템 혹은 대규모 트래픽이 오가는 환경에서 istio를 사용해보고싶은데 언제쯤 해볼 수 있으려나..&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Oct 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/infra/2022/10/14/use_istio.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/infra/2022/10/14/use_istio.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>minikube</category>
        
        <category>kubectl</category>
        
        <category>kubernetes</category>
        
        <category>istio</category>
        
        <category>kiali</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Infra] Minikube에서 Istio 설치하기</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://crisis513.github.io/infra/2021/10/13/install_minikube.html#list1_2&quot; title=&quot;개발 환경&quot;&gt;개발 환경&lt;/a&gt;은 이전 포스팅과 동일하니 참고바란다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. Istio란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. Istio 설치 과정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. Istio 최소 사양&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. metallb 설치 및 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. Istio 설치&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-istio란-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. Istio란?&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;대부분의 서비스 메시와 마찬가지로 istio는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이드카(sidecar)&lt;/code&gt; 라는 프록시 컨테이너로 기존 애플리케이션 컨테이너를 보완한다. 사이드카 프록시로 Envoy를 사용하고, 아래와 같이 서비스 컨테이너에서 오가는 네트워크 트래픽을 가로채고 전용 네트워크를 통해 트래픽을 다시 라우팅한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/istio1.png&quot; alt=&quot;istio-architecture&quot; width=&quot;80%&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] istio 아키텍처&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저, Envoy 프록시는 다음과 같은 기능을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP, HTTP1, HTTP2, gRPC protocol 지원&lt;/li&gt;
  &lt;li&gt;TLS client certification&lt;/li&gt;
  &lt;li&gt;L7 라우팅 지원 및 URL 기반, 버퍼링, 서버간 부하 분산량 조절&lt;/li&gt;
  &lt;li&gt;Auto retry / Circuit Breaker 지원 / 다양한 로드밸런싱 기능 제공&lt;/li&gt;
  &lt;li&gt;Zipkin을 통한 분산 트랜잭션 성능 측정 제공&lt;/li&gt;
  &lt;li&gt;Dynamic configuration 지원, 중앙 레지스트리에 설정 및 설정 정보를 동적으로 읽어옴&lt;/li&gt;
  &lt;li&gt;MongoDB에 대한 L7 라우팅 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Control Plane은 Data Plane을 컨트롤하는 부분으로써 pilot, citadel, galley, Mixer(istio-1.5.0 부터는 istiod로 통합)로 구성되어 있고, 서비스 디스커버리, 설정 관리, 인증 관리 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-istio-설치-과정-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. Istio 설치 과정&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-istio-최소-사양-&quot;&gt;2.1. Istio 최소 사양 &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;istio는 istioctl, helm, Istio Operator 등 다양한 방법으로 설치할 수 있고, minikube에서는 istio를 추가 기능으로 제공하고 있긴 하지만 &lt;strong&gt;본 포스팅에서는 istioctl로 설치&lt;/strong&gt;해볼 것이다. istio는 minikube에서 작동하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4개의 vCPU와 8GB의 RAM이 필요&lt;/code&gt;하다. 참고로 minikube 가상 머신에 할당된 RAM이 충분하지 않으면 다음과 같은 오류가 발생할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이미지 가져오기 실패&lt;/li&gt;
  &lt;li&gt;상태 확인 시간 초과 실패&lt;/li&gt;
  &lt;li&gt;호스트의 kubectl 오류&lt;/li&gt;
  &lt;li&gt;가상 머신과 호스트의 일반적인 네트워크 불안정&lt;/li&gt;
  &lt;li&gt;가상 머신의 완전한 잠금&lt;/li&gt;
  &lt;li&gt;호스트 NMI 워치독 재부팅&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위에서 설명한대로 vCPU 4개와 8GB RAM의 조건을 충족하기 위해 다음 명령을 통해 minikube를 실행하겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube start &lt;span class=&quot;nt&quot;&gt;--cpus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4 &lt;span class=&quot;nt&quot;&gt;--memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8g
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; minikube v1.27.1 on Ubuntu 22.04
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Using the docker driver based on existing profile

  X The requested memory allocation of 8192MiB does not leave room &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;system overhead &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;total system memory: 8481MiB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; You may face stability issues.
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Suggestion: Start minikube with less memory allocated: &lt;span class=&quot;s1&quot;&gt;&apos;minikube start --memory=2200mb&apos;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; You cannot change the memory size &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;an existing minikube cluster. Please first delete the cluster.
  &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; You cannot change the CPUs &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;an existing minikube cluster. Please first delete the cluster.
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Starting control plane node minikube &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;cluster minikube
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Pulling base image ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Restarting existing docker container &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt; ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Preparing Kubernetes v1.25.2 on Docker 20.10.18 ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Verifying Kubernetes components...
    - Using image gcr.io/k8s-minikube/storage-provisioner:v5
    - Using image docker.io/kubernetesui/dashboard:v2.7.0
    - Using image docker.io/kubernetesui/metrics-scraper:v1.0.8
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Enabled addons: storage-provisioner, default-storageclass, dashboard
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Done! kubectl is now configured to use &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt; cluster and &lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt; namespace by default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;minikube에서 지원하는 여러가지 기능들을 addons를 통해 확인할 수 있는데, 여기에 istio도 있는 것을 확인할 수 있다. 앞서 언급하였듯 istioctl을 통해 설치를 진행할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-metallb-설치-및-설정-&quot;&gt;2.2. metallb 설치 및 설정 &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;minikube가 istio에서 사용할 로드 밸런서를 제공하도록 하려면 minikube tunnel 기능을 사용할 수 있지만 본 포스팅에서는 tunnel 기능을 사용하지 않고, metallb를 사용해볼 것이다. 그리고 metallb는 addons에 있는 기능으로 사용할 것 입니다. 우선 addons를 확인해보겠다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 metallb를 사용하지 않고 minikube tunnel을 사용한다면 아래 명령어를 새로운 터미널 창을 띄워 실행시키면 된다.&lt;/p&gt;

  &lt;p&gt;$ minikube tunnel&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube addons list
  |-----------------------------|----------|--------------|--------------------------------|
  |         ADDON NAME          | PROFILE  |    STATUS    |           MAINTAINER           |
  |-----------------------------|----------|--------------|--------------------------------|
  | ambassador                  | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Ambassador&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         |
  | auto-pause                  | minikube | disabled     | Google                         |
  | csi-hostpath-driver         | minikube | disabled     | Kubernetes                     |
  | dashboard                   | minikube | disabled     | Kubernetes                     |
  | default-storageclass        | minikube | enabled ✅   | Kubernetes                     |
  | efk                         | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Elastic&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | freshpod                    | minikube | disabled     | Google                         |
  | gcp-auth                    | minikube | disabled     | Google                         |
  | gvisor                      | minikube | disabled     | Google                         |
  | headlamp                    | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;kinvolk.io&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         |
  | helm-tiller                 | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Helm&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;               |
  | inaccel                     | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;InAccel             |
  |                             |          |              | &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;info@inaccel.com]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | ingress                     | minikube | disabled     | Kubernetes                     |
  | ingress-dns                 | minikube | disabled     | Google                         |
  | istio                       | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Istio&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;              |
  | istio-provisioner           | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Istio&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;              |
  | kong                        | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kong HQ&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | kubevirt                    | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;KubeVirt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;           |
  | logviewer                   | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;unknown&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | metallb                     | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MetalLB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | metrics-server              | minikube | disabled     | Kubernetes                     |
  | nvidia-driver-installer     | minikube | disabled     | Google                         |
  | nvidia-gpu-device-plugin    | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Nvidia&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;             |
  | olm                         | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Operator Framework&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; |
  | pod-security-policy         | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;unknown&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | portainer                   | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Portainer.io&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;       |
  | registry                    | minikube | disabled     | Google                         |
  | registry-aliases            | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;unknown&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | registry-creds              | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;UPMC Enterprises&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   |
  | storage-provisioner         | minikube | enabled ✅   | Google                         |
  | storage-provisioner-gluster | minikube | disabled     | 3rd party &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Gluster&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;            |
  | volumesnapshots             | minikube | disabled     | Kubernetes                     |
  |-----------------------------|----------|--------------|--------------------------------|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;현재 metallb가 사용되고 있지 않기 떄문에 disabled 상태인 것을 확인할 수 있다. minikube addons에서 metallb를 활성화 시켜보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube addons &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;metallb
  &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; metallb is a 3rd party addon and not maintained or verified by minikube maintainers, &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;at your own risk.
    - Using image docker.io/metallb/speaker:v0.9.6
    - Using image docker.io/metallb/controller:v0.9.6
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; The &lt;span class=&quot;s1&quot;&gt;&apos;metallb&apos;&lt;/span&gt; addon is enabled
  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get ns
  NAME              STATUS   AGE
  default           Active   125m
  kube-node-lease   Active   125m
  kube-public       Active   125m
  kube-system       Active   125m
  metallb-system    Active   39s
  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; metallb-system
  NAME                              READY   STATUS    RESTARTS   AGE
  pod/controller-55496b5cd7-52h5q   1/1     Running   0          56s
  pod/speaker-cfvms                 1/1     Running   0          56s

  NAME                     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                 AGE
  daemonset.apps/speaker   1         1         1       1            1           beta.kubernetes.io/os&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux   56s

  NAME                         READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/controller   1/1     1            1           56s

  NAME                                    DESIRED   CURRENT   READY   AGE
  replicaset.apps/controller-55496b5cd7   1         1         1       56s

  son@son-localhost &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get configmap config &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; metallb-system &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; yaml
  apiVersion: v1
  data:
    config: |
      address-pools:
      - name: default
        protocol: layer2
        addresses:
        - -
  kind: ConfigMap
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apiVersion&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;v1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;data&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;config&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;address-pools:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;- name: default&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  protocol: layer2&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  addresses:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  - -&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;kind&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;ConfigMap&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;metadata&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;annotations&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;config&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;namespace&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;metallb-system&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
    creationTimestamp: &lt;span class=&quot;s2&quot;&gt;&quot;2022-10-13T14:34:11Z&quot;&lt;/span&gt;
    name: config
    namespace: metallb-system
    resourceVersion: &lt;span class=&quot;s2&quot;&gt;&quot;5621&quot;&lt;/span&gt;
    uid: 0a5fd834-87f0-4191-a093-aa9cd25f5f35
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;minikube에서 metallb를 활성화시키면 metallb-system이라는 네임 스페이스가 생기는데, controller라는 deployment와 speaker라는 daemonset이 동작하는 것을 확인할 수 있고 configmap도 생성된 것을 확인할 수 있다. configmap 내용을 보면 프로토콜이 &lt;strong&gt;Layer2&lt;/strong&gt;로 동작하고, 주소 풀이 비어있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;metallb는 기본적으로 외부에 연결할 수 있는 IP 대역대가 있다면 metallb에서 IP 대역을 지정하여 IP를 할당해줄 수 있는데, 우리는 로컬 환경에서 구축하고 있기 때문에 External IP 대신 로컬에서 접속할 수 있는 IP 대역대를 입력해줄 것이다. 여기서 metallb를 통해 External IP가 설정된 주소 풀에 맞게 할당되도록 설정해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube addons configure metallb
  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Enter Load Balancer Start IP: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;192.168.49.100&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Enter Load Balancer End IP: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;192.168.49.120&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    - Using image docker.io/metallb/speaker:v0.9.6
    - Using image docker.io/metallb/controller:v0.9.6
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; metallb was successfully configured
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get configmap config &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; metallb-system &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; yaml
  apiVersion: v1
  data:
    config: |
      address-pools:
      - name: default
        protocol: layer2
        addresses:
        - 192.168.49.100-192.168.49.120
  kind: ConfigMap
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;apiVersion&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;v1&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;data&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;config&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;address-pools:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;- name: default&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  protocol: layer2&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  addresses:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;  - 192.168.49.100-192.168.49.120&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;kind&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;ConfigMap&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;metadata&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;annotations&quot;&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;config&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;namespace&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;metallb-system&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
    creationTimestamp: &lt;span class=&quot;s2&quot;&gt;&quot;2022-10-13T14:34:11Z&quot;&lt;/span&gt;
    name: config
    namespace: metallb-system
    resourceVersion: &lt;span class=&quot;s2&quot;&gt;&quot;5805&quot;&lt;/span&gt;
    uid: 0a5fd834-87f0-4191-a093-aa9cd25f5f35
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 필자는 Enter Load Balancer Start IP 부분에 192.168.49.100을, End IP 부분에 192.168.49.120을 입력하였다. 여기서 192.168.49.x 대역대는 필자의 개발환경에서 minikube가 사용하는 내부 네트워크의 대역대이다. &lt;strong&gt;만약 실습을 따라하고 있는 사람이 있다면 각자 환경에 맞는 IP를 기입해야 할 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-istio-설치-&quot;&gt;2.3. Istio 설치 &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;다음으로 istio 설치 파일을 다운받아 설치해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://istio.io/downloadIstio | sh -
    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                  Dload  Upload   Total   Spent    Left  Speed
  100   101  100   101    0     0    247      0 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:--   247
  100  4856  100  4856    0     0   8533      0 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:--  237k

  Downloading istio-1.15.2 from https://github.com/istio/istio/releases/download/1.15.2/istio-1.15.2-linux-amd64.tar.gz ...

  Istio 1.15.2 Download Complete!

  Istio has been successfully downloaded into the istio-1.15.2 folder on your system.

  Next Steps:
  See https://istio.io/latest/docs/setup/install/ to add Istio to your Kubernetes cluster.

  To configure the istioctl client tool &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;your workstation,
  add the /home/son/istio-1.15.2/bin directory to your environment path variable with:
          &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:/home/son/istio-1.15.2/bin&quot;&lt;/span&gt;

  Begin the Istio pre-installation check by running:
          istioctl x precheck

  Need more information? Visit https://istio.io/latest/docs/setup/install/
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:/home/son/istio-1.15.2/bin&quot;&lt;/span&gt;
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;which istioctl
  /home/son/istio-1.15.2/bin/istioctl
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;istioctl version
  client version: 1.15.2
  control plane version: 1.12.1
  data plane version: 1.12.1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2 proxies&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치할 당시의 istio 최신 버전을 다운받았고, bin 폴더에 있는 istioctl 바이너리 파일을 통해 istio를 설치할 것이다. 위의 istio 다운로드 스크립트를 실행했을 때 안내된 대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;istioctl x precheck&lt;/code&gt; 명령을 사용하여 설치 요구사항을 충족하고, 설치시 문제없이 안전하게 설치할 수 있는지 사전 검사를 진행해보고나서 설치해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;istioctl x precheck
  ✔ No issues found when checking the cluster. Istio is safe to &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;or upgrade!
    To get started, check out https://istio.io/latest/docs/setup/getting-started/
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;istioctl &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;profile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;demo &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
  ✔ Istio core installed
  ✔ Istiod installed
  ✔ Ingress gateways installed
  ✔ Egress gateways installed
  ✔ Installation &lt;span class=&quot;nb&quot;&gt;complete       
  &lt;/span&gt;Making this installation the default &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;injection and validation.

  Thank you &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;installing Istio 1.15.  Please take a few minutes to tell us about your &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;/upgrade experience!  https://forms.gle/SWHFBmwJspusK1hv6
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; istio-system
  NAME                                        READY   STATUS    RESTARTS   AGE
  pod/istio-egressgateway-fffc799cf-kd26t     1/1     Running   0          64s
  pod/istio-ingressgateway-7d68764b55-ckkc5   1/1     Running   0          64s
  pod/istiod-5456fd558d-x6jpf                 1/1     Running   0          93s

  NAME                           TYPE           CLUSTER-IP       EXTERNAL-IP     PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                                                                      AGE
  service/istio-egressgateway    ClusterIP      10.105.237.74    &amp;lt;none&amp;gt;          80/TCP,443/TCP                                                               10m
  service/istio-ingressgateway   LoadBalancer   10.97.166.77     192.168.49.100  15021:32414/TCP,80:30295/TCP,443:30180/TCP,31400:30731/TCP,15443:30050/TCP   10m
  service/istiod                 ClusterIP      10.109.182.176   &amp;lt;none&amp;gt;          15010/TCP,15012/TCP,443/TCP,15014/TCP                                        10m

  NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/istio-egressgateway    1/1     1            1           10m
  deployment.apps/istio-ingressgateway   1/1     1            1           10m
  deployment.apps/istiod                 1/1     1            1           10m

  NAME                                              DESIRED   CURRENT   READY   AGE
  replicaset.apps/istio-egressgateway-fffc799cf     1         1         1       64s
  replicaset.apps/istio-ingressgateway-7d68764b55   1         1         1       64s
  replicaset.apps/istiod-5456fd558d                 1         1         1       93s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;istio 디렉토리의 manifests/profiles 경로를 보면 다양한 매니페스트 파일이 존재하는 것을 확인할 수 있는데, 테스트 용도로 설치해보기 위해 demo 매니페스트를 kubernetes에 배포하였다. 성공적으로 배포가 되었다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;istio-system&lt;/code&gt;이라는 네임 스페이스가 생성되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 istio-ingressgateway 로드밸런서 서비스의 External IP가 192.168.49.100으로 할당되어 있는 것을 확인할 수 있다. 앞서 metallb를 설치하고 IP 풀을 할당해줬기 때문에 metallb에서 istio-ingressgateway라는 로드밸런서 타입의 서비스에 External IP를 부여해준 것이다. 현재 테스트 환경을 간단하게 그림으로 그려보자면 다음 [그림 2]과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/infra/istio2.png&quot; alt=&quot;metallb-istio&quot; width=&quot;576&quot; height=&quot;384&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] metallb와 istio 테스트 환경&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Oct 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/infra/2022/10/14/install_istio.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/infra/2022/10/14/install_istio.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>minikube</category>
        
        <category>kubectl</category>
        
        <category>kubernetes</category>
        
        <category>istio</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Infra] Ubuntu 22.04 환경에서 Minikube 설치하기</title>
        <description>&lt;p&gt;본 포스팅에서는 Ubuntu 22.04 환경에서 minikube를 설치하는 과정을 설명한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Minikube란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 개발 환경&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. Docker 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. Minikube 설치 과정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_1&quot;&gt;   3.1. Minikube 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_2&quot;&gt;   3.2. kubectl 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_3&quot;&gt;   3.3. Minikube 실행 및 종료&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-개요-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 개요&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-minikube란-&quot;&gt;1.1. minikube란? &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;minikube는 다양한 OS에서 로컬 Kubernetes 클러스터를 구현할 수 있도록 도와주는 &lt;strong&gt;오픈 소스 도구&lt;/strong&gt;이다. minikube의 주요 목표는 로컬 Kubernetes 애플리케이션 개발을 위한 도구들과 그에 맞는 모든 &lt;strong&gt;Kubernetes 기능을 지원&lt;/strong&gt;하는 것이다. 로컬에서 리소스 활용이 적은 단일 노드 kubernetes 클러스터를 구동시킬 수 있기 때문에 개발 테스트 및 POC 목적으로 사용하기 좋다.&lt;/p&gt;

&lt;p&gt;자세한 설명은 &lt;a href=&quot;https://minikube.sigs.k8s.io/docs&quot; title=&quot;minikube&quot;&gt;minikube 웹사이트&lt;/a&gt;를 통해 확인하기 바란다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-개발-환경-&quot;&gt;1.2. 개발 환경 &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;필자는 실습을 위해 &lt;strong&gt;VMWare Workstation 16.2&lt;/strong&gt;에서 &lt;strong&gt;Ubuntu 22.04 LTS Desktop&lt;/strong&gt; 이미지로 가상머신을 생성하여 진행하였다. 해당 환경에서 &lt;strong&gt;Docker&lt;/strong&gt;를 설치하고, &lt;strong&gt;minikube&lt;/strong&gt;에서 드라이버로 Docker를 사용하여 Kubernetes 구성 요소를 여기에 설치해볼 예정이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-docker-설치-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. Docker 설치&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;minikube를 설치하기 위해서는 드라이버를 설정해주어야 하는데, minikube는 virtualbox와 같은 VM, Docker와 같은 컨테이너 또는 베어메탈 등 다양한 드라이버를 지원하고 있다. 이 중에서 본 포스팅에서는 Docker를 드라이버로 사용하여 진행할 것이다.&lt;/p&gt;

&lt;p&gt;Docker를 설치하기 전에 모든 시스템 패키지를 최신 릴리스로 업데이트 해야한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update
son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;apt-transport-https
son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹시나 재부팅이 필요한 경우 재부팅을 하고난 다음 설치를 진행하면 된다.&lt;/p&gt;

&lt;p&gt;Docker는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get.docker.com&lt;/code&gt;에서 지원하는 &lt;strong&gt;스크립트를 다운받아 실행&lt;/strong&gt;해주기만 하면 되기 때문에 간단하게 설치할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://get.docker.com &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; get-docker.sh
son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;sh get-docker.sh
&lt;span class=&quot;c&quot;&gt;# Executing docker install script, commit: 4f282167c425347a931ccfd95cc91fab041d414f&lt;/span&gt;
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; apt-get update &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;DEBIAN_FRONTEND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;noninteractive apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; apt-transport-https ca-certificates curl &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /etc/apt/keyrings &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-R&lt;/span&gt; 0755 /etc/apt/keyrings
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://download.docker.com/linux/ubuntu/gpg&quot;&lt;/span&gt; | gpg &lt;span class=&quot;nt&quot;&gt;--dearmor&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--yes&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /etc/apt/keyrings/docker.gpg
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;a+r /etc/apt/keyrings/docker.gpg
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu jammy stable&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /etc/apt/sources.list.d/docker.list
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; apt-get update &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;DEBIAN_FRONTEND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;noninteractive apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--no-install-recommends&lt;/span&gt; docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-scan-plugin &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ version_gte 20.10
+ &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
+ &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;0
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;DEBIAN_FRONTEND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;noninteractive apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qq&lt;/span&gt; docker-ce-rootless-extras &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/dev/null
+ sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; docker version
Client: Docker Engine - Community
  Version:           20.10.18
  API version:       1.41
  Go version:        go1.18.6
  Git commit:        b40c2f6
  Built:             Thu Sep  8 23:11:43 2022
  OS/Arch:           linux/amd64
  Context:           default
  Experimental:      &lt;span class=&quot;nb&quot;&gt;true

&lt;/span&gt;Server: Docker Engine - Community
  Engine:
  Version:          20.10.18
  API version:      1.41 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;minimum version 1.12&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  Go version:       go1.18.6
  Git commit:       e42327a
  Built:            Thu Sep  8 23:09:30 2022
  OS/Arch:          linux/amd64
  Experimental:     &lt;span class=&quot;nb&quot;&gt;false
  &lt;/span&gt;containerd:
  Version:          1.6.8
  GitCommit:        9cd3357b7fd7218e4aec3eae239db1f68a5a6ec6
  runc:
  Version:          1.1.4
  GitCommit:        v1.1.4-0-g5fd4c4d
  docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0

&lt;span class=&quot;o&quot;&gt;================================================================================&lt;/span&gt;

To run Docker as a non-privileged user, consider setting up the
Docker daemon &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;rootless mode &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;your user:

    dockerd-rootless-setuptool.sh &lt;span class=&quot;nb&quot;&gt;install

&lt;/span&gt;Visit https://docs.docker.com/go/rootless/ to learn about rootless mode.

To run the Docker daemon as a fully privileged service, but granting non-root
&lt;span class=&quot;nb&quot;&gt;users &lt;/span&gt;access, refer to https://docs.docker.com/go/daemon-access/

WARNING: Access to the remote API on a privileged Docker daemon is equivalent
          to root access on the host. Refer to the &lt;span class=&quot;s1&quot;&gt;&apos;Docker daemon attack surface&apos;&lt;/span&gt;
          documentation &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;details: https://docs.docker.com/go/attack-surface/

&lt;span class=&quot;o&quot;&gt;================================================================================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;get-docker.sh란 이름으로 스크립트를 다운받아 실행해주어 Docker를 설치하고 아래 명령어를 통해 Docker 어느 버전으로 설치되었는지 확인해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
Docker version 20.10.18, build b40c2f6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker가 정상적으로 설치가 되긴 했지만, 현재 상태로 minikube에서 Docker를 드라이버로 설정하여 설치할 때 permission denied 에러가 발생할 것이다. 에러를 사전에 방지하기 위해 Docker를 일반 유저도 쓸 수 있도록 설정해주겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-aG&lt;/span&gt; docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; newgrp docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가로 docker-compose를 사용할 것이라면 다음 명령을 통해 docker-compose를 설치할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-compose
son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
docker-compose version 1.29.2, build unknown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-minikube-설치-과정-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;3. Minikube 설치 과정&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;위의 과정을 통해 Docker를 정상적으로 설치하였다면 다음으로 minikube를 설치하겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;31-minikube-설치-&quot;&gt;3.1. Minikube 설치 &lt;a name=&quot;list3_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;minikube를 설치하기 위해서는 &lt;strong&gt;minikube 바이너리를 다운로드&lt;/strong&gt;해야 한다. 바이너리를 다운받아 &lt;strong&gt;실행 권한을 준 다음 /usr/local/bin 디렉토리 아래에 넣을 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  &lt;span class=&quot;nt&quot;&gt;--2022-10-13&lt;/span&gt; 04:03:24--  https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  Resolving storage.googleapis.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;storage.googleapis.com&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;... 34.64.4.112, 34.64.4.80, 34.64.4.16, ...
  Connecting to storage.googleapis.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;storage.googleapis.com&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;|34.64.4.112|:443... connected.
  HTTP request sent, awaiting response... 200 OK
  Length: 76629407 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;73M&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;application/octet-stream]
  Saving to: ‘minikube-linux-amd64’
  
  minikube-linux-amd64        100%[&lt;span class=&quot;o&quot;&gt;===========================================&amp;gt;]&lt;/span&gt;  73.08M  5.17MB/s    &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;13s
  
  2022-10-13 04:03:38 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5.72 MB/s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; - ‘minikube-linux-amd64’ saved &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;76629407/76629407]
  
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x minikube-linux-amd64
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mv &lt;/span&gt;minikube-linux-amd64 /usr/local/bin/minikube
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;minikube 바이너리 파일을 /usr/local/bin 디렉토리 아래에 두었다면 다음 명령어를 통해 설치된 minikube 버전을 확인해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube version
  minikube version: v1.27.1
  commit: fe869b5d4da11ba318eb84a3ac00f336411de7ba
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;혹시나 minikube가 실행되지 않는다면 $PATH에 /usr/local/bin이 없기 때문일 것이다. 
다른 $PATH로 위치를 옮기거나 $PATH에 /usr/local/bin 위치를 추가해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-kubectl-설치-&quot;&gt;3.2. kubectl 설치 &lt;a name=&quot;list3_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;minikube를 설치하더라도 &lt;strong&gt;Kubernetes에서 애플리케이션을 배포하고 관리하기 위해 사용되는 도구인 kubectl&lt;/strong&gt;을 따로 설치해야 한다. 마찬가지로 kubectl 바이너리 파일을 다운받아 실행권한을 준 다음 /usr/local/bin 위치로 옮겨주자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-LO&lt;/span&gt; https://storage.googleapis.com/kubernetes-release/release/&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://storage.googleapis.com/kubernetes-release/release/stable.txt&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/bin/linux/amd64/kubectl
    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                    Dload  Upload   Total   Spent    Left  Speed
  100 42.9M  100 42.9M    0     0  8035k      0  0:00:05  0:00:05 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;:--:-- 8355k
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x ./kubectl
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mv&lt;/span&gt; ./kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;kubectl 바이너리 파일을 /usr/local/bin 디렉토리 아래에 두었다면 다음 명령어를 통해 설치된 kubectl 버전을 확인해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl version &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; json &lt;span class=&quot;nt&quot;&gt;--client&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;clientVersion&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;s2&quot;&gt;&quot;major&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;minor&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;25&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;gitVersion&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;v1.25.2&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;gitCommit&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;5835544ca568b757a8ecae5c153f317e5736700e&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;gitTreeState&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;clean&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;buildDate&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2022-09-21T14:33:49Z&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;goVersion&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;go1.19.1&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;compiler&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;gc&quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&quot;platform&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;linux/amd64&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;kustomizeVersion&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;v4.5.7&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-minikube-실행-및-종료-&quot;&gt;3.3. Minikube 실행 및 종료 &lt;a name=&quot;list3_3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;minikube를 실행시키기 위해서는 다음과 같이 minikube start 명령을 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube start
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; minikube v1.27.1 on Ubuntu 22.04
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Automatically selected the docker driver. Other choices: ssh, none
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Using Docker driver with root privileges
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Starting control plane node minikube &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;cluster minikube
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Pulling base image ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Downloading Kubernetes v1.25.2 preload ...
      &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; preloaded-images-k8s-v18-v1...:  385.41 MiB / 385.41 MiB  100.00% 4.47 Mi
      &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gcr.io/k8s-minikube/kicbase:  387.10 MiB / 387.11 MiB  100.00% 3.68 MiB p
      &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; gcr.io/k8s-minikube/kicbase:  0 B &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;________________________] ?% ? p/s 58s
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Creating docker container &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CPUs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2200MB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Preparing Kubernetes v1.25.2 on Docker 20.10.18 ...
    - Generating certificates and keys ...
    - Booting up control plane ...
    - Configuring RBAC rules ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Verifying Kubernetes components...
    - Using image gcr.io/k8s-minikube/storage-provisioner:v5
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Enabled addons: default-storageclass, storage-provisioner
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Done! kubectl is now configured to use &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt; cluster and &lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt; namespace by default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아무런 옵션도 기입하지 않으면 위에서 설치했던 Docker를 드라이버로 잡고, kicbase 이미지를 받아 CPU 2 core와 Memory 2200MB를 자동으로 잡는 것을 확인할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여기서 kicbase 이미지는 통신하기 위해 프록시의 역할을 하는 것으로 알고 있다. 
해당 이미지가 없다면 docker pull을 통해 받아오거나, VPN 또는 HTTP/HTTPS 프록시를 환경 변수로 사용하여 minikube start 해야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;minikube가 정상적으로 실행되었다면 kubectl 명령을 통해 생성된 클러스터 정보와 설정을 확인해보도록 하겠다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl cluster-info
  Kubernetes control plane is running at https://192.168.49.2:8443
  CoreDNS is running at https://192.168.49.2:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

  To further debug and diagnose cluster problems, use &lt;span class=&quot;s1&quot;&gt;&apos;kubectl cluster-info dump&apos;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  
  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl config view
  apiVersion: v1
  clusters:
  - cluster:
      certificate-authority: /home/son/.minikube/ca.crt
      extensions:
      - extension:
          last-update: Thu, 13 Oct 2022 21:29:21 KST
          provider: minikube.sigs.k8s.io
          version: v1.27.1
        name: cluster_info
      server: https://192.168.49.2:8443
    name: minikube
  contexts:
  - context:
      cluster: minikube
      extensions:
      - extension:
          last-update: Thu, 13 Oct 2022 21:29:21 KST
          provider: minikube.sigs.k8s.io
          version: v1.27.1
        name: context_info
      namespace: default
      user: minikube
    name: minikube
  current-context: minikube
  kind: Config
  preferences: &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;users&lt;/span&gt;:
  - name: minikube
    user:
      client-certificate: /home/son/.minikube/profiles/minikube/client.crt
      client-key: /home/son/.minikube/profiles/minikube/client.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;minikube를 종료하고 싶다면 다음과 같이 minikube stop 명령을 통해 종료할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  son@son-localhost ~ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;minikube stop
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Stopping node &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt;  ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Powering off &lt;span class=&quot;s2&quot;&gt;&quot;minikube&quot;&lt;/span&gt; via SSH ...
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 1 node stopped.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Oct 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/infra/2022/10/13/install_minikube.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/infra/2022/10/13/install_minikube.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>infra</category>
        
        <category>docker</category>
        
        <category>minikube</category>
        
        <category>kubectl</category>
        
        <category>kubernetes</category>
        
        
        <category>Infra</category>
        
      </item>
    
      <item>
        <title>[Data] 엑셀을 활용한 날짜 데이터 가공</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 데이터 가공 방법&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;필자가 군대에서 데이터를 시각화하는 업무를 보던 중 지원과에서 전달받은 엑셀 데이터의 날짜 형식이 중구난방이었던 적이 있었다. [그림 1]과 같이 어떤 셀에는 텍스트형식, 어떤 셀에는 날짜형식, 어떤 셀에는 숫자형식으로 되어 있는 총체적 난국의 데이터였다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/date1.png&quot; alt=&quot;date_pic_1&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 전달받은 엑셀의 날짜 데이터 예시&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;원래는 엑셀로 양식을 만들어 담당자들에게 뿌려서 취합하여 만든 데이터였는데, 날짜 형식을 지정해주지 않아 각양각색의 날짜 포맷으로 온 것으로 보인다. &lt;strong&gt;다른 포맷의 날짜 형식을 하나의 포맷으로 통일시켜 정상적으로 데이터 시각화시켜줄 수 있도록 가공하는 것이 본 포스팅에서의 목적&lt;/strong&gt;이다. 파이썬으로도 가공할 수 있겠지만, 여기서는 엑셀에서 가공하는 방법을 설명할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-데이터-가공-방법-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 데이터 가공 방법&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;사실 필자는 엑셀을 다뤄본 경험은 없지만 Qlik Sense라는 데이터 분석 툴에서 표현식을 많이 작성하다보니 엑셀의 함수가 매우 익숙했다. 우선 [그림 1]의 날짜 데이터 모든 셀의 표시 형식을 통일을 시키는 것을 시작으로 아래 10 단계의 과정을 거쳐 데이터를 가공하였다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A열은 개판 5분 전인 날짜 데이터&lt;/code&gt;이고, &lt;strong&gt;B열부터는 다음 설명의 3번부터 함수를 적용시켜 단계적으로 가공해나갈 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;값 및 숫자 서식 붙여넣기&lt;/p&gt;

    &lt;p&gt;우선 날짜 형식을 깨지 않으면서 셀 서식을 모두 텍스트로 형식으로 동일하게 맞춰줘야 했다. 따라서 날짜 데이터 열(A열) 전체를 선택하여 [텍스트 나누기] - [구분 기호로 분리됨] - [탭] - [텍스트] 순서로 클릭해나가면 날짜 형식이 숫자로 변환되지 않고 텍스트 그대로 남아있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;찾기 및 바꾸기: &lt;strong&gt;’-‘ → ‘.’, ‘월’ → ‘.’, ‘일’ → ‘.’&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;텍스트로 된 날짜 포맷에서 년월일 날짜 구분자를 ‘.’으로 하기위해 A열 모든 셀들의 ‘-‘, ‘월’, ‘일’이라고 표기를 찾아 ‘.’으로 모두 바꾸기 한다. Ctrl + F 단축키를 누르면 [그림 2]와 같이 찾기 및 바꾸기 창이 뜨는데 바꾸기 탭에서 모두 찾기 및 모두 바꾸기 하면 된다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/date2.png&quot; alt=&quot;date_pic_2&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 찾기 및 모두 바꾸기&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B1셀 수식: &lt;strong&gt;=IF(RIGHT(A1,1)=”.”,LEFT(A1,LEN(A1)-1),A1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;A1열의 맨 오른쪽 첫 문자가 ‘.’이라면 삭제하고, A열에 입력되어 있는 행까지 수식 채워넣기 한다. [그림 3]과 같이 되는 것을 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/date3.png&quot; alt=&quot;date_pic_3&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] B열에서 A열 날짜 데이터 가공 예시&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C1셀 수식: &lt;strong&gt;=IF(LEFT(B1,5)=”2021.”,RIGHT(B1,LEN(B1)-5),B1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;B1열의 맨 왼쪽 다섯 문자가 ‘2021.’이라면 삭제하고, A열에 입력되어 있는 행까지 수식 채워넣기 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;D1셀 수식: &lt;strong&gt;=IF(LEFT(C1,3)=”21.”,RIGHT(C1,LEN(C1)-3),C1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;C1열의 맨 왼쪽 세 문자가 ‘21.’이라면 삭제하고, A열에 입력되어 있는 행까지 수식 채워넣기 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;E1셀 수식: &lt;strong&gt;=IF(LEFT(D1,1)&amp;lt;&amp;gt;”0”,CONCATENATE(“0”,D1),D1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;D1열의 맨 왼쪽 첫 문자가 ‘0’이 아니라면 T열의 문자 앞에 ‘0’을 붙이고, A열에 입력되어 있는 행까지 수식 채워넣기 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;F1셀 수식: &lt;strong&gt;=IF(LEFT(E1,3)=”010”,RIGHT(E1,LEN(E1)-1),E1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;E1열의 맨 왼쪽 세 문자가 ‘010’이라면 우측의 두 문자만 선택하고, A열에 입력되어 있는 행까지 수식 채워넣기 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;G1셀 수식: &lt;strong&gt;=IF(LEFT(F1,3)=”011”,RIGHT(F1,LEN(F1)-1),IF(LEFT(F1,3)=”012”,RIGHT(F1,LEN(F1)-1),F1))&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;F1열의 맨 왼쪽 세 문자가 ‘011’이라면 우측의 두 문자만 선택하고, ‘012’이어도 우측의 두 문자만 선택한다. 그리고 A열에 입력되어 있는 행까지 수식 채워넣기 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;H1셀 수식: &lt;strong&gt;=IF(LEN(G1)=4,LEFT(G1,3)&amp;amp;”0”&amp;amp;RIGHT(G1,1),G1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;G1열의 길이가 4라면 G1의 우측 세 문자 뒤에 ‘0’을 붙이고, 그 뒤에 G1열의 맨 우측 한 문자를 붙인다. 그리고 A열에 입력되어 있는 행까지 수식 채워넣기 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I1셀 수식: &lt;strong&gt;=CONCATENATE(“2021.”,H1)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;H1열의 맨 앞에 ‘2021.’을 붙이고, A열에 입력되어 있는 행까지 수식 채워넣기 한다. 10번까지 정상적으로 입력했다면 다음 [그림 4]와 같이 나올 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/date4.png&quot; alt=&quot;date_pic_4&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] 단계별 데이터 가공 예시&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;본 포스팅에서는 모든 년도가 2021년 데이터이기 때문에 년도에 해당하는 부분을 모두 지우고 2021로 가공했지만, 필요에 따라 년도 부분은 건들이지 않거나 년도의 자릿수를 맞춰주기 위해 맨 앞에 ‘20’을 붙여주는 등 상황에 맞는 수식을 작성해주면 될 것 같다.&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Sep 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/data/2022/09/08/date_data_procecssing.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/data/2022/09/08/date_data_procecssing.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>data</category>
        
        <category>date</category>
        
        <category>processing</category>
        
        <category>excel</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[Anything] 군 복무 스토리</title>
        <description>&lt;p&gt;본 포스트에서는 보안상 디테일한 내용과 이미지를 첨부하지 않고, 개인적인 스토리와 간략한 업무 내용을 담았습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 요약&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 군 복무 상세 스토리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 훈련소 스토리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 자대 스토리&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-요약---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 요약&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;군 복무 기간 및 소속과 보직 (총 복무일: 545일)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;2020-11-09 ~ 2020-12-17 : 육군 논산훈련소 27연대 3중대 1소대 3분대 / 38번 훈련병&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2020-12-17 ~ 2022-05-08 : 육군 종합정비창 본부 정보통신실 빅데이터분석반 / 빅데이터분석병&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2022-05-08 ~ : &lt;strong&gt;병장 만기전역&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;업무 내용&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;훈련소에서 &lt;strong&gt;군사과학기술병&lt;/strong&gt;이라는 군사특기를 받아 &lt;strong&gt;종합정비창&lt;/strong&gt;으로 전입와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;빅데이터분석병&lt;/code&gt;이라는 보직을 받음&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;BI(Business Intelligence) 업무를 하였고, 필요에 따라 SQL 작성, 데이터 가공, Python을 통한 업무 자동화 코드 작성 등의 업무를 하였음&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qlik Sense&lt;/code&gt; 라는 빅데이터 분석 시각화 도구를 통해 각종 시각화 화면을 구현함&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;업무 성과&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;필자는 군 복무를 하는 동안 크게 Qlik Sense 툴을 사용해 다음과 같은 주제의 시각화 화면을 구현함&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;용수저수지 수위관리 데이터 분석&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;창 정비 및 공정 진행 분석&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;예산집행 현황&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;인사 정보 체계&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;코로나19 백신 접종 현황&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;파이썬 프로그래밍 업무활용 교육&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;기간: 2021-04 ~ 2021-05&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;일정: 총 8차시(1일 2시간씩)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;대상: 부대 내 군무원 및 현역간부&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;내용: 파이썬 프로그래밍을 활용하여 &lt;strong&gt;데이터 처리 능력을 함양&lt;/strong&gt;시키고, 단순 반복업무의 자동화 소요를 식별 및 개선할 수 있도록 &lt;strong&gt;업무 효율성을 향상&lt;/strong&gt;시키기 위한 교육을 진행 (파이썬 기초 문법 및 pandas, beautifulsoup4 라이브러리 사용법과 업무적용 사례)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;2021년 전반기 빅데이터 분석 창 경진대회 최우수&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;기간: 2021-05 ~ 2021-07&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;요약: 부대 내에서 모든 부서를 대상(9팀 출전)으로 진행한 빅데이터 분석 창 경진대회에서 &lt;strong&gt;최우수팀&lt;/strong&gt;으로 선정&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;내용: 물 환경 보전법이 개정되어 2022년 1월 1일부로 유기물질에 대한 측정지표가 COD(Chemical Oxygen Demand)에서 &lt;strong&gt;TOC(Total Organic Carbon)로 강화&lt;/strong&gt;됨. 개정됨에 따라 기준치 미충족으로 인한 행정처분이 예상되기 때문에 데이터를 분석하여 작업장별 최적의 배출시기를 도출하고 시각화시키는 프로젝트 진행&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;역할: 문제점 도출을 위한 &lt;strong&gt;데이터 분석&lt;/strong&gt;과 실제 업무에 적용하기 위한 &lt;strong&gt;데이터 시각화&lt;/strong&gt; 그리고 파이썬을 통한 배출량에 따른 &lt;strong&gt;일정 균등분배 알고리즘 구현 보조&lt;/strong&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;빅데이터 분석 시각화 툴(Qlik Sense) 교육 및 컨설팅 진행&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;기간: 2021-09 ~ 2021-09&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;일정: 총 5차시(1일 3시간씩)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;대상: 부대 내 2021년 후반기 빅데이터 분석 창 경진대회에 참가하는 모든 인원&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;내용: 빅데이터 분석 시각화 툴 사용법에 대한 외부 업체 교육의 의존성을 줄여 &lt;strong&gt;교육 비용을 절감&lt;/strong&gt;하고, 군부대 특성에 맞는 다양한 사례를 추가해 &lt;strong&gt;교육의 질을 향상&lt;/strong&gt;시키며, 주기적인 컨설팅을 통해 경진대회에 출품하는 팀들의 &lt;strong&gt;산출물 퀄리티를 높임&lt;/strong&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-군-복무-상세-스토리-&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 군 복무 상세 스토리&lt;/strong&gt;&lt;/span&gt; &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;사실 필자의 군대 갔을 당시의 이야기를 이렇게 블로그로 작성하게 될 줄 몰랐다. 날 마다 일일업무일지도 작성하고 군 경력증명서라는 것을 발급해준다길래 기대했는데, 군대는 역시 군대였다. 교육 관련 교관으로 임명된 인사 발령 기록도 없고, 어떤 업무를 어떻게 했는지에 대한 정보는 일절 찾을 수가 없기에 이렇게 직접 기억을 되새기며 기록해보고자 한다. 18개월이라는 복무 기간동안 일어난 모든 이야기를 담을 수는 없겠지만 기억 나는 대로 기록해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-훈련소-스토리-&quot;&gt;2.1. 훈련소 스토리 &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;군 경험을 포스팅하는 목적은 군 기밀을 유출할 수 없는 상황에서 필자가 빅데이터분석병으로 어떤 업무를 어떻게 했었는지에 대한 이야기를 들려주기 위함이다.&lt;/strong&gt; 추억도 같이 기록할 겸 훈련소에서의 생활도 간단하게 이야기해볼까 한다.&lt;/p&gt;

&lt;p&gt;필자는 바보같은 대처로 군 입대를 더 이상 미루지 못하게 되어 26살이라는 비교적 늦은 나이에 징집으로 입대하게 되었다. 필자의 훈련소 생활은 1주차는 동화주차라고 하여 훈련소 생활에 적응하는 주인데, 하필 코로나가 기승을 부리는 시기여서 동화주차때는 생활관별로 격리기간을 갖고 2주차부터 본격적인 훈련을 시작하였다. 훈련소에서는 자대에 배치됐을 때의 보직이나 주특기를 정하기 위해 5일 차쯤 적성 검사를 진행하게 된다. 사전에 원하는 보직을 정해 모집으로 입대했다면 이 적성 검사와는 상관 없이 해당 보직으로 정해지겠지만, 필자와 같이 징집으로 온 사람들 중 특기가 있는 사람이라면 랜덤으로 보직이 정해지길 기다리는 것보단 본인에 해당되는 특기와 관련한 보직으로 배정받을 수 있는 실낱같은 희망이 생기는 것이다. 필자는 석사학위를 취득하고 입대한 케이스이고, 그 동안 공부한 내용과 경험을 바탕으로 전산, 보안, 행정 등 다양한 분야에 시험을 보고 전공과 관련한 꿀보직이 걸리기를 기대하고 있었다.&lt;/p&gt;

&lt;p&gt;그렇게 시간이 흘러 2주차에는 제식 및 기초 훈련을 받는 동시에 몇몇 부대와 특수한 보직에 적합한 인재를 선별하거나 지원자를 받아 면접을 진행했었다. 필자에게도 하나의 면접 제의가 들어왔다. 그런데 다른 면접은 대부분 단체로 면접을 보는 듯 했는데 필자는 혼자 군무원 한 분과 1:1로 면접을 보게 되었다. 면접보러 오신 군무원분은 경상남도 창운에 위치한 육군 종합정비창 정보통신실 소속 주무관님이셨고, 정보통신실에서는 빅데이터 분석 업무를 하고 있는데 나에게 같이 업무를 하면 좋겠다고 하시며 우리 부대로 오라고 적극 권유해주셨다. 필자는 빅데이터는 커녕 데이터 분석에 대해서 따로 공부해본 적은 없었지만 컴퓨터공학을 전공했다면 분명 도움이 될 것이라고 하시면서 업무를 하고 계시는 군무원분들과 같이 공부하면서 일하면 된다고 하셨다.&lt;/p&gt;

&lt;p&gt;면접이 끝나고는 이러한 면접이 여러 번 있다면 ‘나한테 더 좋은 기회가 또 올 수도 있지 않을까?’ 싶어서 면접이 끝나고 옆에 있는 분대장한테 “여기가 가기 싫어서 거부하면 또 다른 면접을 볼 수 있습니까? 면접 리스트가 따로 있습니까?” 라고 물었더니 “아니, 여기 안가면 랜덤으로 배정돼. 왜 싫어?”라고 답하길래 바로 너무 좋다고 여기로 가겠다고 승락의 못을 박아버렸다!&lt;/p&gt;

&lt;p&gt;여기까지가 필자가 종합정비창의 빅데이터분석병으로 배정되어 가게 된 스토리이다. 추가로 같은 생활관 동기들도 다들 착하고 능력있는 친구들이었어서 서로 의지하며 훈련받을 수 있어 힘든 와중에도 즐거운 시간이었다. 짧다면 짧고 길다면 긴 38일이었지만 전역 후에도 종종 연락하고 만나는 동생들이 생겨 매우 보람찬 훈련소 생활이었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-자대-스토리-&quot;&gt;2.2. 자대 스토리 &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;용수저수지 수위관리 데이터 분석&lt;/p&gt;

    &lt;p&gt;부대 내 대부분의 물을 용수저수지에서 끌어와서 사용하는데, 개발 당시 오랜기간 비가 오지 않아 저수지 수위가 많이 낮아진 상태였다. &lt;strong&gt;만약 저수지 수위가 사수위까지 도달하여 부대 내 근처 상수도를 통해 공급받아야 하는데, 지속가능 일수를 예측하여 용수를 사전에 확보하거나 일정 지속가능 일수에 도달하면 절수방안을 적용하고, 대책 수립의 근거 자료로 사용하기 위해 용수저수지 데이터를 분석 및 시각화하는 업무를 맡게 되었다.&lt;/strong&gt; 이 업무는 두 달 동안 셀프스터디만 하던 나에게 맡겨진 공식적인 첫 업무였다.&lt;/p&gt;

    &lt;p&gt;우선, 용수저수지 수위를 측정하고 데이터를 관리하는 부서에 협조를 요청하여 데이터를 받아왔는데 생각보다 데이터가 관리가 부실했다. 생활용수와 공업용수에 대한 송수량은 자동으로 측정이 되어 엑셀로 관리되고 있지만, 수위는 저수지에 설치된 눈금자를 눈으로 직접 확인하여 수기로 작성되고 있었다. 강수량에 대한 데이터도 존재했지만 신뢰가 안되는 수치였다. 그 외에도 도면이 없는 저수지의 형태, 주변에서 유입되는 물, 불확실한 기상예보 등 여러 가변적인 요소들을 적용하여 지속가능한 일수를 예측하기란 매우 어려운 상황이었다.&lt;/p&gt;

    &lt;p&gt;그래서 기본적인 통계 수치와 간단한 분류를 통해 차트 및 대시보드를 구성할 수 밖에 없었다. 용수저수지 현황을 나타내는 현재 사용 가능량, 일 평균 소비량, 예상 지속가능 일수를 보여주고, 시계열 분석을 통한 용수저수지 수위 및 상수량 변화를 분석하는 차트들을 구성하고, 최대 소비량 기준, 전년동월 소비량 기준, 절수방안을 적용한 소비량 기준으로 지속가능 일수가 얼마나 되는지를 확인하는 KPI 차트를 만들었다. 그리고 사용자의 입력 값으로 평균 소비량과 수위를 입력 받아 최대 소비량을 기준으로 지속가능 일수를 예측해볼 수 있도록 구성 및 개발하였다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;파이썬 프로그래밍 업무활용 교육&lt;/p&gt;

    &lt;p&gt;용수저수지 수위 관리 대시보드를 개발한 후에 주어진 임무가 딱히 없는 시점에 실장님께서 프로그래밍 교육을 한 번 진행해보라고 하셨다. 여러모로 재밌는 경험이 될 것 같아 수락했는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파이썬 프로그래밍 교육 교관으로 임명하는 인사 발령이 났고&lt;/code&gt;, 종합정비창에서 주로 반복적인 행정 및 사무 업무를 하고 있거나, 파이썬 프로그래밍에 관심 있는 군무원이나 현역간부를 대상으로 파이썬 프로그래밍의 기초부터 활용까지 교육을 진행하게 되었다. 2021년 4월 20일부터 29일까지 파이썬 기초 교육을 6일간 진행하였고, 5월 11일부터 21일까지 pandas를 통한 엑셀 데이터 다루기, beautifulsoup를 통한 정적 크롤링 등 업무 활용 교육을 6일간 진행하였다.&lt;/p&gt;

    &lt;p&gt;평소 개발을 하는 편은 아니어서 커리큘럼을 짜고나서 모르는 내용도 공부를 하면서 교육 자료를 만들었다. 무대공포증이 있어 처음 강사 소개를 하고 개요 챕터를 강의할 때까지만 해도 내심 많이 떨렸지만, 점차 익숙해지고 자신감이 생기기 시작했다. 교육을 받으시는 분들이 연세가 높으시거나 비전공자이신 분들도 상당수 계셔서 쉽지는 않았지만, 교육 경험이 생겼다는 것과 무대 공포증이 있는 내가 병사의 신분으로 간부들을 앞에 앉혀두고 교육을 했다는 점은 좋은 경험이 되었다.&lt;/p&gt;

    &lt;p&gt;모든 교육 일정이 종료되고 교육을 되돌아보니 아쉬운 부분이 많았다. &lt;strong&gt;각 부서에서 어떻게 파이썬을 활용하면 좋을지에 대한 토이 프로젝트를 진행하거나, 성과물을 도출할 수 있는 프로그램을 추가로 만들었으면 부대에도 장기적으로 도움이 되었을 것이고, 교육받으신 분들도 프로그래밍에 어느정도 익숙해질 수 있었을텐데..&lt;/strong&gt; 라는 생각이 머릿 속에 계속 맴돌았지만, 계획은 교육만 진행하는 것이었고 더 이상의 시간이 남아있지 않았기 때문에 연락처만 남겨놓고 교육을 종료하게 되었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2021년 전반기 빅데이터 분석 창 경진대회 최우수&lt;/p&gt;

    &lt;p&gt;빅데이터 분석 창 경진대회는 종합정비창 정보통신실에서 주최하여 부대 내 모든 부서를 대상으로 창의 발전을 위한 과제를 선정하여 빅데이터 분석한 결과를 발표하게 된다. 총 9팀이 출전하게 되었고, 나는 연구소에서 근무하시는 주무관님과 다른 과기병 친구와 함께 연구소 소속으로 참가하였다.&lt;/p&gt;

    &lt;p&gt;우리 팀은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOC 저감을 위한 작업장 폐수 배출시기 최적화 방안&lt;/code&gt; 이라는 주제로 빅데이터 분석을 하게 되었다. 분석 내용을 요약하면 다음과 같다. &lt;strong&gt;물 환경 보전법이 개정&lt;/strong&gt;되어 2022년 1월 1일부로 유기물질에 대한 측정지표가 COD(Chemical Oxygen Demand)에서 TOC(Total Organic Carbon)로 강화되고, 그에 따라 기준치 미충족으로 인한 행정처분이 예상되기 때문에 TOC 배출 데이터를 분석하여 작업장별 최적의 배출시기를 도출하여 시각화를 구현하는 주제로 경진대회에 출전하게 되었다. 나는 여기서 문제점 도출을 위한 데이터 분석과 실제 업무에 적용하기 위한 데이터 시각화 그리고 파이썬을 통한 배출량에 따른 일정 균등분배 알고리즘 구현을 보조하는 역할을 맡았다.&lt;/p&gt;

    &lt;p&gt;약 두 달 동안 분석 및 구현한 내용을 같은 팀 주무관님께서 발표를 해주셨고, &lt;strong&gt;우리 팀이 최우수상을 받아 창장님 상장과 4박 5일의 포상휴가 그리고 팀에 30만원의 부상&lt;/strong&gt;을 받게 되었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;빅데이터 분석 시각화 툴(Qlik Sense) 교육 및 컨설팅 진행&lt;/p&gt;

    &lt;p&gt;2021년에는 빅데이터 분석 창 경진대회를 전반기/후반기 2차례에 걸쳐 경진대회를 진행했었다. 해당 경진대회에 참여하기 위해서는 종합정비창에서 빅데이터 분석 시각화 툴로 사용 중인 Qlik Sense에 대한 교육을 필수로 받아야 한다. 업무를 맡은지 반년 정도밖에 되지 않았지만 그 동안의 개발경험과 전반기 경진대회의 최우수상 이력을 인정받아 후반기 경진대회에 대한 교육을 제의받았고, 이 또한 좋은 경험이라 생각하여 승락했다. 그래서 파이썬 교육 교관에 이어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;빅데이터 분석 툴 교육 교관으로 임명&lt;/code&gt;되었고, &lt;strong&gt;2021년 후반기 빅데이터 분석 창 경진대회의 교육 교관을 맡아 교육 자료 보강 및 교육을 진행하고 9월 초부터 교육 후 각 팀에서 경진대회에 필요한 컨설팅 및 기술 지원&lt;/strong&gt;을 하게 되었다.&lt;/p&gt;

    &lt;p&gt;전반기 때 교육하셨던 같은 부서 주무관님께서 기초 교육자료를 주셨고, 기본적인 차트 이외의 유용한 확장 차트들에 대한 내용과 부대 환경에 맞는 실습 자료를 추가하고, 각 팀에 맞는 과제 내용을 개발할 때 어떻게 해야할지에 대한 일련의 과정을 맛볼 수 있는 세미 프로젝트도 만들어 교육자료를 보강하였다. 내가 최대한 많은 내용을 교육하면 굳이 외부 업체 교육을 안해도 되고 예산이 절감될거라 생각했지만, 이미 업체 교육이 그 해 예산에 잡혀있어 반드시(?) 집행해야 했다. 그래서 &lt;strong&gt;어차피 업체 교육을 진행하는 거라면 예산 아깝게 매번 같은 내용으로 교육하는 것이 아니라 업체 교육의 질도 점차 높여나가는 것이 맞다고 판단하여 이번에 내가 진행하는 교육부터는 기초부터 심화 내용 및 활용까지 내용을 최대한 추가하여 궁극적으로는 경진대회에 참여하는 모든 팀들의 성과물의 퀄리티를 높이고자 했다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;교육은 2주에 걸쳐 1주차에는 월, 수, 금요일, 2주차에는 화, 목요일에 매 차시마다 3시간씩 진행하였다. 별 탈 없이 마지막 강의까지 끝내긴 했지만 내용도 기존보다 많이 추가되어 빠르게 강의를 진행할 수 밖에 없었고, 수강하시는 군무원 분들이 아무래도 현장에서 정비 업무를 하시는 분들이 많이 계셔서 실습을 못 따라오시는 분들이 많으셨다. 그걸 감안해서 전반기 교육보다는 교육 시간을 대폭 늘렸는데도 불구하고 중간중간 준비한 강의를 못한 부분이 아쉬웠다. 그만큼 각 팀에 필요한 컨설팅이나 기술 지원을 열심히 했다.&lt;/p&gt;

    &lt;p&gt;체류분석 기간 분석, 약품소요 주기 최적화, 폐기율 신뢰성 향상, 인젝터 분사량과 엔진출력 관계 분석 등 &lt;strong&gt;각 팀의 다양한 과제들에 대한 데이터 분석 및 시각화를 도와주는 것이 매우 생소하고 신기했다&lt;/strong&gt;. 지금까지 살면서 정비라는 일에 대해 한 번도 생각해본 적도 없었는데, 심지어 군이라는 특수한 조직에서 모든 팀의 기술 지원을 하면서 평소엔 볼 수 없는 장비나 화기들에 대한 정비 업무와 그에 대한 데이터도 다뤄볼 수 있다는 점은 재미있었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;창 정비 및 공정 진행 분석&lt;/p&gt;

    &lt;p&gt;우리 부대의 각 단에서 정비하는 장비 및 부분품에 대한 공정 진행 현황을 한 눈에 파악할 수 있는 화면을 만드는 것이 매년 숙원사업으로 이어져왔다고 한다. 기존에는 지시서번호나 재고번호를 기준으로 정비가 어느 정도 진행되고 있는지, 정비 실적이 어떻게 되는지, 지연되고 있는 공정은 어딘지 등 기존의 정비관리체계 시스템에서는 한 눈에 파악하기가 힘든 상황이었다. 올해도 정통실 과제로 남아있었고, 앞서 언급한 문제들을 빅데이터 시각화를 통해 진행 현황을 쉽게 파악할 수 있도록 담당 주무관님 한 분과 정비시스템을 유지보수하는 업체 분들과 코웍하여 개발하게 되었다. 주무관님은 화면 설계 및 업체분과 소통하여 필요한 쿼리문을 전달해 주시고, 내가 이 쿼리문을 받아 필요에 따라 &lt;strong&gt;쿼리문 수정 및 데이터를 가공하여 Qlik Sense를 통해 시각화 화면을 개발하였다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;연간 창정비 계획에서 현재 어느정도의 창정비가 진행되고 있고 완료되었는지에 대한 총괄적인 내용을 담은 화면, 각 장비 및 지시서번호별로 9단계의 정비 진행현황을 볼 수 있는 화면과 각 장비 및 지시서번호별 상세 공정 진행현황을 볼 수 있는 화면 그리고 공정이 지연되고 있는 장비들의 리스트를 확인할 수 있는 차트와 수리부속 불출예정 정보를 담은 차트를 보여주는 화면으로 구성하였다.&lt;/p&gt;

    &lt;p&gt;개발하면서 수많은 서브쿼리와 조인 그리고 조건들이 달리면서 수 백줄로 길어진 하나의 쿼리문을 보면서 멘붕이 오기도 하고, 수백만의 데이터를 요구사항에 맞게 표현하기 위해 데이터를 이리저리 다루다 보니 데이터를 가공하는 방법들을 익히기도 하고, 디자인이 마음에 안드신다며 반복되는 수정작업으로 디자인 안목이 좋아지기도 하는 등 개인적으로 &lt;strong&gt;정비창에 가장 필요한 부분을 개발함과 동시에 재미도 있었고 많은 것을 얻어갈 수 있었던 과제였다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예산집행 현황&lt;/p&gt;

    &lt;p&gt;지난 해 어떤 부대 평가(?)에서 예산 관련하여 감점을 받았다고 하여 지적 당한 부분을 보완하고자 정통실장님께서 재정과장님께 ‘기존에 엑셀로 관리하던 예산집행 현황을 빅데이터 시각화를 통해 관리하는 것이 어떻냐’라고 하셨는데, 너무 좋은 아이디어라고 하셔서 해당 업무가 나에게 주어지게 되었다. 사실 엑셀로 관리되던 예산집행 현황 데이터를 그대로 가져와 엑셀에서 보여지는 내용 그대로 대시보드 화면을 구성하면 되기 때문에 이번 개발은 너무도 간단했다. 기능적인 부분은 빠르게 개발할 수 있었지만, 디자인적인 요소를 두고 실장님과 나란히 며칠동안 앉아서 이것저것 적용시켜보며 대시보드를 이쁘게 만들었던 기억이 있다.&lt;/p&gt;

    &lt;p&gt;기존의 엑셀에서 보여주던 내용에 더해 디테일한 필터와 차트를 사용하여 시각화하였고, 재정과에서 국군재정단에서 가져온 데이터를 간편하게 최신화할 수 있도록 엑셀 데이터 가공은 최소화 시켜서 화면을 보여줄 수 있도록 개발하였다. 그리고 2021년 예산집행 현황 화면과 2016년부터 5년치 예산집행 현황을 확인할 수 있는 대시보드를 개발하여 과거의 예산집행 현황을 통해 집행률 및 원인행위액이 낮은 부서나 과목들에 대한 분석을 하거나 현재 예산집행 현황을 확인하여 예산집행을 하지 않고 있는 부서를 닦달(?)하는 용도로 사용할 것이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;인사 정보 체계&lt;/p&gt;

    &lt;p&gt;군책임운용기관인 우리 부대의 효율적인 인사관리를 위해 인사정보를 한 눈에 볼 수 있는 화면을 개발해야 하는 과제가 올해 정통실의 과제로 있어 과제 책임자이신 군무원분과 개발을 진행하게 되었다. &lt;strong&gt;부대원들의 민감한 개인정보를 다루는 만큼 인사과 내의 몇몇 인원과 제한된 인원들만이 확인할 수 있도록 개발해야 했다.&lt;/strong&gt; 그렇기때문에 계정을 따로 만들어서 해당 계정에 해당 앱에만 접근할 수 있도록 Security Rule을 작성해주었고, 다른 일반 유저에서는 앱 복사도 되지 않도록 권한을 설정했다.&lt;/p&gt;

    &lt;p&gt;소속, 계급, 직군, 연령, 근속년수 등의 개인정보를 기반으로 인사 정보를 총괄해서 볼 수 있는 메인 대시보드를 만들었고, 추가적으로 인사 자력을 조회할 수 있는 화면과 정년 도달 인원과 한 보직 5년 이상 근속자를 미리 파악할 수 있는 보직 현황 화면 그리고 소속별로 부하율을 파악할 수 있는 화면을 개발하였다. 향후 부대를 소개하거나 부대원들의 능력을 파악하고 TF팀을 구성하는 등 인사 정보를 다양하게 활용할 것이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코로나19 백신 접종 현황&lt;/p&gt;

    &lt;p&gt;22년 1월에 정통실장님께서 코로나가 장기화되면서 앞으로 백신접종이 4차, 5차 그 이후의 접종도 불가피할 수 것 같다고 하시면서 부대원들의 백신 접종 현황을 한 눈에 파악할 수 있는 대시보드를 만들어달라고 하셨다. 내심 이 개발이 꼭 필요한지에 대한 의구심이 들다보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이쯤 되니 별의 별 것을 다 만들어달라 하는구나...&lt;/code&gt; 하고 생각이 들었다. 그런 와중에도 재미있는 미션이 생겼다. 지원과에서 각 소속별로 양식을 뿌려 모든 부대원들의 백신접종 현황 데이터를 받은 것을 취합하여 전달받은 것인데, 엑셀 데이터 중에 백신접종일의 날짜 형식이 완전 가지각색이었다. 예를 들어, 2021.4.30, 21.4.30, 21.04.30, 4.30, 4.30. 4. 30., 4월30일, 04-30 등 정말 상상하지도 못한 정체들의 날짜 형식들이 즐비해있었다. 심지어 어떤 셀에는 텍스트형식, 어떤 셀에는 날짜형식, 어떤 셀에는 숫자형식으로 되어 있는 총체적 난국의 데이터였다. 어떤 식으로 문제를 해결했는지는 따로 포스팅을 만들어 설명할 것이다.&lt;/p&gt;

    &lt;p&gt;날짜 형식을 모두 동일하게 가공하고나서 화면 개발을 시작하였다. 백신 제조사별 접종률과 백신접종 차수별로 부대 총원 중 몇 명이 접종하고 미접종했는지 각각의 수치와 백분율로 환산하여 볼 수 있고, 미접종 인원 리스트를 볼 수 있도록 개발하였다. 그리고 질병관리청에서 제조사별로 권고 접종 간격일을 제공해주는데, 백신접종을 희망하는 사람들의 차기 백신 접종일을 확인할 수 있도록 하였다. 개발한 대시보드는 차후 어떻게 사용될지 잘 모르겠지만 이 백신 접종 현황 대시보드가 전역전에 Qlik Sense로 개발한 마지막 프로젝트가 되었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;전역 전 남는 시간은 70페이지 가량의 인수인계서를 작성하여 들어온지 한달도 채 되지않은 내 부사수를 교육하고, 친한 주무관님과 사무관님의 요청으로 Qlik Sense로 분석할 수 있도록 n년치 데이터를 가공해주는 프로그램을 개발하거나 새로고침을 하지 않더라도 크롤링하여 새로운 글이 올라오면 자동으로 알람을 띄워주는 프로그램을 개발해주는 등 나를 필요로하는 분들에게 도움이 되기 위해 노력하고 몸 건강히 군 생활을 마치게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Sep 2022 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/anything/2022/09/07/army.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/anything/2022/09/07/army.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>anything</category>
        
        <category>army</category>
        
        <category>acmd</category>
        
        <category>bi</category>
        
        
        <category>Anything</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - SAST 분석 및 활용</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. DevSecOps 툴체인 보안 점검 리스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. SANS DevSecOps Best Practice&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Pre-Commit 단계&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. Commit 단계&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. SAST(Static Application Security Testing) 적용&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. OWASP Dependency Check&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. SpotBugs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. CheckStyle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_4&quot;&gt;   2.4. PMD(Programing Mistake Detector)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_5&quot;&gt;   2.5. SonarQube&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_6&quot;&gt;   2.6. Anchore&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-devsecops-툴체인-보안-점검-리스트---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. DevSecOps 툴체인 보안 점검 리스트&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SANS DevSecOps Best Practice&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SANS 연구소(SANS Institute)는 교육에서 보안 인증 정보 소스를 보유하고 있으며 사이버 및 네트워크 방어, 침투 테스트, 사고 대응, 디지털 포렌식 등 보안 교육에 있어 국제적으로 가장 높은 신뢰를 받는 보안 기관이다.&lt;/p&gt;

    &lt;p&gt;이러한 SANS 연구소에서 DevSecOps 도구들을 분류 및 정리하여 발표한 &lt;a href=&quot;http://sans.org/u/zAi&quot;&gt;Secure DevOps Toolchain and SWAT checklist&lt;/a&gt; 자료를 토대로 DevSecOps 파이프라인에서 정적 분석할 도구를 선정할 것이다.&lt;/p&gt;

    &lt;p&gt;도구 선정은 앞선 포스팅을 통해 구축된 DevOps 파이프라인에 쉽게 연결할 수 있고, 자동화되어 정적 분석 및 동적 분석을 수행할 수 있는 보안 도구를 선택했다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pre-Commit 단계&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;먼저 DevSecOps 파이프라인의 첫 번째 단계인 Pre-Commit 단계에서는 개발자가 코드를 GitLab과 같은 SCM에 Commit 되기 전에 완료해야하는 단계이다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 1]은 SANS 연구소에서 정리한 Pre-Commit 단계에서 사용할 수 있는 보안 도구들을 정리한 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_1.png&quot; alt=&quot;pre_commit_security_tool&quot; width=&quot;758&quot; height=&quot;273&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Pre-Commit 단계의 보안 도구&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Pre-Commit 단계는 VSCode와 같은 IDE(Integrated Development Environment)에 보안 도구들을 플러그인으로 추가하여 개발자가 코드를 작성 및 실행하면서 보안을 검사한다.&lt;/p&gt;

    &lt;p&gt;앞선 포스팅에서 구성한 DevOps 파이프라인은 GitLab에 푸시하는 이벤트로 인해 실행되는데, Pre-Commit 단계는 푸시 이전에 수행되는 작업이기 때문에 DevSecOps 파이프라인에 추가할 도구는 없다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Commit 단계&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 코드를 컴파일하고 빌드하는 과정에서 정적 분석을 수행해야 하는 Commit 단계이다.&lt;/p&gt;

    &lt;p&gt;[그림 2]는 SANS 연구소에서 정리한 Commit 단계에서 사용할 수 있는 보안 도구들을 정리한 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_2.png&quot; alt=&quot;commit_security_tool&quot; width=&quot;714&quot; height=&quot;308&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Commit 단계의 보안 도구&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Commit 단계는 빌드하고 테스트하는 과정에서 파이프라인의 보안 취약점을 찾기 위해 소스 코드 파일들을 스캔한다.&lt;/p&gt;

    &lt;p&gt;검사할 소스 코드의 언어에 따라 사용되는 도구들은 달라질 수 있다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 Java 기반의 웹 서비스에 보안을 적용해볼 것이고, 정적 분석에 사용할 도구들은 다음과 같다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;OWASP Dependency Check&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;프로젝트의 종속성을 검사&lt;/strong&gt;하고, 공개적으로 공개 된 취약점을 탐지하는 소프트웨어 구성 분석 도구이다.&lt;/p&gt;

        &lt;p&gt;지정된 종속성에 대한 CPE(Common Platform Enumeration) 식별자가 있는지를 확인하고, 발견되면 관련 CVE 항목에 연결되는 보고서를 생성해준다.&lt;/p&gt;

        &lt;p&gt;Jenkins와 Maven 플러그인이 존재하여 연동하기 쉽다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SpotBugs&lt;/p&gt;

        &lt;p&gt;정적 분석 도구로 사용되는 FindBugs가 이제는 &lt;strong&gt;SpotBugs&lt;/strong&gt;로 바뀌어 사용되고 있다.&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;관련 내용은 &lt;a href=&quot;https://github.com/findbugsproject/findbugs/blob/master/README.md&quot;&gt;FindBugs README&lt;/a&gt;에서 확인 가능&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;&lt;strong&gt;제한된 룰 셋(Rule Set)으로 정적 분석을 수행하여 결함을 확인&lt;/strong&gt;하고 생성된 보고서를 확인할 수 있다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CheckStyle&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;코딩 스타일 규칙을 정의하여 체크&lt;/strong&gt;해줌으로써 코딩 스타일 통일할 수 있도록 도와준다.&lt;/p&gt;

        &lt;p&gt;프로젝트 완료 후 유지보수할 떄 생겨나는 많은 문제중 하나가 많은 프로그래머들이 각자의 취향에 따라 변수명, 메소드명, 작성법등이 다르기 때문에 문제가 발생할 수 있는데 이러한 문제를 해결하기 위해 만들어졌다.&lt;/p&gt;

        &lt;p&gt;[그림 2]에 보이는 SANS 연구소의 자료에는 CheckStyle이 없지만 SpotBugs와 더불어 PMD와도 같이 정적 분석 도구로 많이 쓰이고 있어 사용해보았다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;PMD(Programing Mistake Detector)&lt;/p&gt;

        &lt;p&gt;SpotBugs와 마찬가지로 응용 프로그램에서 &lt;strong&gt;Java 소스를 정적 분석&lt;/strong&gt;하여 발견된 문제를 보고해준다.&lt;/p&gt;

        &lt;p&gt;기본적으로 제공되는 룰 셋(Rule Set)이 포함되어 있으며 사용자 지정 규칙을 작성할 수도 있다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SonarQube&lt;/p&gt;

        &lt;p&gt;SonarQube는 20개 이상의 프로그래밍 언어에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bugs, Code Smell, 보안 취약점을 발견할 목적&lt;/code&gt;으로 정적 코드 분석으로 자동 리뷰를 수행하기 위한 지속적인 코드 품질 검사용 오픈 소스 플랫폼이다.&lt;/p&gt;

        &lt;p&gt;SonarQube는 자체 분석기로 모든 규칙을 다룰 수 있다고 가정하지만 SonarQube에서 다루지 않는 Findbugs, PMD 또는 CheckStyle의 규칙이 여전히 있다.&lt;/p&gt;

        &lt;p&gt;SonarQube 자체로도 좋지만 PMD/Findbugs/Checkstyle을 별도로 사용하고 Jenkins CI에서 가시적으로 볼 수 있도록 해주는 Analysis Collector 플러그인을 사용할 수도 있다.&lt;/p&gt;

        &lt;p&gt;이것의 장점은 PMD/Findbugs/Checkstyle 구성을 SCM에 체크인하고 별도의 Sonar 서버에 의존하지 않고 Maven 빌드에 통합 할 수 있다는 것이다.&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;오래된 라이브러리(예: Java 8의 경우)를 수정하거나 업그레이드 혹은 대기하는 데 시간을 소비하게 되기 때문에 SonarQube는 현재 PMD, Checkstyle 및 Findbug를 폐기하고 자체 기술을 사용하여 &lt;a href=&quot;https://redirect.sonarsource.com/plugins/java.html&quot;&gt;SonarJava&lt;/a&gt;를 분석 및 개발하는 중이라고 함 
또한 &lt;a href=&quot;http://www.sonarlint.org/index.html&quot;&gt;SonarLint&lt;/a&gt; 라는 개인 IDE 용 새 플러그인이 존재&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;SonarQube에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;품질 프로파일(Quality Profiles)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;품질 게이트(Quality Gates)&lt;/code&gt;라는 정책이 존재한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;품질 프로파일(Quality Profiles)&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;코드를 분석하기 위한 룰(Rule)의 집합이다.&lt;/p&gt;

            &lt;p&gt;각 언어마다 다른 품질 프로파일들이 존재한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;품질 게이트(Quality Gates)&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;프로젝트 지표들로 설정된 임계 값을 정한다.&lt;/p&gt;

            &lt;p&gt;품질 게이트를 통과하기 위해서는 모든 임계값 조건을 통과해야 한다.&lt;/p&gt;

            &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Anchore&lt;/p&gt;

        &lt;p&gt;Anchore는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨테이너 이미지 스캐닝 도구&lt;/code&gt;이다.&lt;/p&gt;

        &lt;p&gt;컨테이너 이미지를 빌드할 때마다 알려진 보안 취약점을 스캔해서 보안적인 문제가 없는지 분석한다.&lt;/p&gt;

        &lt;p&gt;상업 버전도 존재하지만 오픈 소스 버전이 있어 손쉽게 사용이 가능하다.&lt;/p&gt;

        &lt;p&gt;Anchore는 기본적으로 &lt;strong&gt;보안 CVE(Common Vulnerabilities and Exposures) 목록을 기반으로 해서 스캔&lt;/strong&gt;하고, NPM과 루비젬에 대한 보안 취약점 피드도 가져온다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-saststatic-application-security-testing-적용---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. SAST(Static Application Security Testing) 적용&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OWASP Dependency Check&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins 파이프라인에서 OWASP Dependency Check를 수행하기 위해 Jenkins 인스턴스에 OWASP Dependency Check를 설치하고 실행할 수 있는 환경을 만들어준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget https://dl.bintray.com/jeremy-long/owasp/dependency-check-5.2.4-release.zip
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;unzip dependency-check-5.2.4-release.zip
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mv &lt;/span&gt;dependency-check/ /var/lib/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;dependency-check를 다운 받아 unzip하여 Jenkins의 홈디렉토리로 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/jenkins&lt;/code&gt; 디렉토리로 옮겨준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;/var/lib/jenkins/dependency-check/bin/dependency-check.sh &lt;span class=&quot;nt&quot;&gt;--scan&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--format&lt;/span&gt; HTML &lt;span class=&quot;nt&quot;&gt;--out&lt;/span&gt; /var/lib/jenkins/reports/dependency-check-report &lt;span class=&quot;nt&quot;&gt;--prettyPrint&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;스캔할 소스 코드가 들어있는 프로젝트 디렉토리에서 실행 dependency-check를 실행한다.&lt;/p&gt;

    &lt;p&gt;–scan 옵션에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwd&lt;/code&gt; 명령을 통해 얻은 프로젝트 디렉토리가 들어가야하며, –out 옵션의 값에 해당하는 디렉토리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/jenkins/reports/dependency-check-report&lt;/code&gt;애 스캔하여 출력되는 보고서 파일이 저장된다.&lt;/p&gt;

    &lt;p&gt;–format 옵션에 들어가는 값은 HTML, XML, JSON이 존재하는데, 여기서는 dependecy-chcek 결과를 SonarQube에서도 확인할 수 있도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 파일로 보고서가 생성되도록 했다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;참고: 스캔 중에 odc.mv.db 관련 에러가 발생한 적이 있는데, $ /var/lib/jenkins/dependency-check/bin/dependency-check.sh –purge 명령을 통해 해결됨&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SpotBugs&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Maven에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt; 이라는 빌드 파일을 사용하여 빌드 정보를 기술한다.&lt;/p&gt;

    &lt;p&gt;pom.xml 파일에 SpotBugs를 사용하도록 명시하여 프로젝트를 빌드할 때 SpotBugs를 통해 정적 분석을 진행할 수 있도록 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;plugin&amp;gt;
      &amp;lt;groupId&amp;gt;com.github.spotbugs&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spotbugs-maven-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.1.12.2&amp;lt;/version&amp;gt;
      &amp;lt;configuration&amp;gt;
          &amp;lt;effort&amp;gt;Max&amp;lt;/effort&amp;gt;
          &amp;lt;threshold&amp;gt;Low&amp;lt;/threshold&amp;gt;
          &amp;lt;failOnError&amp;gt;true&amp;lt;/failOnError&amp;gt;
          &amp;lt;plugins&amp;gt;
              &amp;lt;plugin&amp;gt;
                  &amp;lt;groupId&amp;gt;com.h3xstream.findsecbugs&amp;lt;/groupId&amp;gt;
                  &amp;lt;artifactId&amp;gt;findsecbugs-plugin&amp;lt;/artifactId&amp;gt;
                  &amp;lt;version&amp;gt;1.10.1&amp;lt;/version&amp;gt;
              &amp;lt;/plugin&amp;gt;
          &amp;lt;/plugins&amp;gt;
      &amp;lt;/configuration&amp;gt;
      &amp;lt;executions&amp;gt;
          &amp;lt;execution&amp;gt;
              &amp;lt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;scan&amp;lt;/id&amp;gt;
              &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt;
              &amp;lt;goals&amp;gt;
                  &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
              &amp;lt;/goals&amp;gt;
          &amp;lt;/execution&amp;gt;
      &amp;lt;/executions&amp;gt;
  &amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CheckStyle&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SpotBugs와 마찬가지로 pom.xml 파일에 CheckStyle을 사용하도록 명시하여 프로젝트를 빌드할 때 CheckStyle을 통해 정적 분석을 진행할 수 있도록 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;plugin&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-checkstyle-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.17&amp;lt;/version&amp;gt;
      &amp;lt;executions&amp;gt;
          &amp;lt;execution&amp;gt;
              &amp;lt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;validate&amp;lt;/id&amp;gt;
              &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;configLocation&amp;gt;google_checks.xml&amp;lt;/configLocation&amp;gt;
                  &amp;lt;suppressionsLocation&amp;gt;suppressions.xml
                  &amp;lt;/suppressionsLocation&amp;gt;
                  &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                  &amp;lt;failsOnError&amp;gt;true&amp;lt;/failsOnError&amp;gt;
                  &amp;lt;consoleOutput&amp;gt;true&amp;lt;/consoleOutput&amp;gt;
                  &amp;lt;includeTestSourceDirectory&amp;gt;true
                  &amp;lt;/includeTestSourceDirectory&amp;gt;
              &amp;lt;/configuration&amp;gt;
              &amp;lt;goals&amp;gt;
                  &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
              &amp;lt;/goals&amp;gt;
          &amp;lt;/execution&amp;gt;
      &amp;lt;/executions&amp;gt;
  &amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PMD(Programing Mistake Detector)&lt;/strong&gt;   &lt;a name=&quot;list2_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;OMD 또한 pom.xml 파일에 PMD를 사용하도록 명시하여 프로젝트를 빌드할 때 PMD를 통해 정적 분석을 진행할 수 있도록 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;plugin&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-pmd-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.13.0&amp;lt;/version&amp;gt;
      &amp;lt;executions&amp;gt;
          &amp;lt;execution&amp;gt;
              &amp;lt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;pmd-scan&amp;lt;/id&amp;gt;
              &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt;
              &amp;lt;goals&amp;gt;
                  &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
              &amp;lt;/goals&amp;gt;
          &amp;lt;/execution&amp;gt;
      &amp;lt;/executions&amp;gt;
  &amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SonarQube&lt;/strong&gt;   &lt;a name=&quot;list2_5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SonarQube를 사용하기 위해서 여러 가지 방법으로 설치할 수 있지만 본 프로젝트에서는 Docker를 통해서 설치하는 방법을 설명할 것이다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;--restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;always &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 9000:9000 &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 9092:9092 &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; sonarqube sonarqube
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Jenkins 인스턴스에서 Docker 명령을 통해 sonarqube 공식 이미지를 다운로드하여 9000번 포트를 사용하도록 설정한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim /usr/local/maven/conf/settings.xml
  &amp;lt;settings&amp;gt;
      &amp;lt;pluginGroups&amp;gt;
          &amp;lt;pluginGroup&amp;gt;org.sonarsource.scanner.maven&amp;lt;/pluginGroup&amp;gt;
      &amp;lt;/pluginGroups&amp;gt;
      &amp;lt;profiles&amp;gt;
          &amp;lt;profile&amp;gt;
              &amp;lt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;sonar&amp;lt;/id&amp;gt;
              &amp;lt;activation&amp;gt;
                  &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
              &amp;lt;/activation&amp;gt;
              &amp;lt;properties&amp;gt;
                  &amp;lt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Optional URL to server. Default value is http://localhost:9000 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
                  &amp;lt;sonar.host.url&amp;gt;
                  http://JENKINS_SERVER_IP:9000
                  &amp;lt;/sonar.host.url&amp;gt;
              &amp;lt;/properties&amp;gt;
          &amp;lt;/profile&amp;gt;
      &amp;lt;/profiles&amp;gt;
  &amp;lt;/settings&amp;gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mvn clean verify sonar:sonar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;그리고 위와 같이 maven 설정 파일에서 SonarQube 플러그인에 대해 설정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn clean verify&lt;/code&gt; 명령을 통해 빌드할 때 SonarQube가 정상적으로 동작하는지 확인해본다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 SonarQube가 실행되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create New Project&lt;/code&gt; 버튼을 누르면 다음 [그림 3]과 같은 화면이 나온다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_3.png&quot; alt=&quot;create_sonarqube&quot; width=&quot;658&quot; height=&quot;388&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] SonarQube 프로젝트 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Project key와 Display name을 입력한 후 Set Up 버튼을 눌러 프로젝트를 생성한다.&lt;/p&gt;

    &lt;p&gt;프로젝트가 정상적으로 생성되었다면 토큰을 생성한다.&lt;/p&gt;

    &lt;p&gt;Provide a token에 임의의 키를 입력한 후에 Generate를 클릭하면 다음 [그림 4]와 같이 토큰 키가 생성된다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_4.png&quot; alt=&quot;create_sonarqube_token&quot; width=&quot;516&quot; height=&quot;353&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] SonarQube 프로젝트의 토큰 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;생성된 토큰은 Jenkins와 SonarQube를 연동하여 파이프라인에서 활용하기 위해 사용된다.&lt;/p&gt;

    &lt;p&gt;아래에는 다음 [그림 5]와 같이 Run analysis on your project 항목이 있는데, 해당 프로젝트에서 분석할 애플리케이션의 언어와 빌드 도구를 선택하면 SonarQube 분석을 실행시킬 수 있는 명령어가 나온다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_5.png&quot; alt=&quot;sonarqube_project_configuration&quot; width=&quot;870&quot; height=&quot;432&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] SonarQube 프로젝트 설정 및 실행 방법&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 [그림 6]과 같이 Jenkins에서 SonarQube credentials을 생성한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_6.png&quot; alt=&quot;jenkins_sonarqube_credentials&quot; width=&quot;497&quot; height=&quot;286&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] Jenkins에서 SonarQube credentials 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그리고 다음 [그림 7]과 같이 Jenkins와 연동하기 위해 SonarQube에서 웹훅을 생성하고 설정한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_7.png&quot; alt=&quot;create_sonarqube_webhook&quot; width=&quot;408&quot; height=&quot;462&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] SonarQube 웹훅 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이렇게 설정된 웹훅은 Jenkins에서 요청이 오면 정적 분석에 대한 결과를 Jenkins QualifyGate에 응답하게 된다.&lt;/p&gt;

    &lt;p&gt;다음으로 [그림 8]과 같이 Jenkins에서 SonarQube 서버를 연동하기 위한 설정을 진행한다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins 관리 &amp;gt; 시스템 설정에서 SonarQube Servers&lt;/code&gt;가 없으면 Sonar Quality Gates 플러그인을 설치해야 함&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_8.png&quot; alt=&quot;jenkins_sonarqube_server_configuration&quot; width=&quot;914&quot; height=&quot;353&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] Jenkins에서 SonarQube 서버 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;[그림 6]에서 생성했었던 Token을 선택하고 SonarQube Server URL을 설정한다.&lt;/p&gt;

    &lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins 관리 &amp;gt; Global Tool Configuration에서 SonarQube Scanner&lt;/code&gt;에서 다음 [그림 9]와 같이 구성한다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Install automatically를 체크하면 SonarQube Scanner가 자동으로 설치하도록 구성&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_9.png&quot; alt=&quot;jenkins_sonarqube_scanner_configuration&quot; width=&quot;909&quot; height=&quot;425&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] Jenkins에서 SonarQube 스캐너 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기까지 정상적으로 설정되었다면 Jenkins Pipeline에 SonarQube를 활용할 수 있는 환경이 모두 갖춰진 것이다.&lt;/p&gt;

    &lt;p&gt;추가적으로 Jenkins에서 SonarQube로 분석한 결과 파일을 가져올 수 있도록 CheckStyle, PMD, SpotBugs와 Dependency-Check 각각의 분석 결과 파일의 경로를 설정해보겠다.&lt;/p&gt;

    &lt;p&gt;먼저 Dependency-Check는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;환경설정 &amp;gt; 프로젝트 설정 &amp;gt; Dependency-Check&lt;/code&gt; 탭에 들어가서 설정한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_10.png&quot; alt=&quot;sonarqube_dependency_check_configuration&quot; width=&quot;918&quot; height=&quot;667&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] SonarQube에서 Dependency-Check 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Dependency-Check는 HTML, JSON, XML 세 가지 파일 형식으로 결과를 도출할 수 있는데, 각 파일에 대한 저장하고 싶은 Path를 입력하면 된다.&lt;/p&gt;

    &lt;p&gt;다음으로 CheckStyle, PMD, SpotBug는 Dependency-Check 탭 바로 아래의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;External Analyzers&lt;/code&gt; 탭에서 설정한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_11.png&quot; alt=&quot;sonarqube_external_analyzers_configuration&quot; width=&quot;930&quot; height=&quot;714&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] SonarQube에서 External Analyzers 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;CheckStyle, PMD, SpotBug도 마찬가지로 각 툴에서 도출된 결과 레포트 파일을 어느 경로에 저장할 것인지를 명시해준다.&lt;/p&gt;

    &lt;p&gt;각 툴에 대한 경로 설정이 정상적으로 끝났다면 Quality Profiles를 설정해보자.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_12.png&quot; alt=&quot;sonarqube_quality_profile&quot; width=&quot;886&quot; height=&quot;638&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] SonarQube 품질 프로파일 구성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Quality Profiles은 SonarQube에서 분석할 때 적용할 Rule을 설정할 수 있다.&lt;/p&gt;

    &lt;p&gt;기본적으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEFAULT&lt;/code&gt;라고 되어있는 &lt;strong&gt;Sonar way&lt;/strong&gt; Profile로 분석을 하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILT-IN&lt;/code&gt; 되어 있는 Rule을 모두 분석해보기 위해 &lt;strong&gt;My way&lt;/strong&gt;라는 Profile을 만들어 하위 Profile로 다른 Profile을 배치(?)한 후에 My way Profile의 오른쪽 톱니바퀴를 눌러 Set as Default를 설정해주었다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;젠장.. Jenkins에서 SonarQube 연동하여 Pipeline 실행시킨 스크린샷이 어디갔지 -_-;;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Anchore&lt;/strong&gt;   &lt;a name=&quot;list2_6&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음 Jenkins에 연동핳 정적 분석 도구인 Anchore를 살펴보겠다.&lt;/p&gt;

    &lt;p&gt;Anchore는 컨테이너 이미지의 검사, 분석 및 인증을 위한 중앙 집중식 서비스를 제공하는 오픈 소스 프로젝트이다.&lt;/p&gt;

    &lt;p&gt;GEM, Java Archive (jar, war, ear), NPM, Python 패키지가 제공되며, 특히 Jenkins 플러그인을 통해 연동이 가능하다.&lt;/p&gt;

    &lt;p&gt;우선 Kubernetes 및 Helm을 활용하여 Anchore 서버를 구성해보자.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  crisis51526@cloudshell:~ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace anchore
  nameanchore created

  crisis51526@cloudshell:~ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add anchore https://charts.anchore.io
  &lt;span class=&quot;s2&quot;&gt;&quot;anchore&quot;&lt;/span&gt; has been added to your repositories
  crisis51526@cloudshell:~ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;anchore anchore/anchore-engine &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; anchore
  NAME: anchore
  LAST DEPLOYED: Sat Oct 20 18:06:18 2020
  NAMESPACE: anchore
  STATUS: deployed
  REVISION: 1
  TEST SUITE: None
  NOTES:
  To use Anchore Engine you need the URL, username, and password to access the API.

  Anchore Engine can be accessed via port 8228 on the following DNS name from within the cluster:
  anchore-anchore-engine-api.anchore.svc.cluster.local

  Here are the steps to configure the anchore-cli &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;anchorecli&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Use these same values &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;direct API access as well.

  To configure your anchore-cli run:

      &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;admin
      &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get secret &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; anchore anchore-anchore-engine &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{.data.ANCHORE_ADMIN_PASSWORD}&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;base64&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;

  Using the service endpoint from within the cluster you can use:
      &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://anchore-anchore-engine-api.anchore.svc.cluster.local:8228/v1/


  To verify the service is up and running, you can run container &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Anchore Engine CLI:

      kubectl run &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--tty&lt;/span&gt; anchore-cli &lt;span class=&quot;nt&quot;&gt;--restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Always &lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt; anchore/engine-cli  &lt;span class=&quot;nt&quot;&gt;--env&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;admin &lt;span class=&quot;nt&quot;&gt;--env&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--env&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://anchore-anchore-engine-api.anchore.svc.cluster.local:8228/v1/

  from within the container you can use &lt;span class=&quot;s1&quot;&gt;&apos;anchore-cli&apos;&lt;/span&gt; commands.

  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; NOTE: On first startup of anchore-engine, it performs a CVE data &lt;span class=&quot;nb&quot;&gt;sync &lt;/span&gt;which may take several minutes to complete. During this &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;the system status will report &lt;span class=&quot;s1&quot;&gt;&apos;partially_down&apos;&lt;/span&gt; and any images added &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;analysis will stay &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the &lt;span class=&quot;s1&quot;&gt;&apos;not_analyzed&apos;&lt;/span&gt; state.
  Once the &lt;span class=&quot;nb&quot;&gt;sync &lt;/span&gt;is &lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt;, any queued images will be analyzed and the system status will change to &lt;span class=&quot;s1&quot;&gt;&apos;all_up&apos;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

  Initial setup &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;can be &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;120sec &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;postgresql setup and readiness checks to pass &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the services as indicated by pod state. You can check with:
      kubectl get pods &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;anchore-anchore-engine,component&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;api

  A quick primer on using the Anchore Engine CLI follows. For more info see: https://github.com/anchore/anchore-engine/wiki/Getting-Started

  View system status:

      anchore-cli system status

  Add an image to be analyzed:

      anchore-cli image add &amp;lt;imageref&amp;gt;

  List images and see the analysis status &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;not_analyzed initially&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

      anchore-cli image list

  Once the image is analyzed you&lt;span class=&quot;s1&quot;&gt;&apos;ll see status change to &apos;&lt;/span&gt;analyzed&lt;span class=&quot;s1&quot;&gt;&apos;. This may take some time on first execution with a new database because
  the system must first do a CVE data sync which can take several minutes. Once complete, the image will transition to &apos;&lt;/span&gt;analyzing&lt;span class=&quot;s1&quot;&gt;&apos; state.

  When the image reaches &apos;&lt;/span&gt;analyzed&lt;span class=&quot;s1&quot;&gt;&apos; state, you can view policy evaluation output with:

      anchore-cli evaluate check &amp;lt;imageref&amp;gt;

  List CVEs found in the image with:

      anchore-cli image vuln &amp;lt;imageref&amp;gt; os

  List OS packages found in the image with:
      anchore-cli image content &amp;lt;imageref&amp;gt; os

  List files found in the image with:
      anchore-cli image content &amp;lt;imageref&amp;gt; files
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Anchore Engine이 정상적으로 배포되었다면 pip를 통해 anchore-cli 패키지를 설치하고, anchore 컨테이너에 전달 된 secret에 액세스하여 kubernetes에서 비밀번호를 검색한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; epel-release
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; python-pip
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;anchorecli
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;admin
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;foobar
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://ANCHORE_IP:30228/v1

  crisis51526@cloudshell:~/anchore-engine &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get secret &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; anchore anchore-anchore-engine &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{.data.ANCHORE_ADMIN_PASSWORD}&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;base64&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
  crisis51526@cloudshell:~/anchore-engine &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ANCHORE_CLI_PASS&lt;/span&gt;
  foobar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Jenkins Pipeline에서 실행해보기 전에 anchore-cli 명령을 통해 앞서 컨테이너 이미지 검사가 정상적으로 이루어지는지 테스트 해보겠다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  crisis51526@cloudshell:~/anchore-engine &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim anchore-nodeport.yaml
  apiVersion: v1
  kind: Service
  metadata:
  name: anchore-api
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app: anchore-anchore-engine
      component: api
  ports:
      - protocol: TCP
      port: 8228
      targetPort: 8228
      nodePort: 30228

  crisis51526@cloudshell:~/anchore-engine &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-nov2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; anchore-nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; anchore
  service/anchore-api created

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@jenkins cccr-dvwa]# anchore-cli image add jisunpark/cccr-dvwa-java-web &lt;span class=&quot;nt&quot;&gt;--dockerfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Dockerfile &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt;
  Image Digest: sha256:fec038ff428898223fc9fb516caedbf52c4572f2e491590d8f5647e8e5d787c9
  Parent Digest: sha256:fec038ff428898223fc9fb516caedbf52c4572f2e491590d8f5647e8e5d787c9
  Analysis Status: not_analyzed
  Image Type: docker
  Analyzed At: 2020-10-20T18:43:29Z
  Image ID: 85a4a0ea97867479bcb328c7a6c75691434d36ea0a0b75e6e453b22ff0f6fc7d
  Dockerfile Mode: Actual
  Distro: debian
  Distro Version: 10
  Size: 920176640
  Architecture: amd64
  Layer Count: 16

  Full Tag: docker.io/jisunpark/cccr-dvwa-java-web:latest
  Tag Detected At: 2020-10-20T18:40:33Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;jisunpark/cccr-dvwa-java-web&lt;/strong&gt;라는 테스트용 이미지는 DVJA(Damn Vulnerable Java Application)를 사용했다.&lt;/p&gt;

    &lt;p&gt;DVWA(Damn Vulnerable Web Application)는 취약점이 많은 웹 애플리케이션을 모의해킹 및 실습 용도로 PHP와 MySQL을 사용하여 만들어진 것이고, DVJA는 Java로 만들어진 웹 애플리케이션이다.&lt;/p&gt;

    &lt;p&gt;https://github.com/appsecco/dvja&lt;/p&gt;

    &lt;p&gt;위의 git을 클론하여 DVJA 도커 이미지를 helm으로 배포할 수 있도록 개발하여 실습을 진행했다.&lt;/p&gt;

    &lt;p&gt;최종적으로 정적 분석 도구들을 Jenkins에 연동하여 Pipeline 코드를 작성한 내용은 다음과 같다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  properties&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;
      parameters&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;
          string&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: &lt;span class=&quot;s1&quot;&gt;&apos;sonar.projectKey&apos;&lt;/span&gt;, defaultValue: &lt;span class=&quot;s1&quot;&gt;&apos;cccr-dvwa&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
          string&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: &lt;span class=&quot;s1&quot;&gt;&apos;sonar.host.url&apos;&lt;/span&gt;, defaultValue: &lt;span class=&quot;s1&quot;&gt;&apos;http://JENKINS_SERVER_IP:9000&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
          string&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: &lt;span class=&quot;s1&quot;&gt;&apos;sonar.login&apos;&lt;/span&gt;, defaultValue: &lt;span class=&quot;s1&quot;&gt;&apos;265c24760ec4f5cf1f28b87981c7bbe55c3bdffc&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
      &lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          SLACK_CHANNEL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;#send-slack-message-from-jenkins&apos;&lt;/span&gt;
          REGISTRY &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;crisis513/cccr-dvwa-java-web&apos;&lt;/span&gt; 
          REGISTRYCREDENTIAL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;dockerhub&apos;&lt;/span&gt; 
          DOCKER_IMAGE &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      agent any
      tools &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
          maven &lt;span class=&quot;s1&quot;&gt;&apos;mvn&apos;&lt;/span&gt; 
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Git clone&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s1&quot;&gt;&apos;https://github.com/JisunParkRea/cccr-dvwa.git&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Docker image build and push to Dockerhub&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              steps&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      DOCKER_IMAGE &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;, REGISTRYCREDENTIAL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          DOCKER_IMAGE.push&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;latest&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Anchore Analysis&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s1&quot;&gt;&apos;echo &quot;$REGISTRY:latest `pwd`/Dockerfile&quot; &amp;gt; anchore_images&apos;&lt;/span&gt;
                  anchore name: &lt;span class=&quot;s1&quot;&gt;&apos;anchore_images&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Clean local docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              agent any
                  steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
                  sh &lt;span class=&quot;s1&quot;&gt;&apos;docker rmi $REGISTRY:latest&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Static Analysis(PMD, SpotBugs, CheckStyle)&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s1&quot;&gt;&apos;mvn pmd:pmd spotbugs:spotbugs checkstyle:checkstyle&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Dependency-Check Analysis&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s1&quot;&gt;&apos;/var/lib/jenkins/dependency-check/bin/dependency-check.sh --scan `pwd` --format HTML --out /var/lib/jenkins/reports/dependency-check-report --prettyPrint&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Sonarqube and Quality gate&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              options &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;: 5, unit: &lt;span class=&quot;s1&quot;&gt;&apos;MINUTES&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                  retry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  withSonarQubeEnv&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;SonarQube Server&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      sh &lt;span class=&quot;s2&quot;&gt;&quot;mvn sonar:sonar&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      qualitygate &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; waitForQualityGate&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;qualitygate.status &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;OK&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          currentBuild.result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;FAILURE&quot;&lt;/span&gt;
                          slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: &lt;span class=&quot;nv&quot;&gt;$SLACK_CHANNEL&lt;/span&gt;, color: &lt;span class=&quot;s1&quot;&gt;&apos;#F01717&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$JOB_NAME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;*, &amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$BUILD_URL&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;|Build #&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      post &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
          success &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: &lt;span class=&quot;nv&quot;&gt;$SLACK_CHANNEL&lt;/span&gt;, color: &lt;span class=&quot;s1&quot;&gt;&apos;#00FF00&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;SUCCESSFUL: Job &apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&apos; (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          failure &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: &lt;span class=&quot;nv&quot;&gt;$SLACK_CHANNEL&lt;/span&gt;, color: &lt;span class=&quot;s1&quot;&gt;&apos;#F01717&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;FAILURE: &apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&apos; (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;일련의 과정을 정리하면 다음과 같다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;코드를 Git에 Push하면 Jenkins에서 웹훅을 받아 파이프라인이 자동으로 실행&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;웹훅을 받은 Git 레포지토리를 Clone&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;해당 Git에 업데이트된 코드를 기반으로 Docker 이미지를 빌드하고 지정된 Docker hub로 Push&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;빌드된 이미지를 Anchore로 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도커 이미지를 제거 후 SpotBugs, PMD, CheckStyle, Dependency-Check 도구를 통해 코드 정적 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그리고 SonarQube에서 설정한 Quality Profiles의 Rule을 바탕으로 정적 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;해당 파이프라인의 성공 여부를 Slack 메시지로 전달&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;해당 파이프라인을 실행시키면 다음 [그림 13]과 같이 정상적으로 파이프라인이 실행된 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_6_13.png&quot; alt=&quot;anchore_test&quot; width=&quot;819&quot; height=&quot;342&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] Jenkins 정적 분석도구 파이프라인 테스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;왜 [그림 13]에 SonarQube stage는 없는 것인가… 분명 성공했었는데 스샷을 못남긴 듯 하다 ㅠㅠㅠ&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;아무튼 여기까지 DevOps 파이프라인에서 배포할 때 정적 테스트를 거쳐 배포할 수 있는 방법을 알아보았다.&lt;/p&gt;

    &lt;p&gt;Acceptance, Production 단계인 CD 파이프라인에 OWASP ZAP, Hashicorp Vault, kube-monkey 등 동적 테스트 자동화도 적용시켜보고 싶었지만 갑작스럽게 군대를 가게되어 필자는 여기까지만 프로젝트를 참여하게 되었다.😭😭&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/10/21/devsecops6.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/10/21/devsecops6.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>jenkins</category>
        
        <category>sast</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - Jenkins와 Slack 연동 그리고 멀티 브랜치 파이프라인의 사용</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. Jeknins와 Slack 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Slack 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Jenkins 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 멀티 브랜치 파이프라인 사용&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 멀티 브랜치 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 멀티 브랜치 테스트&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-jeknins와-slack-연동---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. Jeknins와 Slack 연동&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Slack 설정&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;먼저 Jenkins 파이프라인의 실행 결과에 대한 메시지를 받아보기 위해 Slack에서 사용할 워크스페이스와 채널을 생성해준다.&lt;/p&gt;

    &lt;p&gt;워스크페이스와 채널을 생성하고나면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://YOUR_WORKSPACE.slack.com/apps&lt;/code&gt; URL에 접속해서 Slack에 추가 할 앱으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jenkins CI&lt;/code&gt;를 검색한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_1.png&quot; alt=&quot;add_jenkins_ci&quot; width=&quot;461&quot; height=&quot;435&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Jenkins CI 앱 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slack에 추가&lt;/code&gt; 버튼을 누르고 앞서 생성해둔 채널을 선택하여 해당 채널에서 Jenkins의 메시지를 받아 볼 수 있도록 설정한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_2.png&quot; alt=&quot;jenkins_ci_configure&quot; width=&quot;632&quot; height=&quot;569&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Jenkins CI 구성 편집&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 Jenkins CI 앱이 추가되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구성&lt;/code&gt; 탭을 눌러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구성 편집&lt;/code&gt;에 들어가면 위의 [그림 2]와 같은 화면을 볼 수 있다.&lt;/p&gt;

    &lt;p&gt;아래쪽에 보면 토큰이 발급되어 있는 것을 볼 수 있을텐데, &lt;strong&gt;이 토큰은 나중에 Jenkins credentials을 생성할 때 사용&lt;/strong&gt;된다.&lt;/p&gt;

    &lt;p&gt;여기까지 설정했다면 Slack에서의 설정은 끝난 것이다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins 설정&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Jenkins에서 Slack과 연동하는 방법을 알아보겠다.&lt;/p&gt;

    &lt;p&gt;먼저 Jenkins 설정에서 Slack 플러그인을 설치해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_3.png&quot; alt=&quot;install_slack_plugin&quot; width=&quot;667&quot; height=&quot;252&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Slack 플러그인 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 Slack 플러그인을 설치하고나면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 설정&lt;/code&gt; 탭의 맨 아래쪽에 Slack 설정 공간이 있다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 4]와 같이 워크스페이스와 Credentials, 채널 ID를 정확하게 기입해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_4.png&quot; alt=&quot;jenkins_slack_configuration&quot; width=&quot;713&quot; height=&quot;275&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Jenkins에서 Slack 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Credentials의 경우에 옆의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add&lt;/code&gt; 버튼을 눌러 Slack의 Credentials를 추가할 수 있다.&lt;/p&gt;

    &lt;p&gt;Credentials를 추가할 때 Kind는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Secret text&lt;/code&gt;로 두고 Secret은 [그림 2]에서 보이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;토큰&lt;/code&gt; 값을 입력해준다.&lt;/p&gt;

    &lt;p&gt;그런 우측 하단의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Connection&lt;/code&gt; 버튼을 눌러 정상적으로 연동되어 Success 문구가 뜨는지 확인한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins와 Slack이 정상적으로 연동되고나면 다시 파이프라인으로 돌아와서, 파이프라인이 모두 실행되고나서 Slack에 메시지를 보내는 테스트를 진행해보겠다.&lt;/p&gt;

    &lt;p&gt;파이프라인 스크립트는 아래의 내용을 앞선 포스트에서 사용했던 스크립트에 추가했다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          SLACK_CHANNEL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;#send-slack-message-from-jenkins&apos;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
      post &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
          success &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;&apos;#00FF00&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;SUCCESSFUL: Job &apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&apos; (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          failure &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;&apos;#F01717&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;FAILURE: Job &apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&apos; (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;파이프라인을 모두 실행하고 나서 파이프라인이 성공 혹은 실패 상태인지 확인하여 상태에 맞게 Slack 메시지를 보내도록 작성했다.&lt;/p&gt;

    &lt;p&gt;성공하면 ‘SUCCESSFUL’이라는 문구와 함께 초록색으로 메시지가 전달될 것이고, 실패하면 ‘FAILURE’이라는 문구와 함께 빨간색으로 메시지가 전달될 것이다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 5]는 파이프라인이 정상적으로 실행되어 Slack으로 메시지가 전달 되었을 경우이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_5.png&quot; alt=&quot;slack_message&quot; width=&quot;485&quot; height=&quot;183&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Slack 메시지 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-멀티-브랜치-파이프라인-사용---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 멀티 브랜치 파이프라인 사용&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;멀티 브랜치 설정&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;이번에는 Jenkins에서 멀티 브랜치 파이프라인을 설정하는 방법을 알아보자.&lt;/p&gt;

    &lt;p&gt;먼저 Jenkins 시스템 설정에서 다음 [그림 6]과 같이 GitLab 서버에 대해 설정해야 한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_6.png&quot; alt=&quot;gitlab_server_configuration&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] Jenkins에서 GitLab 서버 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그런 다음 Jenkins 홈에서 왼쪽 탭의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로운 Item&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Multibranch Pipeline&lt;/code&gt;을 생성해준다.&lt;/p&gt;

    &lt;p&gt;멀티 브랜치 파이프라인을 만들 때 Branch Sources 항목에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add Source -&amp;gt; GitLab Project&lt;/code&gt;를 눌러 다음 [그림 7]과 같이 설정해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_7.png&quot; alt=&quot;multibranch_gitlab_configuration&quot; width=&quot;653&quot; height=&quot;623&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] 멀티브랜치 GitLab 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Server는 [그림 6]에서 정상적으로 설정했다면 자동으로 잡혀있을 것이고, Credentials는 CI 설정할 때 만들어두었던 것을 그대로 사용해주시면 된다.&lt;/p&gt;

    &lt;p&gt;그리고 파이프라인에 연결할 프로젝트를 생성한 계정의 ID를 Owner로 두면 해당 ID에서 관리하고 있는 프로젝트들을 아래 Projects에서 선택할 수 있다.&lt;/p&gt;

    &lt;p&gt;Behaviours 항목에서 Add 버튼을 눌러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filter by name (with wildcards)&lt;/code&gt;를 생성해주고, 위에서 선택한 프로젝트에서 파이프라인을 실행할 브랜치들의 이름을 Include에 적어두면 된다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;멀티 브랜치 파이프라인은 각 브랜치들에 Jenkinsfile을 생성하여 Jenkinsfile에서 스크립트를 작성해두어야 한다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;master 브랜치에서는 CI/CD 파이프라인이 모두 동작하여 빌드부터 배포까지 모두 진행되도록 그대로 두었고,&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;release 브랜치에서는 CI 파이프라인만 동작하도록 아래와 같이 작성했다.&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          registry &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513/flask-app&quot;&lt;/span&gt;
          registryCredential &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;crisis513&apos;&lt;/span&gt;
          dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;
          releaseName &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-app&quot;&lt;/span&gt;
          helmChartRepo &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-kubernetes-helm&quot;&lt;/span&gt;
          release_version &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;latest&apos;&lt;/span&gt;
          SLACK_CHANNEL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;#send-slack-message-from-jenkins&apos;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      agent &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          label &lt;span class=&quot;s2&quot;&gt;&quot;jenkins-slave&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cloning our Git&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s1&quot;&gt;&apos;http://GITLAB_SERVER_IP:8001/root/flask-app.git&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Building docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry + &lt;span class=&quot;s2&quot;&gt;&quot;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Deploy docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              when &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  branch &lt;span class=&quot;s1&quot;&gt;&apos;master&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;, registryCredential &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          dockerImage.push&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cleaning up&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              when &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  branch &lt;span class=&quot;s1&quot;&gt;&apos;master&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;docker rmi &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$registry&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Deploy image to kubernetes&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              when &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  branch &lt;span class=&quot;s1&quot;&gt;&apos;master&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&quot;
                      helm lint &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                      helm upgrade &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;releaseName&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                  &quot;&quot;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      post &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
          success &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;&apos;#00FF00&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;SUCCESSFUL: Job &apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&apos; (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
          failure &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
              slackSend &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;channel: SLACK_CHANNEL, color: &lt;span class=&quot;s1&quot;&gt;&apos;#FF0000&apos;&lt;/span&gt;, message: &lt;span class=&quot;s2&quot;&gt;&quot;FAILED: Job &apos;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.JOB_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; [&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_NUMBER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;]&apos; (&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.BUILD_URL&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;멀티 브랜치 테스트&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;release 파이프라인을 실행시켜 정상적으로 동작하면 다음 [그림 8]과 같은 화면을 볼 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_5_8.png&quot; alt=&quot;release_pipeline_test&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] release 브랜치 파이프라인 테스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Git clone하여 도커 이미지를 빌드하는 부분까지는 정상 동작하지만 도커 이미지를 배포하고 쿠버네티스 클러스터에 배포하기까지의 과정은 master 브랜치에서만 동작하도록 설정하였기 때문에 생락된 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음 포스팅에서는 지금까지 설정해 둔 DevOps 파이프라인에서 SAST(Static Application Security Testing)를 적용하여 자동으로 정적 테스트를 거쳐 배포할 수 있는 방법을 기술해보겠다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/10/15/devsecops5.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/10/15/devsecops5.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>jenkins</category>
        
        <category>slack</category>
        
        <category>multi-branch</category>
        
        <category>pipeline</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - Helm을 통한 모니터링과 로깅 시스템 구축</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 모니터링 시스템 구축&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. Helm 개요와 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Prometheus와 Grafana 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 로깅 시스템 구축&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. EFK(Elasticsearch-Fluent Bit-Kibana) 구성&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-모니터링-시스템-구축---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 모니터링 시스템 구축&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Helm 개요와 설치&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Helm은 쿠버네티스 패키지를 관리해주는 도구이다.&lt;/p&gt;

    &lt;p&gt;Helm에서 사용되는 차트는 리소스를 하나로 묶은 패키지에 해당하며, Helm으로 차트를 관리하는 목적은 자칫 번잡해지기 쉬운 매니페스트 파일을 관리하기 쉽게 하기 위함이다.&lt;/p&gt;

    &lt;p&gt;그리고 설치할 때마다 릴리스 버전이 생성되고 새로운 차트를 찾을때에는 Helm chart repository에서 찾을 수 있다.&lt;/p&gt;

    &lt;p&gt;Helm 다음 명령어로 간단하게 설치가 가능하다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;700 get_helm.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./get_helm.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Helm이 정상적으로 설치되면 차트 레포지토리를 추가하고 업데이트 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add stable https://kubernetes-charts.storage.googleapis.com/
  &lt;span class=&quot;s2&quot;&gt;&quot;stable&quot;&lt;/span&gt; has been added to your repositories

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo update
  Hang tight &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;we grab the latest from your chart repositories...
  ...Successfully got an update from the &lt;span class=&quot;s2&quot;&gt;&quot;stable&quot;&lt;/span&gt; chart repository
  Update Complete. ⎈Happy Helming!⎈
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;여기까지만 해주어도 Helm을 사용할 준비가 끝난 것이다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prometheus와 Grafana 구성&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;모니터링 환경을 구축하기 위해 앞서 설치한 Helm을 사용하여 Prometheus와 Grafana를 쿠버네티스에 설치할 것이다.&lt;/p&gt;

    &lt;p&gt;먼저 모니터링을 위한 네임스페이스를 생성해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace monitoring
  namemonitoring created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;생성된 네임스페이스에 다음 명령어를 통해 prometheus-operator를 설치해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;prometheus stable/prometheus-operator &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; monitoring
  WARNING: This chart is deprecated
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  NAME: prometheus
  LAST DEPLOYED: Sun Oct  4 07:36:07 2020
  NAMESPACE: monitoring
  STATUS: deployed
  REVISION: 1
  NOTES:
  &lt;span class=&quot;k&quot;&gt;*******************&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; DEPRECATED &lt;span class=&quot;k&quot;&gt;****&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*******************&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; stable/prometheus-operator chart is deprecated.
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Further development has moved to https://github.com/prometheus-community/helm-charts
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; The chart has been renamed kube-prometheus-stack to more clearly reflect
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; that it installs the &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;kube-prometheus&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; project stack, within which Prometheus
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Operator is only one component.

  The Prometheus Operator has been installed. Check its status by running:
  kubectl &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; monitoring get pods &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;release=prometheus&quot;&lt;/span&gt;

  Visit https://github.com/coreos/prometheus-operator &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;instructions on how
  to create &amp;amp; configure Alertmanager and Prometheus instances using the Operator.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Prometheus와 Grafana가 재대로 동작하는지 확인해본다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring
  NAME                                                         READY   STATUS    RESTARTS   AGE
  pod/alertmanager-prometheus-prometheus-oper-alertmanager-0   2/2     Running   0          10m
  pod/prometheus-grafana-7db88cd4c6-nff9b                      2/2     Running   0          10m
  pod/prometheus-kube-state-metrics-6b46f67bf6-n8pxk           1/1     Running   0          10m
  pod/prometheus-prometheus-node-exporter-d4zfh                1/1     Running   0          10m
  pod/prometheus-prometheus-node-exporter-dkjrj                1/1     Running   0          10m
  pod/prometheus-prometheus-node-exporter-zv7t9                1/1     Running   0          10m
  pod/prometheus-prometheus-oper-operator-7c75ff5864-z85j8     2/2     Running   0          10m
  pod/prometheus-prometheus-prometheus-oper-prometheus-0       3/3     Running   0          10m

  NAME                                              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                      AGE
  service/alertmanager-operated                     ClusterIP   None             &amp;lt;none&amp;gt;        9093/TCP,9094/TCP,9094/UDP   10m
  service/prometheus-grafana                        ClusterIP   10.104.145.38    &amp;lt;none&amp;gt;        80/TCP                       10m
  service/prometheus-kube-state-metrics             ClusterIP   10.109.220.132   &amp;lt;none&amp;gt;        8080/TCP                     10m
  service/prometheus-operated                       ClusterIP   None             &amp;lt;none&amp;gt;        9090/TCP                     10m
  service/prometheus-prometheus-node-exporter       ClusterIP   10.104.66.36     &amp;lt;none&amp;gt;        9100/TCP                     10m
  service/prometheus-prometheus-oper-alertmanager   ClusterIP   10.100.159.72    &amp;lt;none&amp;gt;        9093/TCP                     10m
  service/prometheus-prometheus-oper-operator       ClusterIP   10.99.75.140     &amp;lt;none&amp;gt;        8080/TCP,443/TCP             10m
  service/prometheus-prometheus-oper-prometheus     NodePort    10.107.124.62    &amp;lt;none&amp;gt;        9090/TCP                     10m

  NAME                                                 DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
  daemonset.apps/prometheus-prometheus-node-exporter   3         3         3       3            3           &amp;lt;none&amp;gt;          10m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Prometheus와 Grafana가 정상적으로 동작하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodePort를 생성&lt;/code&gt;하여 생성된 Prometheus와 Grafana 서비스에 접근할 수 있다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 Prometheus의 포트번호를 31111, Grafana의 포트번호를 31112로 정하였고, &lt;strong&gt;GCP 방화벽에서도 해당 포트를 열어준다.&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim prometheus_nodeport.yaml
  apiVersion: v1
  kind: Service
  metadata:
  name: prometheus
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app: prometheus
      prometheus: prometheus-prometheus-oper-prometheus
  ports:
      - protocol: TCP
      port: 9090
      targetPort: 9090
      nodePort: 31111

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim grafana_nodeport.yaml 
  apiVersion: v1
  kind: Service
  metadata:
  name: grafana
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app.kubernetes.io/instance: prometheus
      app.kubernetes.io/name: grafana
  ports:
      - protocol: TCP
      port: 3000
      targetPort: 3000
      nodePort: 31112

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; prometheus_nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; grafana_nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-masterIP:31111&lt;/code&gt; URL로 접속하여 상단 메뉴의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Status &amp;gt; Targets&lt;/code&gt;에 들어가보면 다음 [그림 1]과 같이 에러가 발생되어 있을 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_4_1.png&quot; alt=&quot;proxy_etcd_error&quot; width=&quot;858&quot; height=&quot;254&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] kube-proxy와 kube-etcd 에러&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;kube-proxy는 메트릭 바인드 주소가 기본적으로 localhost로 잡혀있을 것이다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl edit cm/kube-proxy &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  kind: KubeProxyConfiguration
  metricsBindAddress: 0.0.0.0:10249
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete pod &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; k8s-app&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kube-proxy &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;metricsBindAddress 값을 위와 같이 0.0.0.0으로 바꿔주고 기존의 kube-proxy 파드를 제거하여 재생성 되도록 해주면 Prometheus에서 kube-proxy가 정상적으로 작동할 것이다.&lt;/p&gt;

    &lt;p&gt;다음으로 kube-etcd는 https 인증서 설정이 재대로 되어있지 않아서 생기는 문제이다.&lt;/p&gt;

    &lt;p&gt;prometheus-operator를 배포할 때 Helm 차트의 values.yaml 파일을 다음과 같이 수정한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim values.yaml
  serviceMonitor:
      scheme: https
      insecureSkipVerify: &lt;span class=&quot;nb&quot;&gt;false
      &lt;/span&gt;serverName: localhost
      caFile: /etc/prometheus/secrets/etcd-client-cert/etcd-ca
      certFile: /etc/prometheus/secrets/etcd-client-cert/etcd-client
      keyFile: /etc/prometheus/secrets/etcd-client-cert/etcd-client-key

      secrets:
      - &lt;span class=&quot;s2&quot;&gt;&quot;etcd-client-cert&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;values.yaml 파일을 수정하고 caFile, certFile, keyFile에 맞는 시크릿을 생성해주어야 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ POD_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get pods &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;{.items[0].metadata.name}&apos;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kube-apiserver &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create secret generic etcd-client-cert &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; monitoring &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--from-literal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;etcd-ca&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD_NAME&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/kubernetes/pki/etcd/ca.crt&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--from-literal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;etcd-client&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD_NAME&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/kubernetes/pki/etcd/healthcheck-client.crt&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--from-literal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;etcd-client-key&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$POD_NAME&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/kubernetes/pki/etcd/healthcheck-client.key&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  secret/etcd-client-cert created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;etcd-client-cert 시크릿을 만들어주고 수정된 values.yaml 파일을 바탕으로 다시 prometheus-operator를 배포하면 etcd의 통신 에러도 해결 될 것이다.&lt;/p&gt;

    &lt;p&gt;Helm에 value.xml 파일을 따로 수정하지 않으면 기본적으로 Grafana의 ID는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt;, 패스워드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prom-operator&lt;/code&gt;로 설정되어 있다.&lt;/p&gt;

    &lt;p&gt;참고로 초기 패스워드는 values.yaml 파일에서 수정할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-masterIP:31112&lt;/code&gt; URL로 접속하여 Grafana 대시보드가 Prometheus에서 수집된 메트릭을 잘 수집하여 시각화되어지는지 확인해본다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_4_2.png&quot; alt=&quot;grafana_dashboard&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Grafana 대시보드 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 2]에서와 같이 쿠버네티스 클러스터에 대한 메트릭이 잘 수집되어 시각화해주는 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-로깅-시스템-구축---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 로깅 시스템 구축&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EFK(Elasticsearch-Fluent Bit-Kibana) 구성&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;로깅 환경을 구축하기 위해 Helm을 사용하여 EFK를 쿠버네티스에 설치할 것이다.&lt;/p&gt;

    &lt;p&gt;먼저 EFK 차트 레포지토리를 추가 및 업데이트를 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add akomljen-charts https://raw.githubusercontent.com/komljen/helm-charts/master/charts/
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;그런 다음 모니터링과 마찬가지로 로깅을 위한 네임스페이스를 생성해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace logging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;elasticsearch-master와 elasticsearch-data에서 사용할 PV를 미리 각각 생성해주어야 PVC가 정상적으로 바인딩 되어 Elasticsearch 노드들이 정상적으로 동작된다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim elastic-pv.yaml
  apiVersion: v1
  kind: PersistentVolume
  metadata:
  name: es-data-es-master-efk-cluster-default-0
  labels:
      cluster: efk-cluster
      component: elasticsearch-efk-cluster
      name: es-master-efk-cluster-default
      role: master
  spec:
  capacity:
      storage: 10Gi
  accessModes:
      - ReadWriteOnce
  hostPath:
      path: &lt;span class=&quot;s2&quot;&gt;&quot;/mnt/data&quot;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
  apiVersion: v1
  kind: PersistentVolume
  metadata:
  name: es-data-es-data-efk-cluster-default-0
  labels:
      cluster: efk-cluster
      component: elasticsearch-efk-cluster
      name: es-data-efk-cluster-default
      role: data
  spec:
  capacity:
      storage: 10Gi
  accessModes:
      - ReadWriteOnce
  hostPath:
      path: &lt;span class=&quot;s2&quot;&gt;&quot;/mnt/data&quot;&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; elastic-pv.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pv,pvc &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging
  NAME                                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                             STORAGECLASS   REASON   AGE
  persistentvolume/es-data-es-data-efk-cluster-default-0     10Gi       RWO            Retain           Bound    logging/es-data-es-data-efk-cluster-default-0                             15m
  persistentvolume/es-data-es-master-efk-cluster-default-0   10Gi       RWO            Retain           Bound    logging/es-data-es-master-efk-cluster-default-0                           15m

  NAME                                                            STATUS   VOLUME                                    CAPACITY   ACCESS MODES   STORAGECLASS   AGE
  persistentvolumeclaim/es-data-es-data-efk-cluster-default-0     Bound    es-data-es-data-efk-cluster-default-0     10Gi       RWO                           15m
  persistentvolumeclaim/es-data-es-master-efk-cluster-default-0   Bound    es-data-es-master-efk-cluster-default-0   10Gi       RWO                           15m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;PV를 정상적으로 생성하고 PVC가 바운드된 것이 확인되면 다음 명령어를 통해 EFK를 설치해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;efk &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; logging akomljen-charts/efk

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging
  NAME                                                    READY   STATUS      RESTARTS   AGE
  pod/efk-elasticsearch-curator-1602579600-rcwk8          0/1     Completed   0          15m
  pod/efk-kibana-676fb9dbd4-rx5xv                         1/1     Running     0          15m
  pod/elasticsearch-operator-sysctl-fl7jd                 1/1     Running     0          15m
  pod/elasticsearch-operator-sysctl-mgsxp                 1/1     Running     0          15m
  pod/es-client-efk-cluster-5f65d7f687-hpm65              1/1     Running     0          15m
  pod/es-data-efk-cluster-default-0                       1/1     Running     0          15m
  pod/es-master-efk-cluster-default-0                     1/1     Running     0          15m
  pod/es-operator-elasticsearch-operator-876b46db-s84t8   1/1     Running     0          15m
  pod/fluent-bit-s5j8z                                    1/1     Running     0          15m
  pod/fluent-bit-spwj2                                    1/1     Running     0          15m


  NAME                                          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         AGE
  service/efk-kibana                            ClusterIP   10.111.218.138   &amp;lt;none&amp;gt;        443/TCP         15m
  service/elasticsearch-discovery-efk-cluster   ClusterIP   10.103.53.150    &amp;lt;none&amp;gt;        9300/TCP        15m
  service/elasticsearch-efk-cluster             ClusterIP   10.108.108.5     &amp;lt;none&amp;gt;        9200/TCP        15m
  service/es-data-svc-efk-cluster               ClusterIP   10.107.231.1     &amp;lt;none&amp;gt;        9300/TCP        15m

  NAME                                           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                 AGE
  daemonset.apps/elasticsearch-operator-sysctl   2         2         2       2            2           beta.kubernetes.io/os&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux   15m
  daemonset.apps/fluent-bit                      2         2         2       2            2           &amp;lt;none&amp;gt;                        15m

  NAME                                                 READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/efk-kibana                           1/1     1            1           15m
  deployment.apps/es-client-efk-cluster                1/1     1            1           15m
  deployment.apps/es-operator-elasticsearch-operator   1/1     1            1           15m

  NAME                                                          DESIRED   CURRENT   READY   AGE
  replicaset.apps/efk-kibana-676fb9dbd4                         1         1         1       15m
  replicaset.apps/es-client-efk-cluster-5f65d7f687              1         1         1       15m
  replicaset.apps/es-operator-elasticsearch-operator-876b46db   1         1         1       15m

  NAME                                             READY   AGE
  statefulset.apps/es-data-efk-cluster-default     1/1     15m
  statefulset.apps/es-master-efk-cluster-default   1/1     15m

  NAME                                             COMPLETIONS   DURATION   AGE
  job.batch/efk-elasticsearch-curator-1602579600   1/1           2s         15m

  NAME                                      SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE
  cronjob.batch/efk-elasticsearch-curator   0 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;   False     0        15m             15m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;EFK가 정상적으로 설치되면 NodePort 서비스를 생성하여 외부에서 접근 가능하도록 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim kibana-nodeport.yaml
  apiVersion: v1
  kind: Service
  metadata:
  name: kibana
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
      app: kibana
      release: efk
  ports:
      - protocol: TCP
      port: 443
      targetPort: 5601
      nodePort: 30443

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; kibana-nodeport.yaml &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; logging
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;마찬가지로 &lt;strong&gt;Kibana에 접근할 30443 포트는 GCP 방화벽에서도 열어주어야 접근이 가능하다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이렇게 Kibana에 접근하더라도 한 가지 문제가 있다.&lt;/p&gt;

    &lt;p&gt;Fluent Bit에서 쿠버네티스 클러스터의 로그를 수집할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log/containers&lt;/code&gt;에 존재하는 로그 파일을 읽어들이는데, journald 드라이버를 사용하여 컨테이너 로그를 수집하게 되어 있어 /var/log/containers 폴더에 로그가 쌓이지 않는 문제가 있다.&lt;/p&gt;

    &lt;p&gt;그래서 Kibana에 접속하더라도 생성할 인덱스 패턴이 존재하지 않았었는데, 문제를 해결하기 위해 다음과 같이 수정해야 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim /etc/sysconfig/docker
  &lt;span class=&quot;nv&quot;&gt;OPTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;--selinux-enabled --signature-verification=false&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;모든 쿠버네티스 클러스터에서 /etc/sysconfig/docker 파일에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--log-driver = journald 부분을 제거&lt;/code&gt;해야 도커 컨테이너 로그가 /var/log/containers 경로에 쌓이게 되고, Fluent Bit에서 해당 로그들을 수집하여 Kibana에서 인덱스 패턴을 생성할 수 있게 된다.&lt;/p&gt;

    &lt;p&gt;정상적으로 로그가 쌓이게 되면 다시 Kibana에 접속하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kubernetes_cluster-*&lt;/code&gt;이라는 인덱스 패턴을 생성해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_4_3.png&quot; alt=&quot;kibana_index_pattern&quot; width=&quot;1233&quot; height=&quot;608&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Kibana 인덱스 패턴 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기까지 Helm을 이용하여 쿠버네티스에 로깅 및 모니터링 시스템을 구축해보았다.&lt;/p&gt;

    &lt;p&gt;다음 포스팅에서는 Jenkins와 Slack을 연동하고 멀티 브랜치를 기반으로 작동하는 파이프라인을 생성하고 스크립트를 작성하는 부분에 대해 기술해보겠다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 13 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/10/13/devsecops4.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/10/13/devsecops4.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>kubernetes</category>
        
        <category>helm</category>
        
        <category>prometheus</category>
        
        <category>grafana</category>
        
        <category>efk</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - CD 구성</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. CD(Continuous Delivery/Continuous Deployment) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. CD 란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. Jenkins - 쿠버네티스 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. Jenkins Slave 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_4&quot;&gt;   1.4. 쿠버네티스 배포 파이프라인 추가&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. ArgoCD를 이용한 CD 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. ArgoCD 란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. ArgoCD 설치&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. ArgoCD 설정&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-cdcontinuous-deliverycontinuous-deploy-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. CD(Continuous Delivery/Continuous Deploy) 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CD 란?&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;CD는 지속적인 지속적인 제공(Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미한다.&lt;/p&gt;

    &lt;p&gt;이 두 용어는 상호 교환적으로 사용되며, 두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 한다.&lt;/p&gt;

    &lt;p&gt;지속적인 제공이란 &lt;strong&gt;개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리에 자동으로 업로드&lt;/strong&gt;되는 것을 뜻한다.&lt;/p&gt;

    &lt;p&gt;지속적인 배포란 &lt;strong&gt;개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것&lt;/strong&gt;을 의미한다.&lt;/p&gt;

    &lt;p&gt;이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결해준다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins - 쿠버네티스 연동&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 쿠버네티스 클러스터와 연동하는 방법에 대해서 설명할 것이다.&lt;/p&gt;

    &lt;p&gt;Jenkins와 쿠버네티스의 구성은 &lt;a href=&quot;https://crisis513.github.io/project/2020/10/03/devsecops1.html#list2_1&quot;&gt;구축 환경 참고&lt;/a&gt;를 참고 바란다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_1.png&quot; alt=&quot;kubernetes_plugin&quot; width=&quot;728&quot; height=&quot;718&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] Jenkins에서 쿠버네티스 플러그인 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 설치된 쿠버네티스 플러그인에 대한 설정을 진행한다.&lt;/p&gt;

    &lt;p&gt;Jenkins 시스템 설정에서 맨 밑으로 내려가면 [그림 2]와 같이 클라우드 설정하는 부분이 나온다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_2.png&quot; alt=&quot;cloud_configuration&quot; width=&quot;598&quot; height=&quot;75&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] Jenkins 시스템 설정에서 클라우드 설정 클릭&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a separate configuration page&lt;/code&gt;를 눌러 Configure Clouds 설정으로 들어온다.&lt;/p&gt;

    &lt;p&gt;쿠버네티스 설정은 다음 [그림 3], [그림 4]와 같이 진행한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_3.png&quot; alt=&quot;kubernetes_plugin_configuration&quot; width=&quot;725&quot; height=&quot;335&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] 쿠버네티스 플러그인 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Kubernetes URL은 kube-master 인스턴스에 접속하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.kube/config&lt;/code&gt; 파일의 내용을 확인해보면 server에 명시된 URL을 기입하면 된다.&lt;/p&gt;

    &lt;p&gt;Kubernetes URL을 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Connection&lt;/code&gt; 버튼을 눌러 쿠버네티스 클러스터에 정상적으로 접속되는지 확인한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; ~/.kube/config 
  apiVersion: v1
  clusters:
  - cluster:
      certificate-authority-data: &lt;span class=&quot;nv&quot;&gt;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN5RENDQWJDZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJd01UQXdPREF5TlRreU9Gb1hEVE13TVRBd05qQXlOVGt5T0Zvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTlNhCkhwK2M2cWxhRXU1cXlWWHpLZFA3UTJZWnVjVnN1aTRTczFqamUxQW41cXlEVDVnMk9iKzM5OXN4Y0phM215MkIKYjg0UE5NYmc1MERyenZ4S1VOWVZySkk4Z1F2c2JXWXRPZnhhTGV3NUF1aE5NV1dsRlVlRUpyTE9WT0NQdndoTApDRHVLOVd5TUlIMTU4U1hKM1dYRW5TeUZJWXVSeDI3NTNicnFWRzVuNnZMTVVMMUdDKzNSaHJ1cEN5d0xoVG12CnpyYWdWTVFicUVjV2pTcjV2TVZueTduTXVvQ2xmSjE3SXBYa1MweTN3eDJsRTJVREtIblNuSlZHeVNYbXVKYVYKL3A5THk4djNWL2VsVjZLY1plRStIaVZFNlNBT3R4bXhwSDl2Zmh2blpxQzBsbzNpaGpzR0hGUGRyeStiZkhVegpPaSsrZ1VCZmxKTkZucFZlNE5zQ0F3RUFBYU1qTUNFd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFBNlI3NW9SWnJxQ2tDMEpqbURTMmgxMUN4WkYKTmM0cXRqMTlqeEZlQUFlMCt4a0MveUlidzBUYmY0OW1TWGE1VUhPbkE1RSszSStFWTdXc0h6dTJTOEZlU3FwbgpNZC9iYXp6aU5wT28vNGxoNGVWNkE5NmNsdjV1cm5CSVIzOVVpM085SnpKUDBobTRhUGxDZFVqcDhyb3BrSWFmCkZieURTcVBFS1E0Rm5tc1MvcGJWellHQ2RVdmlqT3JCcnBiTEU2ZW1PYkc2RGE4WG0xNWJHSzVUVUt5Mm5rOGgKOHoxNjZZanVVOTR1bW9RYjR4eVNWOThNZ2RRTWVsWml1U2dHelRKcEtKTHN3NG94SGdPbkNLZUNNeURHSFZOUwpnMFo2MU12YldlVzhzVEtaSHpCVVZySFZ3WjlTSCtNdGtMWllSb0VWdk9NTTNLSXczbmRieG8rcXd5OD0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
      server: https://10.178.0.19:6443
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그 후 아래로 내리다보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod Templates&lt;/code&gt;를 구성하는 버튼이 있다.&lt;/p&gt;

    &lt;p&gt;그 버튼을 눌러 다음 [그림 4]와 같이 설정하고 저장한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_4.png&quot; alt=&quot;pod_template&quot; width=&quot;910&quot; height=&quot;601&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Pod 템플릿 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins Slave 설정&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 쿠버네티스 클러스터와의 연동이 정상적으로 설정되었다면 다음은 Jenkins Slave를 생성 및 구성해야 한다.&lt;/p&gt;

    &lt;p&gt;Jenkins의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Manage Nodes&lt;/code&gt; 설정에 들어와서 왼쪽의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신규 노드&lt;/code&gt; 탭을 눌러 Jenkins Slave 노드를 생성해준다.&lt;/p&gt;

    &lt;p&gt;첫 화면에서는 노드 명에 ‘jenkins-slave’라고 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Permanent Agent&lt;/code&gt;를 클릭 후 다음으로 넘어간다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_5.png&quot; alt=&quot;create_jenkins_slave&quot; width=&quot;937&quot; height=&quot;437&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Jenkins Slave 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;신규 노드에 대한 설정에서 위의 [그림 5]와 같이 설정한다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;jenkins-slave를 kube-master 인스턴스에서 실행시켜놓고 Jenkins에서 웹 소켓을 통해 kube-master에 접근하여 스크립트를 실행시켜서 서비스를 배포하는 형태로 진행된다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;jenkins-slave agent를 생성하면 다음 [그림 6]의 화면을 볼 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_6.png&quot; alt=&quot;jenkins_slave_guide&quot; width=&quot;1050&quot; height=&quot;297&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] jenkins-slave 가이드 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;agent.jar 링크를 눌러 파일을 다운&lt;/strong&gt;받고 kube-master 인스턴스에 복사한 후에 [그림 6]에 보이는 명령을 실행하면 된다.&lt;/p&gt;

    &lt;p&gt;하지만 kube-master 인스턴스에는 java가 설치되어 있지 않아 java를 설치하고 설정하는 작업부터 진행한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;java-1.8.0-openjdk-devel.x86_64
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;readlink&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /usr/bin/javac
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vi /etc/profile
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;
  /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/bin/javac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;java 1.8 버전을 설치&lt;/strong&gt;하고 &lt;strong&gt;JAVA_HOME 환경변수를 설정&lt;/strong&gt;하여 java 명령을 실행시킬 수 있도록 해주고 다음 명령을 입력한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;java &lt;span class=&quot;nt&quot;&gt;-jar&lt;/span&gt; agent.jar &lt;span class=&quot;nt&quot;&gt;-jnlpUrl&lt;/span&gt; http://serversIP:8002/computer/jenkins-slave/slave-agent.jnlp &lt;span class=&quot;nt&quot;&gt;-secret&lt;/span&gt; 032e782a7ef4897446fec5be230aefb9036ddb841552142e415012d266ced967 &lt;span class=&quot;nt&quot;&gt;-workDir&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/data/jenkins&quot;&lt;/span&gt;
  Sep 30, 2020 3:18:20 PM org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir
  INFO: Using /home/jenkins/agent/remoting as a remoting work directory
  Sep 30, 2020 3:18:20 PM org.jenkinsci.remoting.engine.WorkDirManager setupLogging
  INFO: Both error and output logs will be printed to /home/jenkins/agent/remoting
  Sep 30, 2020 3:18:21 PM hudson.remoting.jnlp.Main createEngine
  INFO: Setting up agent: jenkins-slave
  Sep 30, 2020 3:18:21 PM hudson.remoting.jnlp.Main&lt;span class=&quot;nv&quot;&gt;$CuiListener&lt;/span&gt; &amp;lt;init&amp;gt;
  INFO: Jenkins agent is running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;headless mode.
  Sep 30, 2020 3:18:21 PM hudson.remoting.Engine startEngine
  INFO: Using Remoting version: 4.5
  Sep 30, 2020 3:18:21 PM org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir
  INFO: Using /home/jenkins/agent/remoting as a remoting work directory
  Sep 30, 2020 3:18:21 PM hudson.remoting.jnlp.Main&lt;span class=&quot;nv&quot;&gt;$CuiListener&lt;/span&gt; status
  INFO: WebSocket connection open
  Sep 30, 2020 3:18:22 PM hudson.remoting.jnlp.Main&lt;span class=&quot;nv&quot;&gt;$CuiListener&lt;/span&gt; status
  INFO: Connected
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 jenkins-slave가 실행되면 Jenkins에서 쿠버네티스 클러스터에 서비스를 배포할 수 있는 환경이 만들어진 것이고 [그림 7]과 같이 agent가 연결된 것을 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_7.png&quot; alt=&quot;jenkins_slave_agent&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] jenkins-slave agent 연결 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipeline 설정 및 테스트&lt;/strong&gt;   &lt;a name=&quot;list1_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;위의 쿠버네티스 관련 설정이 정상적으로 완료되면 파이프라인 스크립트를 다음과 같이 작성해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          registry &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513/flask-app&quot;&lt;/span&gt;
          registryCredential &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513&quot;&lt;/span&gt;
          dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
          releaseName &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-app&quot;&lt;/span&gt;
          helmChartRepo &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-kubernetes-helm&quot;&lt;/span&gt;
          release_version &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;latest&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      agent &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          label &lt;span class=&quot;s2&quot;&gt;&quot;jenkins-slave&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cloning our Git&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s2&quot;&gt;&quot;http://GITLAB_SERVER_IP:8001/root/flask-app.git&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Building docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry + &lt;span class=&quot;s2&quot;&gt;&quot;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Deploy docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;, registryCredential &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          dockerImage.push&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cleaning up&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;docker rmi &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$registry&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Deploy image to kubernetes&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&quot;
                      helm lint &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                      helm upgrade &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;releaseName&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;helmChartRepo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
                  &quot;&quot;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;만약 Jenkins agent에서 도커를 실행하지 못하는 에러가 발생하면 docker.io 패키지를 설치해야 한다.&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;파이프라인은 다음과 같이 실행된다.&lt;/p&gt;

    &lt;p&gt;CI가 실행되는 스크립트는 이전 포스팅과 동일하고 그 이후 배포하는 과정이 추가되었고, ‘Deploy image to kubernetes’ Stage에서 &lt;strong&gt;helm upgrade 명령어를 통해 쿠버네티스 클러스터에 실행되고 있는 서비스에 롤링 업데이트 형태로 재배포할 수 있다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_8.png&quot; alt=&quot;pipeline_execute_result&quot; width=&quot;716&quot; height=&quot;332&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] 쿠버네티스 배포까지의 파이프라인 실행 결과&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위 스크립트의 실행 결과는 위의 [그림 8]과 같다. Git clone하는 부분부터 쿠버네티스 클러스터에 서비스 배포하는 과정까지 정상적으로 실행된 것을 확인할 수 있다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Helm에 대한 부분은 추후 별도로 포스팅 할 예정&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-argocd를-이용한-cd-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. ArgoCD를 이용한 CD 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ArgoCD 란?&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;앞서 설명한 Jenkins Slave를 구성하여 CI/CD를 모두 제어할 수 있지만, CI를 Jenkins에서 진행하고 CD를 ArgoCD로 진행하는 형태로도 구축할 수 있다.&lt;/p&gt;

    &lt;p&gt;ArgoCD는 쿠버네티스 클러스터에 설치 한 후 애플리케이션들을 관리할 수 ​​있다.&lt;/p&gt;

    &lt;p&gt;Git 저장소에 앱을 설명하는 쿠버네티스 매니페스트가 존재하는데, ArgoCD는 이러한 매니페스트가 항상 동기화되어 있는지 확인한다.&lt;/p&gt;

    &lt;p&gt;모든 매니페스트와 해당 동기화 상태는 UI가 깔끔하고 시각적으로 잘 표현되어 있으면서도 가볍기 때문에 Jenkins와 같이 사용하는 것도 상당히 매력적인 선택지 중 하나이다.&lt;/p&gt;

    &lt;p&gt;애플리케이션 배포 및 수명주기 관리는 자동화되고 감사 가능하며 이해하기 쉬워야합니다. 이 모든 작업은 Argo를 사용하여 수행할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ArgoCD 설치&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ArgoCD는 쿠버네티스 위에서 동작하는 GitOps 지속적 배포 도구이다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;따라서 Helm을 사용하여 ArgoCD를 쿠버네티스에 배포할 것이다.&lt;/p&gt;

    &lt;p&gt;우선 argocd의 네임스페이스를 생성해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create namespace argocd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;다음으로 ArgoCD의 Helm 레포지토리를 추가해주고 앞서 생성해준 argocd 네임스페이스에 Helm을 사용해 argocd를 설치해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm repo add argo https://argoproj.github.io/argo-helm
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;argocd argo/argo-cd &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  manifest_sorter.go:192: info: skipping unknown hook: &lt;span class=&quot;s2&quot;&gt;&quot;crd-install&quot;&lt;/span&gt;
  NAME: argocd
  LAST DEPLOYED: Wed Oct 10 06:38:54 2020
  NAMESPACE: argocd
  STATUS: deployed
  REVISION: 1
  TEST SUITE: None
  NOTES:
  In order to access the server UI you have the following options:

  1. kubectl port-forward service/argocd-server &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; argocd 8080:443

      and &lt;span class=&quot;k&quot;&gt;then &lt;/span&gt;open the browser on http://localhost:8080 and accept the certificate

  2. &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;ingress &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the values file &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;service.ingress.enabled&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; and either
      - Add the annotation &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;ssl passthrough: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/ingress.md#option-1-ssl-passthrough
      - Add the &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--insecure&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; flag to &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;server.extraArgs&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the values file and terminate SSL at your ingress: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/ingress.md#option-2-multiple-ingress-objects-and-hosts


  After reaching the UI the first &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;you can login with username: admin and the password will be the
  name of the server pod. You can get the pod name by running:

  kubectl get pods &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; argocd &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; app.kubernetes.io/name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;argocd-server &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; name | &lt;span class=&quot;nb&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;/&apos;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;설치 시 수정 된 values.yaml을 적용할 경우 다음의 명령어를 통해 배포
$ helm install argocd argo/argo-cd -f ./values.yaml&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;성공적으로 배포가 되었는지 확인해본다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get all &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; argocd
  NAME                                                READY   STATUS    RESTARTS   AGE
  pod/argocd-application-controller-544c45984-26sfs   1/1     Running   0          15h
  pod/argocd-dex-server-7cd54b9d86-6hhvw              1/1     Running   0          15h
  pod/argocd-redis-5ddd577d68-nh867                   1/1     Running   0          15h
  pod/argocd-repo-server-69fc78b68-8f9n2              1/1     Running   0          15h
  pod/argocd-server-7c5f6f8d9-xkc8h                   1/1     Running   0          15h


  NAME                            TYPE           CLUSTER-IP       EXTERNAL-IP     PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                      AGE
  service/argocd-dex-server       ClusterIP      10.100.97.188    &amp;lt;none&amp;gt;          5556/TCP,5557/TCP,5558/TCP   15h
  service/argocd-metrics          ClusterIP      10.108.127.86    &amp;lt;none&amp;gt;          8082/TCP                     15h
  service/argocd-redis            ClusterIP      10.105.230.152   &amp;lt;none&amp;gt;          6379/TCP                     15h
  service/argocd-repo-server      ClusterIP      10.104.24.97     &amp;lt;none&amp;gt;          8081/TCP,8084/TCP            15h
  service/argocd-server           ClusterIP      10.104.68.51     &amp;lt;none&amp;gt;          80:30854/TCP,443:32178/TCP   15h
  service/argocd-server-metrics   ClusterIP      10.103.118.105   &amp;lt;none&amp;gt;          8083/TCP                     15h


  NAME                                            READY   UP-TO-DATE   AVAILABLE   AGE
  deployment.apps/argocd-application-controller   1/1     1            1           15h
  deployment.apps/argocd-dex-server               1/1     1            1           15h
  deployment.apps/argocd-redis                    1/1     1            1           15h
  deployment.apps/argocd-repo-server              1/1     1            1           15h
  deployment.apps/argocd-server                   1/1     1            1           15h

  NAME                                                      DESIRED   CURRENT   READY   AGE
  replicaset.apps/argocd-application-controller-544c45984   1         1         1       15h
  replicaset.apps/argocd-dex-server-7cd54b9d86              1         1         1       15h
  replicaset.apps/argocd-redis-5ddd577d68                   1         1         1       15h
  replicaset.apps/argocd-repo-server-69fc78b68              1         1         1       15h
  replicaset.apps/argocd-server-7c5f6f8d9                   1         1         1       15h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;서비스가 정상적으로 배포가 되었다면 argocd에 접근하기 위해 argocd-server에 대한 NodePort를 생성해준다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 30093으로 정의하였고, 마찬가지로 GCP 방화벽에서도 해당 포트번호를 추가해주어야 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim argocd-nodeport.yaml 
  apiVersion: v1
  kind: Service
  metadata:
    name: argocd
  spec:
  &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: NodePort
  selector:
    app.kubernetes.io/instance: argocd
    app.kubernetes.io/name: argocd-server
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
      nodePort: 30093
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이제 ArgoCD에 접속하여 로그인을 시도해본다.&lt;/p&gt;

    &lt;p&gt;Helm으로 배포했을 때 초기 아이디는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt;, 패스워드는 ArgoCD 파드명 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argocd-server-7c5f6f8d9-xkc8h&lt;/code&gt; 이다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ArgoCD 설정&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 로그인이 이루어지면 Git 레포지토리를 추가하는 작업을 해주어야 한다.&lt;/p&gt;

    &lt;p&gt;왼쪽의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt; 탭에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repositories&lt;/code&gt; 항목을 눌러 다음 [그림 9]와 같이 레포지토리를 추가해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_9.png&quot; alt=&quot;argocd_repo&quot; width=&quot;680&quot; height=&quot;239&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] ArgoCD 레포지토리 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 레포지토리가 연결되면 [그림 10]과 같이 상태 부분에 &lt;strong&gt;Successful&lt;/strong&gt; 이라는 문구가 뜨게 된다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_10.png&quot; alt=&quot;argocd_repo_check&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] ArgoCD 레포지토리 추가 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Applications&lt;/code&gt; 탭에 와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEW APP&lt;/code&gt; 버튼을 눌러 배포를 관리할 애플리케이션을 추가해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_11.png&quot; alt=&quot;argocd_app&quot; width=&quot;638&quot; height=&quot;453&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] ArgoCD 애플리케이션 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;애플리케이션 이름을 정의해주고 아래로 내리면 [그림 12]와 같은 화면이 나온다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_12.png&quot; alt=&quot;argocd_app2&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] ArgoCD 애플리케이션 추가2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;레포지토리 주소와 배포할 yaml 파일들이 들어있는 경로를 명시해주고, 배포할 쿠버네티스의 클러스터 주소와 네임스페이스까지 작성하여 애플리케이션을 만들어준다.&lt;/p&gt;

    &lt;p&gt;정상적으로 애플리케이션이 만들어지면 다음 [그림 13]과 같이 ArgoCD에서 Git 레포지토리와 연동된 애플리케이션을 볼 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_13.png&quot; alt=&quot;argocd_app_check&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] ArgoCD 애플리케이션 추가 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;동기화 되지 않은 상태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OutOfSync&lt;/code&gt;라는 문구와 &lt;strong&gt;노란색&lt;/strong&gt;으로 표현이 되고, Sync 버튼을 눌러주면 쿠버네티스 클러스터에 자동으로 배포가 되면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sync OK&lt;/code&gt; 라는 문구와 함께 &lt;strong&gt;초록색&lt;/strong&gt;으로 바뀌어 정상 동작하는 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;ArgoCD에서 정상적으로 동기화를 시켜주면 다음 [그림 14]와 같은 화면을 보실 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_3_14.png&quot; alt=&quot;argocd_sync&quot; width=&quot;952&quot; height=&quot;309&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 14] ArgoCD 배포 동기화&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;[그림 13]에서 애플리케이션을 선택해 들어가면 [그림 14]와 같이 실행중인 애플리케이션을 지속적으로 모니터링할 수 있는 화면이 나오게 된다.&lt;/p&gt;

    &lt;p&gt;Git 레포지토리와 쿠버네티스 클러스터와의 차이점을 보고하고 시각화하는 동시에 라이브 상태를 원하는 상태로 동기화하는 기능을 제공한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기까지 Jenkins를 활용하여 쿠버네티스를 연동하여 CD를 구성하고 ArgeCD 설치 및 설정하는 과정을 살펴보았다.&lt;/p&gt;

    &lt;p&gt;다음 포스팅에서는 Helm을 활용하여 Prometheus와 Grafana를 구성하여 모니터링 시스템을 구축하고, EFK(Elasticsearch, Fluent Bit, Kibana)를 구성하여 로깅 시스템을 구축하는 방법에 대해 기술해보겠다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 11 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/10/11/devsecops3.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/10/11/devsecops3.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>jenkins</category>
        
        <category>cd</category>
        
        <category>argocd</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - CI 구성</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. CI(Continuous Integration) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.2. CI 란?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. GitLab - Jenkins 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. GitLab - Jenkins 웹훅 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. Jenkins 파이프라인 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 파이프라인 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. Jenkins - Docker 연동 및 파이프라인 테스트&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-cicontinuous-integration-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. CI(Continuous Integration) 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CI 란?&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;CI 란 팀의 구성원들이 작업한 내용을 정기적으로 통합하는 것을 의미한다.&lt;/p&gt;

    &lt;p&gt;개발자들은 소스 코드를 정기적으로 Git, SVN 과 같은 SCM(Source Code Management, 형상 관리 시스템)에 Push 하는데, &lt;strong&gt;각각의 개발자들로부터 Push된 소스 코드들을 정기적으로 통합하는 것을 CI&lt;/strong&gt;라고 한다.&lt;/p&gt;

    &lt;p&gt;CI를 구축하지 않은 경우 개발자들이 각자 개발한 소스 코드를 형상 관리 서버에 Commit 하면 별도의 품질관리를 거치지 않고 대부분 개발이 끝난 막바지에 통합을 하여 테스트를 진행하게 된다.&lt;/p&gt;

    &lt;p&gt;이럴경우, 개발 중 별도의 품질 관리를 수행하지 않았기 때문에 잘못된 소스 코드를 형상관리 시스템에 반영하였을 경우 발생되는 문제가 개발 후반에 모두 장애로 발견된다.&lt;/p&gt;

    &lt;p&gt;반면에 CI를 구축하게 되면 CI 서버는 형상 관리 서버에 Push 된 소스코드를 주기적으로 폴링하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴파일, 단위테스트, 코드 인스펙션&lt;/code&gt; 등의 과정을 수행하며 &lt;strong&gt;신규 또는 수정된 소스 코드에 결함이 있는지에 대한 여부를 지속적으로 검증&lt;/strong&gt;하기 때문에 조기에 결함을 발견하여 해결할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GitLab - Jenkins 연동&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;먼저 SCM 툴인 Gitlab과 CI/CD Server 툴로 사용할 Jenkins를 연동하는 작업을 시작해보자.&lt;/p&gt;

    &lt;p&gt;[그림 1]과 같이 관리자 계정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Admin Area &amp;gt; Network&lt;/code&gt; 탭으로 들어와 아웃바운드를 설정한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_1.png&quot; alt=&quot;gitlab_outbound&quot; width=&quot;761&quot; height=&quot;650&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] GitLab 네트워크 아웃바운드 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;웹훅 및 서비스가 액세스 할 수 있는 IP, 즉 Jenkins 서버의 IP를 적어준다.&lt;/p&gt;

    &lt;p&gt;다음으로 &lt;strong&gt;GitLab 프로젝트를 생성&lt;/strong&gt;하여 해당 프로젝트의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings &amp;gt; Access Tokens&lt;/code&gt; 탭에 들어온다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_2.png&quot; alt=&quot;gitlab_access_token&quot; width=&quot;671&quot; height=&quot;612&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] GitLab Access Token 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 2]와 같이 토큰 명과 만료일을 설정하고 액세스 토큰을 생성하면 토큰 값이 나온다.&lt;/p&gt;

    &lt;p&gt;토큰 값은 Jenkins에서 credentials를 생성할 때 필요하기 때문에 따로 기록해둔다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Jenkins의 설정의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plugin Manager&lt;/code&gt; 탭으로 GitLab 관련한 플러그인을 모두 설치해준다.&lt;/p&gt;

    &lt;p&gt;GitLab 플러그인이 정상적으로 설치되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 설정&lt;/code&gt;으로 들어와서 [그림 3]과 같이 Gitlab을 연동하기 위한 설정을 해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_3.png&quot; alt=&quot;jenkins_gitlab_config&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Jenkins에서 GitLab 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;GitLab 호스트의 URL 및 포트를 적어주고 Credentials는 Add 버튼을 눌러 다음 [그림 4]와 같이 생성해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_4.png&quot; alt=&quot;jenkins_gitlab_credentials&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Jenkins에서 GitLab Credentials 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Credentials 키를 정상적으로 생성 및 선택해주고 오른쪽 하단의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Connection&lt;/code&gt; 버튼을 눌러 Success 문구가 뜨는지 확인한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GitLab - Jenkins 웹훅 설정&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins와 Gitlab을 성공적으로 연동시키고 나서 Jenkins 메인 화면에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로운 Item&lt;/code&gt; 탭을 눌러준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_5.png&quot; alt=&quot;jenkins_new_item&quot; width=&quot;831&quot; height=&quot;402&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Jenkins Item 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 5]와 같이 파이프라인을 선택하고 아이템의 이름을 명시하고 OK 버튼을 눌러 아이템을 만들어준다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devsecops-pipeline&lt;/code&gt;라는 이름의 아이템을 만들어주었다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Jenkins에서 아이템을 정상적으로 만들어준 후에 Giblab의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings &amp;gt; Webhooks&lt;/code&gt; 탭으로 들어온다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_6.png&quot; alt=&quot;gitlab_webhook&quot; width=&quot;754&quot; height=&quot;357&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] GitLab 웹훅 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 6]와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://JenkinsID:JenkinsPassword@JenkinsIP:JenkinsPort/project/ProjectName&lt;/code&gt;의 형태로 URL을 작성해준다.&lt;/p&gt;

    &lt;p&gt;일단 설정은 푸시 이벤트에 대한 트리거만 걸어놓고 차후 멀티 브랜치에 대한 파이프라인 구성도 진행해볼 것이다.&lt;/p&gt;

    &lt;p&gt;웹훅 설정을 마치고 아래로 내리면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test&lt;/code&gt; 버튼을 눌러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Push events&lt;/code&gt;에 대한 테스트를 진행해본다.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hook executed successfully: HTTP 200&lt;/code&gt; 메시지가 뜨면 푸시 이벤트에 대한 웹훅도 정상적으로 설정되어 Jenkins를 통해 CI를 구성할 준비가 끝난 것이다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-jenkins-파이프라인-설정---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. Jenkins 파이프라인 설정&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipeline 설정 및 테스트&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;[그림 5]에서 생성한 파이프라인의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구성&lt;/code&gt; 탭을 눌러서 다음 [그림 7]과 같이 Gitlab에 푸시되면 자동으로 파이프라인이 실행될 수 있도록 설정해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_7.png&quot; alt=&quot;gitlab_webhook&quot; width=&quot;846&quot; height=&quot;478&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] GitLab 웹훅 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;아래로 쭉 내리면 [그림 8]과 같이 파이프라인 스크립트를 작성할 수 있는 공간이 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_8.png&quot; alt=&quot;echo_hello_world&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] Hello World 파이프라인 스크립트 작성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Gitlab에 푸시했을 때 정상적으로 파이프라인이 작동하는지만 확인해보기 위해 ‘Hello World’를 출력하는 간단한 스크립트를 작성하여 설정을 저장했다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그러고나서 깃 푸시 이벤트를 보내면 다음 [그림 9]와 같이 자동으로 설정해둔 파이프라인이 정상적으로 실행되는 것을 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_9.png&quot; alt=&quot;pipeline_result&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] 파이프라인 실행 결과 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;실행된 파이프라인에 대한 로그는 해당 빌드 넘버를 클릭하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Console Output&lt;/code&gt; 탭을 눌러 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_10.png&quot; alt=&quot;build_console&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] 파이프라인 실행 콘솔 로그 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;[그림 10]에서 볼 수 있듯이 정상적으로 파이프라인이 실행되어 콘솔에 ‘Hello World’ 문구가 출력된 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins - Docker 연동 및 파이프라인 테스트&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Gitlab과 Jenkins가 정상적으로 연동되어 Git Push에 의해 자동으로 파이프라인이 실행되는 부분까지 진행하였고 다음으로 파이프라인에서 &lt;strong&gt;git clone하여&lt;/strong&gt; 프로젝트 폴더의 Dockerfile을 통해 빌드하여 &lt;strong&gt;Docker hub에 푸시하는 부분까지 진행&lt;/strong&gt;해보겠다.&lt;/p&gt;

    &lt;p&gt;우선 Jenkins가 설치되어 있는 노드에서 Git 혹은 Docker 관련 스크립트 실행시 커맨드 에러가 발생할 수 있으므로 servers 인스턴스에서 다음 명령어를 통해 파이프라인에서 Git과 Docker 명령을 사용할 수 있도록 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker docker-registry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;docker 명령을 입력했을 때 권한 에러를 해결하기 위한 설정도 해주어야 한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;service docker restart
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo chmod &lt;/span&gt;777 /var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그리고 Jenkins에서 [그림 11]에 보이는 Docker 관련 플러그인을 설치해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_11.png&quot; alt=&quot;docker_plugin_installation&quot; width=&quot;788&quot; height=&quot;319    &quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] Jenkins에서 Docker 플러그인 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 Docker hub에 로그인 할 계정의 Credentials을 생성해야 한다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;추후 Harbor를 구축하여 연동해볼 예정&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_12.png&quot; alt=&quot;docker_hub_credentials&quot; width=&quot;636&quot; height=&quot;239&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] Docker hub credentials 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 Docker 관련 설정이 정상적으로 완료되면 파이프라인 스크립트를 다음과 같이 작성해준다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pipeline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      environment &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          registry &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;crisis513/flask-app&quot;&lt;/span&gt;
          registryCredential &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;crisis513&apos;&lt;/span&gt;
          dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;
          releaseName &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;flask-app&quot;&lt;/span&gt;
          release_version &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;latest&apos;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      agent any
      stages &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cloning our Git&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  git &lt;span class=&quot;s1&quot;&gt;&apos;http://GITLAB_SERVER_IP:8001/root/flask-app.git&apos;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Building docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      dockerImage &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; docker.build registry + &lt;span class=&quot;s2&quot;&gt;&quot;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Deploy docker image&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  script &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                      docker.withRegistry&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&apos;&lt;/span&gt;, registryCredential &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                          dockerImage.push&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cleaning up&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              steps &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                  sh &lt;span class=&quot;s2&quot;&gt;&quot;docker rmi &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$registry&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;release_version&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;파이프라인 스크립트의 문법에 대해 알고싶다면 &lt;a href=&quot;https://www.jenkins.io/doc/book/pipeline/syntax/&quot;&gt;Jenkins Pipeline Syntax&lt;/a&gt;에서 확인&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;파이프라인은 다음과 같이 실행된다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;GitLab 서버에서 flask-app 프로젝트를 가져와서 프로젝트 내의 Dockerfile을 통해 빌드하고 ‘crisis513’ 이라는 ID를 가진 credentials를 통해 Docker hub에 로그인 하여 해당 도커 레포지토리(registry)에 release_version에 해당하는 태그를 붙여 푸시하고 로컬에 생성된 도커 이미지는 삭제된다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Dockerfile의 내용은 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  FROM python:alpine

  RUN apk add &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; linux-headers build-base

  COPY requirements.txt /requirements.txt

  RUN pip &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; /requirements.txt

  COPY ./app /app
  WORKDIR /app
  RUN pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;flask

  RUN &lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database.db
  RUN python ./setup.py

  EXPOSE 8080
  CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;uwsgi&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;--ini&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;conf.ini&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;해당 Dockerfile이 포함된 프로젝트는 &lt;a href=&quot;https://github.com/crisis513/flask-app&quot;&gt;git - crisis513/flask-app&lt;/a&gt;에서 확인 가능&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;위의 파이프라인이 정상적으로 실행된 결과는 다음 [그림 13]과 같다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_2_13.png&quot; alt=&quot;docker_push_pipeline_result&quot; width=&quot;858&quot; height=&quot;382&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] Docker 푸시까지의 파이프라인 실행 결과&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Docker hub에 접속하면 도커 이미지도 정상적으로 푸시된 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기까지 &lt;strong&gt;GitLab - Jenkins - Docker&lt;/strong&gt;를 연동하여 Git 푸시 이벤트가 발생했을 때 Git 프로젝트를 clone하여 Dockerfile을 빌드하여 Docker hub에 푸시하기까지의 과정을 모두 살펴보았다.&lt;/p&gt;

    &lt;p&gt;다음 포스팅에서는 CD(Continuous Delivery/Continuous Deployment) 환경을 구성하는 방법에 대해 기술해보겠다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 08 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/10/08/devsecops2.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/10/08/devsecops2.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>gitlab</category>
        
        <category>jenkins</category>
        
        <category>ci</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] DevSecOps 프로젝트 - 개요 및 환경 구성</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.1. 프로젝트 소개&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 프로젝트 목적&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. 프로젝트 아키텍처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 환경 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. GCP(Google Cloud Platform) 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 쿠버네티스 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. GitLab 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_4&quot;&gt;   2.4. Jenkins 구성&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-프로젝트-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 프로젝트 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 소개&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;DevSecOps란 DevOps에 보안 즉, Security를 접목시킨 용어로 소프트웨어 개발과 운영을 접합한 소프트웨어 개발 라이프 사이클에 보안을 내장한 개발 프로세스이다.&lt;/p&gt;

    &lt;p&gt;많은 기업들이 클라우드 환경으로의 디지털 트랜스포메이션을 진행하면서, 기존의 보안 쳬계와 다른 클라우드 네이티브 환경에서의 보안을 어렵게 생각하는 경우가 많다.&lt;/p&gt;

    &lt;p&gt;온프레미스와는 전혀 다른 방식으로 보안을 구현해야하는 필요성이 대두되었고, 클라우드 환경에서는 기업마다 다른 개발환경과 개발문화로 인한 변화의 폭이 훨씬 크므로, 자동화되고 가시화된 개발보안방법론인 DevSecOps 쳬계를 적용하므로써 빠르게 변화하는 서비스 개발 속도에 발맞춰 보안의 속도도 따라가야 할 필요가 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 목적&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트를 통해 클라우드 네이티브 환경에서 DevSecOps 체계를 구현하는데 필요한 툴 체인들을 이해하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보안이 적용된 다양한 툴 체인 파이프라인 방법들을 구축&lt;/code&gt;하고자 한다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;클라우드 네이티브 환경에서의 DevSecOps 쳬계와 CI/CD 체계를 이해&lt;/strong&gt;하고, 이 체계에 적용되는 보안 분석 도구들을 구축하여 &lt;strong&gt;실제 서비스 개발 프로세스에 적용할 수 있는 DevSecOps 툴체인 파이프라인 구축하는 것이 목적&lt;/strong&gt;이다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 아키텍처&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트의 아키텍처는 다음 [그림 1]과 같다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_1.png&quot; alt=&quot;devops_architecture&quot; width=&quot;778&quot; height=&quot;513&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] DevOps 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;GitLab, Jenkins, Harbor, Helm을 이용해 CI(Continuous Integration)를, Jenkins, ArgoCD, Kubernetes를 통해 CD(Continuous Delivery/Continuous Deployment) 환경을 구축하고 파이프라인 실행 결과를 Slack으로 전달한다.&lt;/p&gt;

    &lt;p&gt;그리고 서비스 운영에 필요한 로깅 시스템은 EFK(Elasticsearch-Fluentd-Kibana)를, 모니터링 시스템은 Prometheus, Grafana를 쿠버네티스의 서비스 형태로 구축했다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;[그림 1]은 현재(2020-10-17)까지 진행된 부분이며, Security에 대한 파이프라인은 미완성으로 추후 아키텍처를 업데이트 할 예정임&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-환경-구성---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 환경 구성&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GCP(Google Cloud Platform) 구성&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;GCP의 기능으로 있는 GKE(Google Kubernetes Engine)을 사용하여 손 쉽게 쿠버네티스 환경을 구성할 수 있지만, 현재는 테스트용으로 인스턴스를 따로 생성하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubeadm&lt;/code&gt;을 통해 쿠버네티스를 구성할 것이다.&lt;/p&gt;

    &lt;p&gt;따라서 다음 [그림 2]와 같이 GCP 인스턴스를 생성해준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_2.png&quot; alt=&quot;gcp_instance&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] GCP 인스턴스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인스턴스 생성할 때의 설정은 다음과 같다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;리전: asia-northeast3(서울)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;머신 계열: n1-standard-2(vCPU 2개, 7.5GB 메모리)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;부팅 디스크: CentOS 7&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;액세스 범위: 모든 Cloud API에 대한 전체 액세스 허용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;방화벽: HTTP/HTTPS 트래픽 허용&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;추가로 [VPC 네트워크] - [외부 IP 주소] 탭에 들어가 각 인스턴스들의 IP를 고정으로 바꿔주었다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;쿠버네티스 구성&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;위에서 언급하였듯 생성한 인스턴스에 kubeadm 명령을 통해 쿠버네티스를 구성한다.&lt;/p&gt;

    &lt;p&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-master, kube-worker1, kube-worker2 모두&lt;/code&gt; 동일하게 아래의 명령을 실행하도록 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;쿠버네티스 설치를 위한 모든 과정은 root 권한으로 진행한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;su -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;스왑 메모리의 사용을 중지한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;swapoff &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;0 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/vm/swappiness
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;/swap/ s/^#*/#/&apos;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;Swap은 디스크의 일부 공간을 메모리처럼 사용하는 기능이다. 
  Kubelet이 정상 동작할 수 있도록 swap 디바이스와 파일 모두 disable 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;각 노드의 통신을 원활하게 하기 위해 방화벽을 해제하고 SELinux를 비활성화 시켜준다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl disable firewalld
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl stop firewalld

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;setenforce 0
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;s/^SELINUX=enforcing$/SELINUX=permissive/&apos;&lt;/span&gt; /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RHEL과 CentOS 7에서 iptables 관련 이슈가 있어 커널 매개변수를 다음과 같이 수정하고 적용한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt;  /etc/sysctl.d/k8s.conf
  net.bridge.bridge-nf-call-ip6tables = 1
  net.bridge.bridge-nf-call-iptables = 1
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;  EOF

&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sysctl &lt;span class=&quot;nt&quot;&gt;--system&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;br_netfilter 모듈을 활성화한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;modprobe br_netfilter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;br_netfilter 모듈을 명시적으로 추가한 후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsmod | grep br_netfilter&lt;/code&gt; 명령어로 추가 여부를 확인할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도커 및 쿠버네티스 설치 후 서비스 시작&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;docker &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start docker.service

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt; /etc/yum.repos.d/kubernetes.repo
  [kubernetes]
  name=Kubernetes
  baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
  enabled=1
  gpgcheck=1
  repo_gpgcheck=1
  gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
  exclude=kube*
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;  EOF

&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; yum-utils device-mapper-persistent-data lvm2
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum-config-manager &lt;span class=&quot;nt&quot;&gt;--add-repo&lt;/span&gt; https://download.docker.com/linux/centos/docker-ce.repo 
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-ce-18.06.2.ce
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--disableexcludes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kubernetes kubeadm-1.15.5-0.x86_64 kubectl-1.15.5-0.x86_64 kubelet-1.15.5-0.x86_64
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;kubelet &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;본 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;헬스체크 이슈&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대쉬보드 호환성&lt;/code&gt;의 이유로 비교적 안정적인 쿠버네티스 1.15 버전으로 명시하여 설치했다.&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;처음에 1.19 버전으로 설치했었다가 쿠버네티스 클러스터의 매트릭을 수집해주는 &lt;strong&gt;kube-state-metrics&lt;/strong&gt;이 정상적으로 작동하지 않아 1.15버전으로 재설치했다.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-master&lt;/code&gt;에서만 아래의 명령을 실행하도록 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨트롤 구성 요소들의 이미지를 설치한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm config images pull
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kube-master 노드를 초기화 해준다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm init
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;init] Using Kubernetes version: v1.15.5
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Running pre-flight checks
          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;WARNING Service-Kubelet]: kubelet service is not enabled, please run &lt;span class=&quot;s1&quot;&gt;&apos;systemctl enable kubelet.service&apos;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Pulling images required &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;setting up a Kubernetes cluster
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] This might take a minute or two, depending on the speed of your internet connection
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] You can also perform this action &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;beforehand using &lt;span class=&quot;s1&quot;&gt;&apos;kubeadm config images pull&apos;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet environment file with flags to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/kubeadm-flags.env&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet configuration to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/config.yaml&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Activating the kubelet service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;certs] Using certificateDir folder &lt;span class=&quot;s2&quot;&gt;&quot;/etc/kubernetes/pki&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;certs] Generating &lt;span class=&quot;s2&quot;&gt;&quot;ca&quot;&lt;/span&gt; certificate and key

  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Your Kubernetes control-plane has initialized successfully!
  To start using your cluster, you need to run the following as a regular user:
  &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube
  &lt;span class=&quot;nb&quot;&gt;sudo cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; /etc/kubernetes/admin.conf &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
  &lt;span class=&quot;nb&quot;&gt;sudo chown&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;:&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
  You should now deploy a pod network to the cluster.
  Run &lt;span class=&quot;s2&quot;&gt;&quot;kubectl apply -f [podnetwork].yaml&quot;&lt;/span&gt; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/
  Then you can &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;any number of worker nodes by running the following on each as root:
  kubeadm &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;10.178.0.19:6443 &lt;span class=&quot;nt&quot;&gt;--token&lt;/span&gt; tcqjev.d775p70aj3dseele &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;--discovery-token-ca-cert-hash&lt;/span&gt; sha256:d9f67f85ea3e5ca8821dd311cf0c3c886d9637c14814b61f15f67e06f732b200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kubeadm init의 결과에서 나온 것 처럼 일반 사용자가 kubectl 명령을 사용할 수 있도록 환경변수를 설정한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; /etc/kubernetes/admin.conf &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo chown&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;:&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.kube/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 kubeadm init의 결과에서 나온 것 처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-worker 노드들&lt;/code&gt;에서만 아래의 명령을 실행하도록 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;컨트롤 구성 요소들의 이미지를 설치한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;10.178.0.19:6443 &lt;span class=&quot;nt&quot;&gt;--token&lt;/span&gt; tcqjev.d775p70aj3dseele &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;--discovery-token-ca-cert-hash&lt;/span&gt; sha256:d9f67f85ea3e5ca8821dd311cf0c3c886d9637c14814b61f15f67e06f732b200
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Running pre-flight checks
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] Reading configuration from the cluster...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;preflight] FYI: You can look at this config file with &lt;span class=&quot;s1&quot;&gt;&apos;kubectl -n kube-system get cm kubead
  m-config -oyaml&apos;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Downloading configuration &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the kubelet from the &lt;span class=&quot;s2&quot;&gt;&quot;kubelet-config-1.15&quot;&lt;/span&gt; Con
  figMap &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the kube-system namespace
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet configuration to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/config.yaml&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Writing kubelet environment file with flags to file &lt;span class=&quot;s2&quot;&gt;&quot;/var/lib/kubelet/kubead
  m-flags.env&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Activating the kubelet service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;kubelet-start] Waiting &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the kubelet to perform the TLS Bootstrap...
  This node has joined the cluster:
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Certificate signing request was sent to apiserver and a response was received.
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; The Kubelet was informed of the new secure connection details.
  Run &lt;span class=&quot;s1&quot;&gt;&apos;kubectl get nodes&apos;&lt;/span&gt; on the control-plane to see this node &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;the cluster.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;마지막으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-master&lt;/code&gt;에서 weave를 설치한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;kubectl apply를 통해 weave 생성&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://cloud.weave.works/k8s/net?k8s-version=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl version | &lt;span class=&quot;nb&quot;&gt;base64&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;tr&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;\n&apos;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  serviceaccount/weave-net created
  clusterrole.rbac.authorization.k8s.io/weave-net created
  clusterrolebinding.rbac.authorization.k8s.io/weave-net created
  role.rbac.authorization.k8s.io/weave-net created
  rolebinding.rbac.authorization.k8s.io/weave-net created
  daemonset.apps/weave-net created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;CNI(Container Network Interface)를 설치하면 CoreDNS Pod가 정상적으로 동작하게 된다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;쿠버네티스 클러스터가 정상적으로 구성되었는지 확인해본다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get nodes
  NAME           STATUS   ROLES    AGE   VERSION
  kube-master    Ready    master   1d   v1.15.5
  kube-worker1   Ready    &amp;lt;none&amp;gt;   1d   v1.15.5
  kube-worker2   Ready    &amp;lt;none&amp;gt;   1d   v1.15.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get cs
  NAME                 STATUS    MESSAGE             ERROR
  controller-manager   Healthy   ok                  
  scheduler            Healthy   ok                  
  etcd-0               Healthy   &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;health&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get po &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; custom-columns&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;POD:metadata.name,NODE:spec.nodeName &lt;span class=&quot;nt&quot;&gt;--sort-by&lt;/span&gt; spec.nodeName &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system
  POD                                   NODE
  kube-proxy-ks9ss                      kube-master
  etcd-kube-master                      kube-master
  kube-apiserver-kube-master            kube-master
  kube-controller-manager-kube-master   kube-master
  kube-scheduler-kube-master            kube-master
  weave-net-4g8fj                       kube-master
  kube-proxy-mg5z5                      kube-worker1
  weave-net-rjqk5                       kube-worker1
  coredns-5c98db65d4-xd8lw              kube-worker1
  coredns-5c98db65d4-zf5kx              kube-worker2
  weave-net-gvwqv                       kube-worker2
  kube-proxy-7jd9r                      kube-worker2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;GitLab 구성&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Gitlab과 Jenkins 설치는 [그림 2]의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;servers 인스턴스&lt;/code&gt;에서 진행한다.&lt;/p&gt;

    &lt;p&gt;GitLab은 자체 CI를 무료로 제공하고 있어 외부 CI 서비스를 사용할 필요가 없다.&lt;/p&gt;

    &lt;p&gt;하지만 Jenkins에서 제공되는 플러그인이 많기 때문에 보안을 적용한 파이프라인을 구축하기에는 외부 CI/CD 서비스인 Jenkins를 사용할 것이고, 기존의 서비스 중인 Github 혹은 Gitlab을 사용해도 무방하다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;GitLab 설치 및 설정&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;# openssh 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; curl policycoreutils-python openssh-server openssh-clients

  &lt;span class=&quot;c&quot;&gt;# 서버 부팅 시 sshd 실행&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;sshd &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start sshd

  &lt;span class=&quot;c&quot;&gt;# 방화벽 해제&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 메일서버 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; postfix

  &lt;span class=&quot;c&quot;&gt;# 서버 부팅 시 메일서버 실행&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;postfix &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start postfix

  &lt;span class=&quot;c&quot;&gt;# gitlab 패키치 저장소 등록 및 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sS&lt;/span&gt; https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;bash
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;EXTERNAL_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;servers IP:8001&quot;&lt;/span&gt; yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; gitlab-ce
  gitlab Reconfigured!

      &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;                 &lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;*****&lt;/span&gt;               &lt;span class=&quot;k&quot;&gt;*****&lt;/span&gt;
      .&lt;span class=&quot;k&quot;&gt;******&lt;/span&gt;             &lt;span class=&quot;k&quot;&gt;*******&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;********&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;********&lt;/span&gt;
  ,,,,,,,,,&lt;span class=&quot;k&quot;&gt;***********&lt;/span&gt;,,,,,,,,,
  ,,,,,,,,,,,&lt;span class=&quot;k&quot;&gt;*********&lt;/span&gt;,,,,,,,,,,,
  .,,,,,,,,,,,&lt;span class=&quot;k&quot;&gt;*******&lt;/span&gt;,,,,,,,,,,,,
      ,,,,,,,,,&lt;span class=&quot;k&quot;&gt;*****&lt;/span&gt;,,,,,,,,,.
          ,,,,,,,&lt;span class=&quot;k&quot;&gt;****&lt;/span&gt;,,,,,,
              .,,,&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt;,,,,
                  ,&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,.


      _______ __  __          __
      / ____&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; /_/ /   ____ _/ /_
  / / __/ / __/ /   / __ &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/ __ &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  / /_/ / / /_/ /___/ /_/ / /_/ /
  &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;___/_/&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;_/_____/&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;_,_/_.___/


  Thank you &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;installing GitLab!
  GitLab should be available at http://servers IP:8001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;Gitlab이 정상적으로 설치되면 Gitlab에서 사용할 포트 및 기타 설정을 해준다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;# GitLab 설정파일에서 해당 라인 주석 해제 혹은 추가&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi /etc/gitlab/gitlab.rb
  32 external_url &lt;span class=&quot;s1&quot;&gt;&apos;http://servers IP:8001&apos;&lt;/span&gt;
  ...&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;중략&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  1215 nginx[&lt;span class=&quot;s1&quot;&gt;&apos;enable&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true 
  &lt;/span&gt;1216 nginx[&lt;span class=&quot;s1&quot;&gt;&apos;client_max_body_size&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2G&apos;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 변경된 설정 적용&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gitlab-ctl reconfigure

  &lt;span class=&quot;c&quot;&gt;# 8001 방화벽 해제&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8001/tcp
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;Gitlab의 설정을 끝내고 Gitlab에 접속하기 전에 &lt;strong&gt;GCP의 방화벽도 열어주어야 외부에서 접근이 가능&lt;/strong&gt;하다.&lt;/p&gt;

        &lt;p&gt;다음 [그림 3]과 같이 &lt;strong&gt;[VPC 네트워크] - [방화벽] 탭&lt;/strong&gt;에서 servers에서 사용할 포트들을 열어주기 위한 방화벽 규칙을 생성해준다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_3.png&quot; alt=&quot;gcp_firewall&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] GCP 방화벽 포트 오픈&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;GCP 방화벽까지 열어주고나서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;servers IP:8001&lt;/code&gt; URL로 접속하면 다음 [그림 3]과 같이 root 계정의 초기 패스워드를 지정하는 화면을 볼 수 있다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_4.png&quot; alt=&quot;gitlab_new_password&quot; width=&quot;569&quot; height=&quot;385&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] GitLab 접속 후 패스워드 변경&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jenkins 구성&lt;/strong&gt;   &lt;a name=&quot;list2_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Jenkins 설치 및 설정&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;# Java 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; java-1.8.0-openjdk-devel.x86_64

  &lt;span class=&quot;c&quot;&gt;# JAVA_HOME 환경변수 확인&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;which javac
  /usr/bin/javac
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;readlink&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /usr/bin/javac
  /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/bin/javac

  &lt;span class=&quot;c&quot;&gt;# 경로 뒤의 /bin/javac는 제외하고 JAVA_HOME 환경변수 설정&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;sudo tee&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /etc/profile
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;
  /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64

  &lt;span class=&quot;c&quot;&gt;# maven 설치 (http://maven.apache.org/download.cgi)&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo mkdir&lt;/span&gt; /tools
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tools
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;wget http://mirror.apache-kr.org/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo tar &lt;/span&gt;xzf apache-maven-3.6.3-bin.tar.gz
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; apache-maven-3.6.3 maven
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi /etc/profile.d/maven.sh
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;MAVEN_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/tools/maven
  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;MAVEN_HOME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/bin:&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile.d/maven.sh

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mvn &lt;span class=&quot;nt&quot;&gt;-version&lt;/span&gt;
  Apache Maven 3.6.3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cecedd343002696d0abb50b32b541b8a6ba2883f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  Maven home: /tools/maven
  Java version: 1.8.0_262, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre
  Default locale: en_US, platform encoding: UTF-8
  OS name: &lt;span class=&quot;s2&quot;&gt;&quot;linux&quot;&lt;/span&gt;, version: &lt;span class=&quot;s2&quot;&gt;&quot;3.10.0-1127.el7.x86_64&quot;&lt;/span&gt;, &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;amd64&quot;&lt;/span&gt;, family: &lt;span class=&quot;s2&quot;&gt;&quot;unix&quot;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# Jenkins repo 다운로드 및 key import&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;wget &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;rpm &lt;span class=&quot;nt&quot;&gt;--import&lt;/span&gt; https://pkg.jenkins.io/redhat-stable/jenkins.io.key

  &lt;span class=&quot;c&quot;&gt;# Jenkins 설치&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; jenkins

  &lt;span class=&quot;c&quot;&gt;# Jenkins 기본 포트 변경&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi /etc/sysconfig/jenkins
  56 &lt;span class=&quot;nv&quot;&gt;JENKINS_PORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;8002&quot;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 8002 방화벽 해제&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--new-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins &lt;span class=&quot;nt&quot;&gt;--set-short&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Jenkins Service Ports&quot;&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins &lt;span class=&quot;nt&quot;&gt;--set-description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Jenkins service firewalld port exceptions&quot;&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins &lt;span class=&quot;nt&quot;&gt;--add-port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8002/tcp 
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--permanent&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--add-service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;jenkins
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;firewall-cmd &lt;span class=&quot;nt&quot;&gt;--reload&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# 서버 부팅 시 Jenkins 실행&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start jenkins &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;Jenkins에 접속하기 위한 포트는 8002로 설정하였고 GCP 방화벽에서 이미 포트를 열어둔 상태이다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_5.png&quot; alt=&quot;jenkins_install&quot; width=&quot;520&quot; height=&quot;462&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] Jenkins 접속&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;servers IP:8002&lt;/code&gt; URL로 접속하면 위의 [그림 5]와 같이 화면이 뜬다.&lt;/p&gt;

        &lt;p&gt;화면의 안내에 따라 &lt;strong&gt;/var/lib/jenkins/secrets/initialAdminPassword 파일을 확인&lt;/strong&gt;한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo cat&lt;/span&gt; /var/lib/jenkins/secrets/initialAdminPassword
  f05ef37257944b62a80086bbc4b047bf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;Jenkins 초기 비밀번호를 확인하고 입력하여 다음으로 넘어간다.&lt;/p&gt;

        &lt;p&gt;다음은 Customize Jenkins라는 페이지가 나오는데, 여기서는 원하는 Jenkins 플러그인을 설치할 수 있다.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Jenkins 플러그인은 Jenkins가 설치된 이후에도 자유롭게 설치가 가능&lt;/strong&gt;하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Install suggested plugins&lt;/code&gt;를 눌러 기본 플러그인만 설치하고 넘어간다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;p&gt;Jenkins가 정상적으로 설치되면 다음 [그림 6]과 같은 화면이 뜨게 된다.&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/devsecops_1_6.png&quot; alt=&quot;jenkins_main&quot; width=&quot;563&quot; height=&quot;389&quot; /&gt;&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] Jenkins 정상 설치 화면&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이로써 쿠버네티스 클러스터와 GitLab, Jenkins의 설치 및 기본 구성은 끝이 났다.&lt;/p&gt;

    &lt;p&gt;다음 포스팅에서는 CI(Continuous Integration) 환경을 구성하는 방법에 대해 기술해보겠다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 03 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/10/03/devsecops1.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/10/03/devsecops1.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>devsecops</category>
        
        <category>devops</category>
        
        <category>gcp</category>
        
        <category>kubernetes</category>
        
        <category>gitlab</category>
        
        <category>jenkins</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] Linux 취약점 진단 및 평가와 로깅</title>
        <description>&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.1. 프로젝트 목적&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 프로젝트 아키텍처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_3&quot;&gt;   1.3. 취약점 분석 평가 항목&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 프로젝트 구현&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. 스크립트 디렉토리 구조&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. 스크립트 실행&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. Kibana 대시보드 커스터마이징&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 결론&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-프로젝트-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 프로젝트 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 목적&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트는 KISA에서 작성된 &lt;a href=&quot;https://www.krcert.or.kr/data/guideView.do?bulletin_writing_sequence=35988&quot;&gt;주요정보통신기반시설 기술적 취약점 분석 평가 상세 가이드&lt;/a&gt; 문서를 참고하여 기술적인 취약 여부를 검사함으로써 악성코드 유포, 해킹 등 사이버 위협에 대응하기 위해 시작하게 된 프로젝트이다.&lt;/p&gt;

    &lt;p&gt;가이드의 문서를 숙지하기 어려운 부분이 많기 때문에 보안 담당자들이 취약점 점검을 자동으로 손쉽게 취약점 진단을 진행할 수 있도록 운영체제 취약점 진단 자동화 스크립트를 개발하고 배포한다.&lt;/p&gt;

    &lt;p&gt;취약점 점검을 손쉽게 진행할 수 있도록 자동화 스크립트를 개발하고 진단 결과를 한 눈에 확인할 수 있도록 가시화된 데이터를 제공하는 것을 목표로 한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 아키텍처&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음 [그림 1]은 진단 스크립트를 실행하는 것부터 Kibana에서 로그를 확인하는 일련의 과정을 테스트하기 위한 환경을 아키텍처로 나타낸 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_1.png&quot; alt=&quot;project_architecture&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 프로젝트 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;테스트는 Virtualbox에서 진행되었으며, ELK Stack이 설치되어 있는 VM과 진단할 여러 대의 VM을 구성하여 테스트까지 진행했다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;명령어 하나로 [그림 1]의 과정이 모두 진행&lt;/strong&gt;되며, 스크립트를 실행하는 명령어의 &lt;strong&gt;매개변수에 입력되는 노드&lt;/strong&gt;들까지 모두 취약점 진단이 되어 Kibana에서 진단 결과를 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;취약점 분석 평가 항목&lt;/strong&gt;   &lt;a name=&quot;list1_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;취약점 분석은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CentOS 7&lt;/code&gt; 환경에서 진행되며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;항목 중요도가 상&lt;/code&gt;인 진단 항목을 몇 가지 선택하여 진단 스크립트를 작성했다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서 선택한 진단 항목은 다음 [그림 2]와 같다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_2.png&quot; alt=&quot;analysis_list&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 진단 항목 리스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-프로젝트-구현---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 프로젝트 구현&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스크립트 디렉토리 구조&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;son@elk linux_diagnosis]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tree &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
  ├── lib
  │   ├── diagnosis_1
  │   ├── diagnosis_2
  │   └── &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;
  ├── log
  │   └── diagnosis_script.debug
  ├── main_diagnosis.sh
  └── U-13_filelist

  2 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서 취약점을 진단하기 위해 사용되는 스크립트의 디렉토리 구조를 나타낸다. 각 파일들에 대한 설명은 다음과 같다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;lib/diagnosis_1 : KISA 가이드 문서의 ‘계정 관리’ 진단 부분을 실행하는 파일&lt;/li&gt;
      &lt;li&gt;lib/diagnosis_2 : KISA 가이드 문서의 ‘파일 및 디렉토리 관리’ 진단 부분을 실행하는 파일&lt;/li&gt;
      &lt;li&gt;lib/function : 스크립트를 실행하면서 남겨지는 로그와 Elasticsearch로 데이터를 전송할 때 필요한 함수들을 정의한 파일&lt;/li&gt;
      &lt;li&gt;log/diagnosis_script.debug : main_diagnosis.sh 스크립트에서 실행되는 명령어와 실행 결과를 기록한 파일&lt;/li&gt;
      &lt;li&gt;main_diagnosis.sh : 취약점 진단을 위한 스크립트 실행 파일&lt;/li&gt;
      &lt;li&gt;U-13_filelist : U-13 항목에서 진단할 파일 리스트를 작성한 파일&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스크립트 실행&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;취약점 진단에는 시스템 파일을 확인하는 경우가 많기 때문에 root로 실행하거나 sudo를 앞에 삽입하여 실행하도록 구현했다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 3]은 일반 유저로 스크립트를 실행했을 때의 결과이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_3.png&quot; alt=&quot;failed_execute&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] 일반 유저의 스크립트 실행 실패&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;스크립트가 재대로 실행되었을 때의 화면은 다음 [그림 4]와 같이 출력된다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_4.png&quot; alt=&quot;succeed_execute&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] 정상적인 스크립트 실행 결과&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;root 권한과 함께 스크립트를 실행하면 정상적으로 취약점 진단이 실행되며, 항목 코드 별로 진단 결과가 출력된다.&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color:green&quot;&gt;[Good]&lt;/span&gt;은 해당 항목에서 진단한 결과가 양호하다는 것이다.&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;[Weak]&lt;/span&gt;는 진단 결과가 취약하게 나왔으므로 &lt;span style=&quot;color:blue&quot;&gt;[Info]&lt;/span&gt;를 통해 취약점을 보완해야 함을 의미한다.&lt;/p&gt;

    &lt;p&gt;이러한 결과 로그는 스크립트 실행과 동시에 Elasticsearch에 전달되어 Kibana에서 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 4]처럼 main_diagnosis.sh를 실행시킬 때 매개변수로 client.cccr.local의 호스트네임을 매개변수로 넣어서 실행시켰을 때 다음의 [그림 5]와 같이 elk.cccr.local 에서의 진단이 끝나면 곧바로 이어서 매개변수에 기입된 호스트에 대한 진단을 진행하게 된다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_5.png&quot; alt=&quot;execute_with_ssh&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] ssh를 이용하여 매개변수에 기입된 호스트 진단&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;마찬가지로 client.cccr.local 호스트의 진단 결과도 Kibana에서 바로 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;아래의 [그림 6]은 진단 스크립트를 실행시키면서 실행되는 명령어들이 재대로 수행되는지 xtrace를 통해 디버깅할 수 있도록 만든 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_6.png&quot; alt=&quot;debug_sample&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] diagnosis_script.debug 실행 샘플&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;진단하면서 실행되는 코드는 xtrace를 통해 디버깅해볼 수 있도록 log/diagnosis_script.debug 파일로 저장되어 진단이 끝난 후에 확인해볼 수 있다.&lt;/p&gt;

    &lt;p&gt;elk.cccr.local, client.cccr.local에서 실행되는 코드 모두 elk.cccr.local 호스트의 log/diagnosis_script.debug 파일을 통해 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;그리고 다음 [그림 7]은 다른 호스트까지 원격 진단할 수 있도록 개발한 코드이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_7.png&quot; alt=&quot;remote_execute_code&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] elk.cccr.local에서 다른 호스트로의 원격 진단 코드&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ sudo ./main_diagnosis.sh client&lt;/code&gt; 라고 명령어를 입력하면 호스트의 취약점 진단이 끝난 후에 /etc/hosts에 정의된 client 호스트네임을 가진 노드로 진단에 필요한 코드를 전송하여 ssh 접속을 통해 진단을 수행하도록 했다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_8.png&quot; alt=&quot;output_log_code&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] 진단 로그 출력과 Elasticsearch로의 로그 전송 코드&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 8]은 진단 결과를 출력해주는 진단 로그를 출력해주는 함수와 Elasticsearch로 로그를 전송하는 함수를 정의한 것이다.&lt;/p&gt;

    &lt;p&gt;콘솔에서 진단 결과를 출력해주는 함수는 print_good(), print_weak(), print_info() 로 정의되어 있고, 콘솔에 출력하는 동시에 Elasticsearch로 로그를 보내게 된다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Kibana 대시보드 커스터마이징&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Elasticsearch와 Kibana의 설치가 정상적으로 끝나고나면 스크립트를 실행하여 진단 결과 데이터를 Elasticsearch로 전송시켜주면 Kibana에서 인덱스 패턴을 생성할 수 있게 된다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_9.png&quot; alt=&quot;create_index_pattern&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] Kibana에서 인덱스 패턴 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Kibana에 접속하여 &lt;strong&gt;Management &amp;gt; Stack Management &amp;gt; Kibana &amp;gt; Index Patterns 탭&lt;/strong&gt;에 들어가서 &lt;strong&gt;Create index pattern 버튼&lt;/strong&gt;을 누르면 위의 [그림 9]과 같이 인덱스 패턴을 생성할 수 있는 화면이 나온다.&lt;/p&gt;

    &lt;p&gt;인덱스 패턴을 정의할 때 해당 패턴에 일치하는 인덱스가 Elasticsearch 내에 존재해야 한다.&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 &lt;strong&gt;인덱스 이름을 diagnosis&lt;/strong&gt;라고 정의하였고, 진단 스크립트가 실행되면서 diagnosis 인덱스에 정형화된 컬럼 필드 내용들이 Elasticsearch로 전송되어 스크립트로 생성된 diagnosis라는 인덱스에 대한 인덱스 패턴을 생성할 수 있게 된다.&lt;/p&gt;

    &lt;p&gt;인덱스 패턴 이름을 적는 란에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diagnosis*&lt;/code&gt; 이라고 입력하여 인덱스 패턴을 생성해준다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인덱스 패턴을 생성하고 나면 해당 인덱스 패턴에 대한 로그를 확인할 수 있게 되고, 로그는 &lt;strong&gt;Kibana &amp;gt; Discover 탭&lt;/strong&gt;에서 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;해당 탭에 들어가면 아래의 [그림 10]처럼 전송된 진단 로그를 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_10.png&quot; alt=&quot;kibana_discover_log&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] Kibana Discover 로그 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;스크립트에서 전송되는 로그에 대한 컬럼은 &lt;strong&gt;{“timestamp”, “ip_addr”, “hostname”, “os_version”, “vul_item”, “result_code”, “messages”}&lt;/strong&gt;의 형태로 되어 있다.&lt;/p&gt;

    &lt;p&gt;취약점 진단 스크립트를 실행을 통해 생성된 로그를 Discover 탭에서 가시화되어 확인할 수 있고, 왼쪽에 필드 내용을 검색해서 데이터를 필터링해서 확인할 수도 있다.&lt;/p&gt;

    &lt;p&gt;예를 들어, 취약점으로 나온 로그만 확인하고 싶다면 Add filter를 눌러 result_code: Weak를 입력하면 result_code 값이 Weak라고 되어있는 로그들을 쉽게 필터링하여 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로, Kibana에서 로그를 한눈에 확인할 수 있도록 다양한 모형을 통해 로그를 확인해본다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 11]는 로그를 Visualization하여 확인한 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/diagnosis_11.png&quot; alt=&quot;kibana_visualize_custom&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] Kibana Visualize 탭 커스터마이징&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Kibana &amp;gt; Visualize 탭&lt;/strong&gt;에서 로그를 Visualization 할 수 있다.&lt;/p&gt;

    &lt;p&gt;로그들에 대한 Visualization할 수 있는 모형들이 다양하게 존재하는데, [그림 11]에서 보여지는 모형은 Pie를 사용했으며, 로그 필드는 hostname, result_code, vul_item을 순서로 &lt;strong&gt;드래그 앤 드랍&lt;/strong&gt;하여 커스터마이징 한 것이다.&lt;/p&gt;

    &lt;p&gt;Pie 뿐만 아니라 Bar, Line, Area, Data table, Metric, Donut, Treemap 등 다양한 모형을 통해 로그를 Visualization 하여 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-결론---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;3. 결론&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;KISA의 &lt;strong&gt;기술적 취약점 분석 평가 상세 가이드&lt;/strong&gt; 문서를 참고하여 CentOS 환경에서 Bash 스크립트를 기반으로 취약점 진단을 자동으로 진행한 후에 로그를 Elasticsearch에 저장하였고, Kibana를 통해 가시화된 데이터를 확인하고 테스트를 진행한 방식에 대해 기술했다.&lt;/p&gt;

&lt;p&gt;취약점 진단 자동화 스크립트를 실행하여 진단 로그를 생성하고, Elasticsearch에 저장한 후에 Kibana에서 각 노드 별로 진단 결과를 한 눈에 확인하는 [그림 1]의 일련의 과정들이 정상적으로 동작되는 것을 확인했다.&lt;/p&gt;

&lt;p&gt;다만 개발 기간이 짧아 KISA의 문서에 기술된 진단 항목을 모두 개발하지 못하고 일부만 구현한 부분이 아쉽고 나머지 진단 항목에 대해서는 추가 개발이 필요하다.&lt;/p&gt;

&lt;p&gt;그리고 진단 결과 취약하다고 나온 결과에 대해서는 자동으로 조치할 수 있는 스크립트를 개발하는 것도 향후 과제로 남기며 본 포스트를 마친다.&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/08/30/linux_vulnerability_diagnosis_project.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/08/30/linux_vulnerability_diagnosis_project.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>linux</category>
        
        <category>bulnerability</category>
        
        <category>diagnosis</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] GCP를 활용한 웹사이트 구축과 모너터링 및 부하 테스트</title>
        <description>&lt;p&gt;구현 과정 및 설정까지 작성하여 포스팅이 다소 길지만, 프로젝트성으로 진행되어 포스팅을 따로 나누지 않았음&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 프로젝트 개요&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.1. 프로젝트 목적&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. 프로젝트 아키텍처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 프로젝트 구현&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_1&quot;&gt;   2.1. Cloud SQL 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_2&quot;&gt;   2.2. VM 인스턴스 생성 및 워드프레스 구축&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_3&quot;&gt;   2.3. VM 인스턴스와 Cloud SQL 연동&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_4&quot;&gt;   2.4. 관리형 로드 밸런싱 구성&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_5&quot;&gt;   2.5. Bucket 생성 및 백업 설정&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2_6&quot;&gt;   2.6. Stack Driver를 활용한 모니터링 및 로깅 시스템 구축&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 프로젝트 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_1&quot;&gt;   3.1. Cloud SQL 로깅 테스트&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3_2&quot;&gt;   3.2. 오토 스케일링 및 부하 테스트&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-프로젝트-개요---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. 프로젝트 개요&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 목적&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트는 GCP의 전반적인 환경을 이해하고 흔하게 사용할 수 있는 기능들을 사용하여 GCP 환경에서 워드프레스(Wordpress)를 구축한다.&lt;/p&gt;

    &lt;p&gt;구축된 워드프레스 서버를 Google Cloud Console을 사용해 서비스와 상호작용하는 방법 등 GCP의 기본적인 기능들을 사용해보는 것을 목표로 진행된 프로젝트이다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;프로젝트 진행 당시에 notion을 통해 정리했었던 프로젝트 진행 순서는 다음 [그림 1]과 같다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_1.png&quot; alt=&quot;What_we_did&quot; width=&quot;560&quot; height=&quot;310&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 1] 프로젝트 진행 순서&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝트 아키텍처&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹서비스는 CentOS 인스턴스를 생성하여 워드프레스를 구축하였고, 구축한 웹서비스에 GCP의 기능을 최대한 활용하는 형태로 프로젝트를 진행했다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 2]는 본 프로젝트의 구조를 쉽게 나타낼 수 있도록 아키텍처를 그린 것이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_2.png&quot; alt=&quot;project_architecture&quot; width=&quot;850&quot; height=&quot;470&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 2] 프로젝트 아키텍처&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위와 같이 Compute Engine을 통한 인스턴스 생성, 로드 밸런싱, Cloud SQL 및 Bucket 연동, Stack Driver를 통한 로깅과 모니터링하는 부분까지 진행했다.&lt;/p&gt;

    &lt;p&gt;Cloud DNS를 이용하여 도메인을 설정해보고 싶었지만, 도메인을 구입하고 등록하는 과정이 필요하여 생략했다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-프로젝트-구현---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;2. 프로젝트 구현&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cloud SQL 구성&lt;/strong&gt;   &lt;a name=&quot;list2_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;GCP 콘솔 페이지에 접속하면 상단 바에 제품 및 리소스를 검색할 수 있는 텍스트 박스가 있다.&lt;/p&gt;

    &lt;p&gt;해당 검색창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cloud SQL Admin API&lt;/code&gt;를 입력하여 다음 [그림 3]에 보이는 &lt;strong&gt;사용&lt;/strong&gt; 버튼을 눌러 &lt;strong&gt;Cloud SQL를 활성화&lt;/strong&gt; 시켜준다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_3.png&quot; alt=&quot;enable_cloudsql&quot; width=&quot;320&quot; height=&quot;132&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 3] Cloud SQL Admin API 활성화&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Cloud SQL Admin API를 활성화 했다면 GCP 콘솔 페이지의 왼쪽 상단에 있는 탐색 메뉴에서 &lt;strong&gt;[SQL] 탭&lt;/strong&gt;을 눌러 다음 [그림 4]와 같이 &lt;strong&gt;Cloud SQL 인스턴스를 생성&lt;/strong&gt;했다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_4.png&quot; alt=&quot;create_cloudsql_instance&quot; width=&quot;450&quot; height=&quot;552&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 4] Cloud SQL 인스턴스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 MySQL 5.7을 선택하여 데이터베이스를 생성하였고, 리전은 성능 향상을 위해 비교적 가까운 &lt;strong&gt;서울 리전&lt;/strong&gt;을 선택했다.&lt;/p&gt;

    &lt;p&gt;다음으로 GCP 콘솔 기능인 Cloud Shell 화면에서 웹서버에서 사용할 데이터베이스의 설정을 진행한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  crisis51526@cloudshell:~ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cccr-gcp-project&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gcloud sql connect mysql-wordpress &lt;span class=&quot;nt&quot;&gt;--user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root &lt;span class=&quot;nt&quot;&gt;--quiet&lt;/span&gt;
  Allowlisting your IP &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;incoming connection &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;5 minutes...done.
  Connecting to database with SQL user &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root].Enter password: Input Your Password

  Your MySQL connection &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;is 187
  Server version: 5.7.25-google-log &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Google&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2000, 2020, Oracle and/or its affiliates. All rights reserved.

  Oracle is a registered trademark of Oracle Corporation and/or its
  affiliates. Other names may be trademarks of their respective
  owners.

  Type &lt;span class=&quot;s1&quot;&gt;&apos;help;&apos;&lt;/span&gt; or &lt;span class=&quot;s1&quot;&gt;&apos;\\h&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;help. Type &lt;span class=&quot;s1&quot;&gt;&apos;\\c&apos;&lt;/span&gt; to clear the current input statement.

  mysql&amp;gt; GRANT ALL PRIVILEGES ON &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; TO &lt;span class=&quot;s1&quot;&gt;&apos;root&apos;&lt;/span&gt;@&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt; IDENTIFIED BY &lt;span class=&quot;s1&quot;&gt;&apos;Input Your Password&apos;&lt;/span&gt; WITH GRANT OPTION&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  Query OK, 0 rows affected, 1 warning &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.05 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  mysql&amp;gt; CREATE DATABASE wordpress CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  Query OK, 1 row affected &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.05 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  mysql&amp;gt; GRANT ALL ON wordpress.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; TO &lt;span class=&quot;s1&quot;&gt;&apos;wordpressuser&apos;&lt;/span&gt;@&lt;span class=&quot;s1&quot;&gt;&apos;%&apos;&lt;/span&gt; IDENTIFIED BY &lt;span class=&quot;s1&quot;&gt;&apos;Input Your Password&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  Query OK, 0 rows affected, 1 warning &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.06 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  mysql&amp;gt; FLUSH PRIVILEGES&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  Query OK, 0 rows affected &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.06 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VM 인스턴스 생성 및 워드프레스 구축&lt;/strong&gt;   &lt;a name=&quot;list2_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹서버에 연동할 Cloud SQL의 구성이 모두 끝난 후에 워드프레스를 설치할 VM 인스턴스를 생성한다.&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[Compute Engine] - [VM 인스턴스]&lt;/strong&gt; 탭을 눌러 &lt;strong&gt;만들기&lt;/strong&gt; 버튼을 클릭하여 다음 [그림 5]와 같이 인스턴스를 생성한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_5.png&quot; alt=&quot;create_instance&quot; width=&quot;450&quot; height=&quot;1040&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 5] VM 인스턴스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;먼저, 인스턴스를 생성할 때 앞서 생성한 Cloud SQL 인스턴스와 같은 리전(서울 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asia-northeast3-a&lt;/code&gt;)을 선택하도록 한다.&lt;/p&gt;

    &lt;p&gt;flavor는 실제 서비스를 운영할 목적이 아니기에 VM 사양이 낮은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n1-standard-1&lt;/code&gt;을 선택했고,&lt;/p&gt;

    &lt;p&gt;OS는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CentOS 7&lt;/code&gt;, 웹서버의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP 트래픽을 허용&lt;/code&gt;해주도록 체크했다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;생성한 인스턴스에 워드프레스를 설치하기 위해 터미널에 입력한 명령어는 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;crisis51526@instance-wordpress ~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;su -

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;https://rpms.remirepo.net/enterprise/remi-release-7.rpm 
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;epel-release yum-utils

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# setenforce 0

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum-config-manager &lt;span class=&quot;nt&quot;&gt;--disable&lt;/span&gt; remi-php54
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum-config-manager &lt;span class=&quot;nt&quot;&gt;--enable&lt;/span&gt; remi-php74
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;php php-fpm
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;php-cli php-redis php-brotli php-intl php-gd php-gmp php-imap php-bcmath &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      php-interbase php-json php-mbstring php-mysqlnd php-odbc php-opcache php-memcached php-tidy php-pdo php-pdo-dblib &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      php-pear php-pgsql php-process php-pecl-apcu php-pecl-geoip php-pecl-imagick php-pecl-hrtime php-pecl-json &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      php-pecl-memcache php-pecl-rar php-pecl-pq php-pecl-redis4 php-pecl-yaml php-pecl-zip
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;httpd
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl restart httpd
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;php-fpm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start php-fpm
    
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;redis memcached
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;redis &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;memcached 
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl start redis &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; systemctl start memcached
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim /etc/sysconfig/memcached
  &lt;span class=&quot;nv&quot;&gt;OPTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-l 127.0.0.1&quot;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl restart memcached
    
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# wget http://wordpress.org/latest.tar.gz
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-xvzf&lt;/span&gt; latest.tar.gz &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; /var/www/html
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-R&lt;/span&gt; apache: /var/www/html/wordpress
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim /etc/httpd/conf.d/wordpress.conf
  &amp;lt;VirtualHost &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;:80&amp;gt;
      DocumentRoot /var/www/html/wordpress
      ServerName lls.wordpress.com
      ServerAlias www.lls.wordpress.com
    
      &amp;lt;Directory /var/www/html/wordpress/&amp;gt;
          Options +FollowSymlinks
          AllowOverride All
      &amp;lt;/Directory&amp;gt;
    
      ErrorLog /var/log/httpd/tecminttest-error-log
      CustomLog /var/log/httpd/tecminttest-acces-log common
  &amp;lt;/VirtualHost&amp;gt;
    
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl restart httpd.service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/www/html/wordpress/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;wp-config-sample.php wp-config.php 
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# vim wp-config.php
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;DB_NAME&apos;&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;&apos;wordpress&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;DB_USER&apos;&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;&apos;wordpressuser&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;DB_PASSWORD&apos;&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;&apos;Input Your Password.&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;DB_HOST&apos;&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;&apos;localhost&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VM 인스턴스와 Cloud SQL 연동&lt;/strong&gt;   &lt;a name=&quot;list2_3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;워드프레스를 설치한 인스턴스에서 Cloud SQL Proxy를 통해 Cloud SQL에 연결하기 위해서는 권한이 필요하다.&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[IAM 및 관리자] - [IAM]&lt;/strong&gt; 탭을 눌러 다음 [그림 6]와 같이 새로운 구성원을 추가한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_6.png&quot; alt=&quot;iam_create&quot; width=&quot;800&quot; height=&quot;627&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 6] 서비스 계정 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;역할에서 &lt;strong&gt;Cloud SQL -&amp;gt; Cloud SQL 편집자&lt;/strong&gt;를 선택하고 서비스 키도 생성해준다.&lt;/p&gt;

    &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;service_account&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;project_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cccr-gcp-project&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;private_key_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;3ef41c7827f3524bc358d489313f6084c229cf2f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;private_key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-----BEGIN PRIVATE KEY-----&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCVnSNgrX4B+Vi1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nYoTpCMXSl/p/tSjfhGaIUprWzCSfl3mVVQJlnN9mDQ8GTvg4l5UpGxvuaftV3MDN&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;npwBkZ/tCKE7h/DTRx1cay28paXGV/vKZt8OwwWCCmm5Uk5ZvIvmel/oGho9TC886&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nJ1DvWSqjZL+aRwFxWJqGwpF4zxXOFjStcqhCdnT9UipCfOgqx2xBoN4N0mhkUEby&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nfqLqo7AqEYh/5/zXWR9PTm7bESbqtz2i+VUOGwDDt5U0PVatGpFahNL8qUj4lJlO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nOzltgNICedHdUMa9B+GuSi5NOKHkuR5lOJZGcqziZFQLw3UpUyGMPVdsupcn6ZQm&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nLwdl/lpfAgMBAAECgf8TSS5GSBb2Ki5FM23unDLj8rNXwwKBzY9qAzvydF5ENEJ3&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n/X1Rm+cwQH6vUX6tzNxtcBEpqn+7kblIyT5DsyOwY4HHn7svT4Lq8U5jCDScIUEk&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nj4uqPUMzkrSmMmAx81A6IV0Zej7/dYZA+NB2Cgh1B4erW3vUIJfKx0n5SLiG2CN9&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nSRC2L3YlwKPrmGiKXSvt6p2qezDjwycooph5s8EWjZ4Wyy5lP2bjaIGqs+QzIN3s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nYAMf3KTNF8EHNs4jJYmFiwIuz8q4zscnt3z7TF5vsgcBSgKqnE5rSa2UiyXx/8um&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nw7gU5taZh32o0Xk8AYTrVW7vYx9PkAz7g77yVFkCgYEAxQSTYZmkPxXKYs9aGeyi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nYCRnBNgNr1WjvQ5DQGBAUQS4OiZEb6JoWDqlOvcMqvF1Vu2CPv5MTgEWrs2+mAmj&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n8xWvySm97oJ2FfnYX2rl/SmGmxbWq2CKzsU56jJNDUGBiC4/3Ot8hsy/cnzEec54&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nhU1yW+mEwq0Ew50Ab5IldcsCgYEAwmeFo8XoI86Y8MakIoW6rL9zredwf+B9qYjI&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n7VHGcEnAcCfnRevLj7kK/QFswox/cfGmIbOxd1BPBH4D6nVKmRWqIzkpnCPkVRJ8&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n5BuImNhzfurPUgJWf0lNkrRaSwbsBYf12ZQ01J5t4Bg8ArQ5nNNT4ieC9dptpYTL&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n2hFSuz0CgYAMkzEw/pR8LlDfo6p1kyP+DPTCW2PsOAQecgWa20nfofR8Sar+kRgl&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n4YBgVhpp4sWBieFRUfve0rT27Uzn+V2Mi2rP5SkpSwxsdKj51iHd2cOsrHWBNMVH&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nU1FSAGnombDB12neGO220OS7UvlbaPFKWNoewbXmkxKFxcScWnCnpwKBgQCIiwub&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nhzLQi5hybSL1uHXwRZxrhgZHWxcID7IItgop7jNC01QmkUJt1St5nxmT3/jXwEHO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;npBa+1eJaJmR7thxKP6Q7jzfBmpgShKTB1vDvYgBlIWmykT/NsV/R7ekJj3gRPniY&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ndPdSa2CDKKJlx847b1cYnmXmZp/ixM4lgUtZhQKBgQC7GBZxRh4dx6JWqQ8J2Vaq&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n1sE83o0/K0i4i2MqEw70CG4nFs5831fnV6DSVWpyvxlN9M8Ce19ZcpVLP4UD0pE6&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ndTKGhvdIkQeat9yWBr4J/+d9jz3uleXGZCmVYrR/f2Ge8Vb/DWEUf2Ps9s0QZkoO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nN6xZ+UJBHIwBp+i3pLqXOw==&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n-----END PRIVATE KEY-----&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;n&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;client_email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;wpmanager@cccr-gcp-project.iam.gserviceaccount.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;client_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;116608554003641610764&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;auth_uri&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;https://accounts.google.com/o/oauth2/auth&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;token_uri&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;https://oauth2.googleapis.com/token&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;auth_provider_x509_cert_url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;https://www.googleapis.com/oauth2/v1/certs&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;client_x509_cert_url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;https://www.googleapis.com/robot/v1/metadata/x509/wpmanager%40cccr-gcp-project.iam.gserviceaccount.com&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;생성된 서비스 키의 샘플입니다. Cloud SQL Proxy를 통해 Cloud SQL에 접속할 때 필요하다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;그리고 다음 [그림 7]과 같이 Cloud SQL 인스턴스에서 접근을 허용할 네트워크를 추가해주어야 한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_7.png&quot; alt=&quot;cloudsql_configuration&quot; width=&quot;650&quot; height=&quot;442&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 7] Cloud SQL 인스턴스 설정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;연결 방식을 &lt;strong&gt;공개 IP&lt;/strong&gt;에 체크하여 프록시를 통해 Cloud SQL에 접근할 수 있도록 설정하고,&lt;/p&gt;

    &lt;p&gt;아래쪽의 네트워크 추가 버튼을 눌러 워드프레스 &lt;strong&gt;웹서버의 공개 IP 주소를 등록&lt;/strong&gt;한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 워드프레스 웹서버에서 Cloud SQL에 접속하는 과정을 정리한 명령어이다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mysql
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; 34.64.148.237
  Enter password: 
  Welcome to the MariaDB monitor.  Commands end with &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; or &lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;g.
  Your MySQL connection &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;is 343
  Server version: 5.7.25-google-log &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Google&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2000, 2018, Oracle, MariaDB Corporation Ab and others.

  Type &lt;span class=&quot;s1&quot;&gt;&apos;help;&apos;&lt;/span&gt; or &lt;span class=&quot;s1&quot;&gt;&apos;\\h&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;help. Type &lt;span class=&quot;s1&quot;&gt;&apos;\\c&apos;&lt;/span&gt; to clear the current input statement.

  MySQL &lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;none&lt;span class=&quot;o&quot;&gt;)]&amp;gt;&lt;/span&gt; show databases&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  +--------------------+
  | Database           |
  +--------------------+
  | information_schema |
  | mysql              |
  | performance_schema |
  | sys                |
  | wordpress          |
  +--------------------+
  5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.01 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  MySQL &lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;none&lt;span class=&quot;o&quot;&gt;)]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit
  &lt;/span&gt;Bye

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /cloudsql
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;777 /cloudsql
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; cloud_sql_proxy
  &lt;span class=&quot;nt&quot;&gt;--2020-08-02&lt;/span&gt; 10:39:20--  https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64
  Resolving dl.google.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dl.google.com&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;... 172.217.161.238, 2404:6800:400a:80c::200e
  Connecting to dl.google.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dl.google.com&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;|172.217.161.238|:443... connected.
  HTTP request sent, awaiting response... 200 OK
  Length: 14492253 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;14M&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;application/octet-stream]
  Saving to: ‘cloud_sql_proxy’

  100%[&lt;span class=&quot;o&quot;&gt;=========================================================================&amp;gt;]&lt;/span&gt; 14,492,253  22.0MB/s   &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.6s   

  2020-08-02 10:39:21 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;22.0 MB/s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; - ‘cloud_sql_proxy’ saved &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;14492253/14492253]

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x cloud_sql_proxy
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim wordpress-key.json
  &lt;span class=&quot;c&quot;&gt;# wpmanager 서비스 계정에서 키를 만들 때 생성된 json 내용 입력&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# ./cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;nt&quot;&gt;-credential_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/root/wordpress-key.json &amp;amp;
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 15932
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# 2020/08/02 15:23:07 Rlimits &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;file descriptors &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;to &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&amp;amp;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;8500 8500&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
  2020/08/02 15:23:07 using credential file &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;authentication&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wpmanager@cccr-gcp-project.iam.gserviceaccount.com
  2020/08/02 15:23:07 Listening on /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress
  2020/08/02 15:23:07 Ready &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;new connections&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress 
  Enter password: 
  2020/08/02 10:52:05 New connection &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;cccr-gcp-project:asia-northeast3:mysql-wordpress&quot;&lt;/span&gt;
  Welcome to the MariaDB monitor.  Commands end with &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; or &lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;g.
  Your MySQL connection &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;is 429
  Server version: 5.7.25-google-log &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Google&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2000, 2018, Oracle, MariaDB Corporation Ab and others.

  Type &lt;span class=&quot;s1&quot;&gt;&apos;help;&apos;&lt;/span&gt; or &lt;span class=&quot;s1&quot;&gt;&apos;\\h&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;help. Type &lt;span class=&quot;s1&quot;&gt;&apos;\\c&apos;&lt;/span&gt; to clear the current input statement.

  MySQL &lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;none&lt;span class=&quot;o&quot;&gt;)]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit
  &lt;/span&gt;Bye
  2020/08/02 10:52:24 Client closed &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;connection on /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# ps
  PID TTY          TIME CMD
  1467 pts/0    00:00:00 &lt;span class=&quot;nb&quot;&gt;sudo
  &lt;/span&gt;1469 pts/0    00:00:00 su
  1470 pts/0    00:00:00 bash
  16476 pts/0    00:00:00 cloud_sql_proxy
  16517 pts/0    00:00:00 ps
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-9&lt;/span&gt; 16476
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]+  Killed                  ./cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;nt&quot;&gt;-credential_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wordpress-key.json
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /opt/cloudsqlproxy/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;cloud_sql_proxy /opt/cloudsqlproxy/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim ~/cloudsqlproxy.service
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Unit]
  &lt;span class=&quot;nv&quot;&gt;Description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Google Cloud SQL Proxy
  &lt;span class=&quot;nv&quot;&gt;After&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;syslog.target network.target auditd.service

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Service]
  &lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/opt/cloudsqlproxy/cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3:mysql-wordpress &lt;span class=&quot;nt&quot;&gt;-credential_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/root/wordpress-key.json
  &lt;span class=&quot;nv&quot;&gt;ExecStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/bin/kill &lt;span class=&quot;nt&quot;&gt;-TERM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$MAINPID&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Install]
  &lt;span class=&quot;nv&quot;&gt;WantedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;multi-user.target

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# &lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; ~/cloudsqlproxy.service /etc/systemd/system/
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl daemon-reload
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl start cloudsqlproxy
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;cloudsqlproxy
  Created symlink from /etc/systemd/system/multi-user.target.wants/cloudsqlproxy.service to /etc/systemd/system/cloudsqlproxy.service.
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# systemctl status cloudsqlproxy
  ● cloudsqlproxy.service - Google Cloud SQL Proxy
      Loaded: loaded &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/etc/systemd/system/cloudsqlproxy.service&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; disabled&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; vendor preset: disabled&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      Active: active &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;running&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; since Sun 2020-08-02 10:55:53 UTC&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 13s ago
  Main PID: 16524 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cloud_sql_proxy&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      CGroup: /system.slice/cloudsqlproxy.service
              └─16524 /opt/cloudsqlproxy/cloud_sql_proxy &lt;span class=&quot;nt&quot;&gt;-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql &lt;span class=&quot;nt&quot;&gt;-instances&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cccr-gcp-project:asia-northeast3...

  Aug 02 10:55:53 instance-wordpress systemd[1]: Started Google Cloud SQL Proxy.
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 Rlimits &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;file descriptors s...0&lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 using credential file &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;auth...com
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 Listening on /cloudsql/cccr-gc...ess
  Aug 02 10:55:53 instance-wordpress cloud_sql_proxy[16524]: 2020/08/02 10:55:53 Ready &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;new connections
  Hint: Some lines were ellipsized, use &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; to show &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;full.

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress wordpress]# vim /var/www/html/wordpress/wp-config.php
  define&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;DB_HOST&apos;&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;&apos;localhost:/cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Cloud SQL Proxy가 정상적으로 동작하는지 테스트 한 후에 데몬을 생성하여 cloudsqlproxy 서비스가 실행되도록 했다.&lt;/p&gt;

    &lt;p&gt;wordpress-key.json 파일의 내용에는 위에서 wpmanager 서비스 계정의 키를 만들 때 생성된 json 내용을 입력하면 된다.&lt;/p&gt;

    &lt;p&gt;워드프레스의 설정파일에서 데이터베이스 설정 값에 cloudsqlproxy 서비스로 생겨난 소켓 파일의 경로를 적어주고 정상적으로 연결되는지 확인한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Cloud SQL에 정상적으로 연결되었다면 워드프레스를 설치하고 워드프레스 데이터베이스와 테이블이 정상적으로 생성되었는지 확인하도록 한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_8.png&quot; alt=&quot;wordpress_installation&quot; width=&quot;750&quot; height=&quot;554&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 8] 워드프레스 설치&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_9.png&quot; alt=&quot;wordpress_theme&quot; width=&quot;1000&quot; height=&quot;541&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 9] 워드프레스 테마 적용&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;워드프레스 설치 및 테마 적용이 정상적으로 이루어진 후에 Cloud SQL에서 워드프레스 데이터베이스의 테이블이 정상적으로 생성되었는지 확인한다.&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordpress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# mysql -u root -p -S /cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Enter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;Welcome&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MariaDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Commands&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; \\&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Your&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1478&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Copyright&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2018&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Oracle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MariaDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Corporation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ab&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;others&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;help;&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;h&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;c&apos;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordpress&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Reading&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;You&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startup&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changed&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MySQL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordpress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;+-----------------------+&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tables_in_wordpress&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;+-----------------------+&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_commentmeta&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_comments&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_links&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_options&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_postmeta&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_posts&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_term_relationships&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_term_taxonomy&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_termmeta&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_terms&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_usermeta&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_users&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;+-----------------------+&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.00&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;관리형 로드 밸런싱 구성&lt;/strong&gt;   &lt;a name=&quot;list2_4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;GCLB(Google Cloud Load Balancing)을 구성하기 위해서는 기본적으로 대상으로 할 인스턴스 그룹이 존재해야 한다. 인스턴스 그룹은 &lt;strong&gt;오토 스케일링(Auto-scaling)을 위한&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리형 인스턴스 그룹&lt;/code&gt;과 &lt;strong&gt;템플릿을 사용하지 않고 직접 VM 인스턴스를 추가할 수 있는&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비관리형 인스턴스 그룹&lt;/code&gt;으로 나뉜다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;본 프로젝트에서는 관리형 인스턴스 그룹을 구성하고 부하 분산기를 생성하여 로스 밸런싱 환경을 구축한다.&lt;/p&gt;

    &lt;p&gt;먼저 VM 인스턴스에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스냅샷을 생성&lt;/code&gt;하고, 생성한 스냅샷으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이미지를 생성&lt;/code&gt;한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_10.png&quot; alt=&quot;create_snapshot&quot; width=&quot;400&quot; height=&quot;566&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 10] 스냅샷 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_11.png&quot; alt=&quot;create_image&quot; width=&quot;400&quot; height=&quot;689&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 11] 이미지 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이미지까지 정상적으로 생성되었다면 다음으로 관리형 인스턴스 그룹을 만들기 전에 다음 [그림 12]과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인스턴스 템플릿을 생성&lt;/code&gt;한다.&lt;/p&gt;

    &lt;p&gt;그룹에 속한 VM의 종류가 여러 개라면 모든 VM의 운영체제의 이미지를 지정해야 한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_12.png&quot; alt=&quot;create_instance_template&quot; width=&quot;400&quot; height=&quot;881&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 12] 인스턴스 템플릿 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인스턴스 템플릿을 정상적으로 생성한 후에 다음 [그림 13]과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리형 인스턴스 그룹을 생성&lt;/code&gt;한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_13.png&quot; alt=&quot;create_instance_group&quot; width=&quot;700&quot; height=&quot;1114&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 13] 인스턴스 그룹 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;인스턴스 그룹까지 정상적으로 생성되었다면 부하 분산기를 생성할 준비가 끝났다.&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[네트워크 서비스] - [부하 분산]&lt;/strong&gt; 탭에 들어와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부하 분산기 만들기&lt;/code&gt;를 눌러준다.&lt;/p&gt;

    &lt;p&gt;HTTP(S), TCP, UDP에 대한 부하 분산기를 만들 수 있으며 본 프로젝트에서는 워드프레스를 통한 웹서버 인스턴스를 부하 분산 시켜주기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP(S) 부하 분산기&lt;/code&gt;를 선택하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터넷 트래픽을 VM으로 분산&lt;/code&gt;을 눌러준다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음 단계로 넘어오면 백엔드 서비스와 프런트엔드 서비스를 생성하는 화면으로 넘어오게 된다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_14.png&quot; alt=&quot;create_lb_backend&quot; width=&quot;400&quot; height=&quot;589&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 14] 백엔드 서비스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;기존에 만들어둔 백엔드 서비스가 없기 때문에 새로운 서비스 생성을 선택하고 백앤드 서비스의 이름과 앞에서 생성한 인스턴스 그룹을 선택하면 된다. 다음으로는 로드밸런서에서 들어온 트래픽을 인스턴스 그룹의 인스턴스들의 어느 포트로 전달할 것인지를 포트 번호에 정의하는데, 여기서는 HTTP 트래픽을 전달하는 것이기 때문에 80을 선택한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;백엔드 서비스를 생성할 때 상태 확인(Health check)을 선택하는 항목이 있는데 마찬가지로 기존에 만들어둔 상태 확인이 없기 때문에 새로 생성한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_15.png&quot; alt=&quot;create_lb_check&quot; width=&quot;400&quot; height=&quot;465&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 15] 상태 확인 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;상태 확인은 인스턴스 그룹 내의 인스턴스가 양호한지를 체크하고 만약에 정상적이지 않으면 비정상 노드는 부하 분산에서 빼버리는 기능을 수행한다. 프로토콜은 HTTP를 입력하고, 포트에는 HTTP 포트인 80포트, 그리고 서비스가 정상인지를 확인하는 확인 간격은 체크 주기이고, 제한 시간은 이 시간(초)내에 응답이 없으면 장애라고 판단을 한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_16.png&quot; alt=&quot;create_lb_frontend&quot; width=&quot;400&quot; height=&quot;493&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 16] 프런트엔드 서비스 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;마지막으로 프런트엔드 서비스를 설정하는데, 여기서는 어떤 프로토콜을 어떤 IP와 포트로 받을 것인지, HTTPS의 경우에는 SSL 인증서를 설정하는 작업을 한다. 본 프로젝트에서는 HTTP 프로토콜을 80 포트로 설정하기 때문에 [그림 16]과 같이 설정하고, 부하 분산 이름을 입력하여 생성을 완료한다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;정상적으로 부하 분산기가 생성이 되면 다음 [그림 17]과 같이 백엔드 서비스에 지정된 인스턴스 그룹에 해당하는 인스턴스가 모두 정상 동작하는 화면을 볼 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_17.png&quot; alt=&quot;lb_detail&quot; width=&quot;800&quot; height=&quot;404&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 17] 부하 분산기 세부 정보&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bucket 생성 및 백업 설정&lt;/strong&gt;   &lt;a name=&quot;list2_5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;탐색 메뉴에서 &lt;strong&gt;[Storage] - [브라우저]&lt;/strong&gt; 탭을 눌러 &lt;strong&gt;버킷 생성&lt;/strong&gt; 버튼을 클릭하여 버킷을 생성한다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_18.png&quot; alt=&quot;create_bucket&quot; width=&quot;900&quot; height=&quot;145&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 18] 버킷 생성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;버킷 이름을 입력하고 리전을 아시아로 설정한 후에 나머지는 기본 값으로 생성하게 되면 위의 [그림 18]과 같이 버킷이 생성된 모습을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;생성한 버킷의 권한 탭에 들어오면 버킷에 접근 가능한 구성원들과 역할을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 19]에서 보이는 &lt;strong&gt;추가&lt;/strong&gt; 버튼을 클릭하여 새로운 구성원을 추가해준다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_19.png&quot; alt=&quot;bucket_allUsers&quot; width=&quot;500&quot; height=&quot;223&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 19] 버킷 allUsers 구성원 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allUsers&lt;/code&gt; 구성원에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;저장소 개체 관리자&lt;/code&gt; 역할을 주어 모든 사용자들이 저장소에 접근할 수 있도록 설정했다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음은 Cloud SQL에 저장된 wordpress 데이터베이스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysqldump&lt;/code&gt;하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crontab&lt;/code&gt;을 통해 주기적으로 백업하기 위한 명령어이다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim /etc/my.cnf
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;mysqldump]
  &lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root
  &lt;span class=&quot;nv&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Input Your Password

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim cloudsql_backup.sh
  &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;db_instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql-wordpress
  &lt;span class=&quot;nv&quot;&gt;db_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wordpress
  &lt;span class=&quot;nv&quot;&gt;db_user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;root
  &lt;span class=&quot;nv&quot;&gt;bucket_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gs://bucket-mysql-wordpress
  &lt;span class=&quot;nv&quot;&gt;socket_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/cloudsql/cccr-gcp-project:asia-northeast3:mysql-wordpress
  &lt;span class=&quot;nv&quot;&gt;date_YYYYMMDDHHMMSS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;+%Y%m%d%H%M%S&apos;&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;backupfile_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wordpress_&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;date_YYYYMMDDHHMMSS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;.sql

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Cloud SQLl daily backup start..&quot;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;#gcloud sql export csv $db_instance $bucket_name/test.csv --database=$db_name --query=$sql_query&lt;/span&gt;
  mysqldump &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$db_user&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$socket_path&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--databases&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$db_name&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--hex-blob&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--single-transaction&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--default-character-set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;utf8mb4 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backupfile_name&lt;/span&gt;

  gsutil &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$backupfile_name&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$bucket_name&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Cloud SQL daily backup stop..&quot;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# crontab &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt;
  0 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/3 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; /root/cloudsql_backup.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;Cloud SQL을 백업하는 쉘 스크립트를 작성하여 crontab에 등록하여 3시간 주기로 mysqldump가 실행되도록 설정해두고 일정 시간이 지난 후에 버킷에 정상적으로 백업되어 저장됐는지 확인했다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_20.png&quot; alt=&quot;cloudsql_bucket_backup1&quot; width=&quot;800&quot; height=&quot;323&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 20] crontab을 사용한 Cloud SQL의 주기적인 백업&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 20]에서 최종 수정 날짜를 확인해보면 3시간 주기로 저장되어 있는 것을 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;같은 형태로 이번에는 syslog를 백업하는 쉘 스크립트를 작성하여 crontab에 등록한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# vim apache_log_backup.sh
  &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;syslog daily backup start..&quot;&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /var/log/messages | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-iE&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;apache|wordpress&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /root/apache_log_backup_&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;+%y-%m-%d&apos;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;.log
  gsutil &lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /root/apache_log_backup_&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.log gs://bucket-mysql-wordpress/apache_log_backup/
  &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt; /root/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.log

  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;syslog daily backup stop..&quot;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@instance-wordpress ~]# crontab &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; /root/apache_log_backup.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이번에는 매 분마다 쉘 스크립트를 실행하도록 crontab에 등록하고 버킷을 확인해봤다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_21.png&quot; alt=&quot;syslog_bucket_backup&quot; width=&quot;800&quot; height=&quot;383&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 21] crontab을 사용한 syslog의 주기적인 백업&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Stack Driver를 활용한 모니터링 및 로깅 시스템 구축&lt;/strong&gt;   &lt;a name=&quot;list2_6&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;VM 인스턴스에 monitoring-agent 설치&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sSO&lt;/span&gt; https://dl.google.com/cloudagents/add-monitoring-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;bash add-monitoring-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;stackdriver-agent

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start stackdriver-agent
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;stackdriver-agent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;VM 인스턴스에 logging-agent 설치&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sSO&lt;/span&gt; https://dl.google.com/cloudagents/add-logging-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;bash add-logging-agent-repo.sh
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; update
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;google-fluentd
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;google-fluentd-catch-all-config-structured

  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start google-fluentd
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;google-fluentd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;모니터링과 로깅을 할 VM 인스턴스에 에이전트를 설치하고 &lt;strong&gt;[모니터링] - [대시보드]&lt;/strong&gt; 탭을 눌러 들어간다.&lt;/p&gt;

    &lt;p&gt;대시보드 페이지에 들어오면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create Dashboard&lt;/code&gt; 버튼을 통해 새로운 대시보드를 생성할 수 있다.&lt;/p&gt;

    &lt;p&gt;원하는 대시보드의 이름을 입력하고 대시보드를 생성하면 우측 상단에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add Chart&lt;/code&gt; 버튼을 눌러 원하는 차트들을 추가하여 대시보드를 커스터마이징할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_22.png&quot; alt=&quot;add_chart&quot; width=&quot;800&quot; height=&quot;402&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 22] 대시보드 차트 추가&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 22]와 같이 차트에 나타낼 CPU, Memory, I/O 등 모니터링할 항목들의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Metric&lt;/code&gt;과 Instance, Group 등 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resource 타입&lt;/code&gt;을 지정하고 차트를 생성할 수 있다. 원하는 차트를 추가하고 대시보드를 확인하면 다음 [그림 23]과 같이 monitoring-agent을 통해 VM 인스턴스의 Metric들을 모니터링할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_23.png&quot; alt=&quot;monitoring_dashboard&quot; width=&quot;1000&quot; height=&quot;744&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 23] 모니터링 대시보드 완성&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 로깅 시스템은 &lt;strong&gt;[로그 기록] - [로그 뷰어]&lt;/strong&gt; 탭에 들어오면 다음 [그림 24]와 같이 logging-agent를 통해 수집된 로그들을 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_24.png&quot; alt=&quot;log_viewer&quot; width=&quot;900&quot; height=&quot;294&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 24] 로그 뷰어 확인&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_25.png&quot; alt=&quot;log_query&quot; width=&quot;900&quot; height=&quot;316&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 25] 로그 뷰어 쿼리 빌더&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-프로젝트-테스트---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;3. 프로젝트 테스트&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cloud SQL 로깅 테스트&lt;/strong&gt;   &lt;a name=&quot;list3_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;서비스 중인 워드프레스 서버에서 Cloud SQL에 대한 접속을 시도하는데 다음 [그림 26]과 같이 패스워드를 잘못 입력한 상황이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_26.png&quot; alt=&quot;cloudsql_connection_failure&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 26] Cloud SQL 접속 실패&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;패스워드를 잘못 입력하여 접속을 실패하여 쉘에 나타나는 로그를 다음 [그림 27]처럼 GCP의 로그 뷰어에서도 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_27.png&quot; alt=&quot;cloudsql_log_viewer&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 27] Cloud SQL 접속 실패 로그 뷰어&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;오토 스케일링 및 부하 테스트&lt;/strong&gt;   &lt;a name=&quot;list3_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다음으로 아파치(Apache)의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JMeter&lt;/code&gt;라는 툴을 사용하여 부하 테스트를 진행한다.&lt;/p&gt;

    &lt;p&gt;JMeter에서 핵심 기능은 웹 HTTP/HTTPS 프로토콜을 통해 클라이언트의 요청을 수행하여 부하를 발생시키는 것이다.&lt;/p&gt;

    &lt;p&gt;요청에 대한 성공/실패, 소요 시간 등의 정보를 기록하여 제공해준다.&lt;/p&gt;

    &lt;p&gt;다음 [그림 28]은 테스트할 사용자 수 및 반복 횟수 등을 설정해 웹 사이트 서버의 성능을 테스트한 내용이다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_28.png&quot; alt=&quot;jmeter&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 28] JMeter로 부하 테스트&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;여기서 &lt;strong&gt;스레드를 300개와 1000개 두 번의 부하 테스트를 진행&lt;/strong&gt;하였고, 300개의 스레드로 요청을 보냈을 때 오토 스케일링 기능으로 인해 인스턴스의 갯수가 2개에서 3개로 늘어났고, 1000개의 스레드로 부하를 주었을 때 3개에서 4개로 인스턴스가 자동 확장되는 것을 확인할 수 있었다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_29.png&quot; alt=&quot;instance_upscale&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 29] 인스턴스 자동 확장&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 29]는 인스턴스가 3개에서 4개로 확장되는 장면을 캡처한 것이다.&lt;/p&gt;

    &lt;p&gt;다음으로 부하 테스트를 진행하면서 인스턴스가 자동 생성되는 부분을 모니터링을 통해 확인했다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_30.png&quot; alt=&quot;instance_upscale_monitoring&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 30] 인스턴스 확장 모니터링&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;위의 [그림 30]에서 볼 수 있듯이 부하 테스트를 수행한 시점에 &lt;strong&gt;CPU, Memory, Network traffic이 확 늘어난 것을 확인&lt;/strong&gt;할 수 있고, 그와 동시에 인스턴스가 각각 하나씩 생겨난 것을 확인할 수 있다. 메모리 사용량을 확인하는 부분에서 측정 항목(인스턴스)가 새로 생겨난 것을 쉽게 확인할 수 있다.&lt;/p&gt;

    &lt;p&gt;그 후 &lt;strong&gt;마지막 10분&lt;/strong&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정화 기간&lt;/code&gt;이라고 하는데, 안정화 기간동안 관찰된 최대 부하를 기준으로 관리형 인스턴스 그룹이 유지되면 자동으로 인스턴스가 축소 되는 것을 확인할 수 있다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/static/assets/img/landing/project/gcp_toyproject_31.png&quot; alt=&quot;instance_downscale&quot; /&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;[그림 31] 인스턴스 자동 축소&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;물론 안정화 기간에 대한 설정은 로드밸런싱을 구성할 때 따로 설정이 가능하고, 인스턴스는 생성된지 가장 오래된 인스턴스를 우선으로 삭제되는 것 같았다.&lt;/p&gt;

    &lt;p&gt;이로써 GCP의 기능을 활용한 서버 구성과 로깅 및 테스트까지 정상적으로 끝났다!&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 16 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/08/16/gcp_project.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/08/16/gcp_project.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>gcp</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] ssustack_installer</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 프로젝트는 2017년 숭실대학교에서 김명호 교수님의 지도하에 진행되었습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ssustack_installer&quot;&gt;ssustack_installer&lt;/h2&gt;

&lt;p&gt;ssustack_installer 프로젝트는 ssustack 설치를 웹 브라우저에서 더욱 쉽게 설치할 수 있도록 도와준다.&lt;/p&gt;

&lt;p&gt;ssustack_installer를 실행하면 웹 브라우저가 뜨게되고, 필요한 설정을 입력 및 선택하면 ssustack 스크립트를 기반으로 설치가 시작된다.&lt;/p&gt;

&lt;p&gt;사용자의 선택에 따라 싱글노드 혹은 멀티호스트로 자유롭게 설치가 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;environment&quot;&gt;Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OpenStack : Rokcy Release&lt;/li&gt;
  &lt;li&gt;OS : Ubuntu 18.04 LTS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;다음의 설치 방법은 모든 노드가 Ubuntu 18.04 운영체제로 설치된 환경에서 진행되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-ssustack--ssustack_installer-클론&quot;&gt;1. ssustack &amp;amp; ssustack_installer 클론&lt;/h4&gt;

&lt;p&gt;OpenStack 환경을 구성하는 모든 노드에서 진행한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone http://git.dotstack.io/crisis513/ssustack.git
$ git clone http://git.dotstack.io/dotstack/ssustack_installer.git
$ cd ssustack/bin
$ ./ssustack_user_creation.sh
$ cp -r &amp;lt;your_controller_path&amp;gt;/ssustack/ .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성할 유저의 패스워드를 설정하여 ssustack 유저가 생성되면 ssustack 폴더를 ssustack 유저의 홈 디렉토리로 복사한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-network-설정&quot;&gt;2. network 설정&lt;/h4&gt;

&lt;p&gt;모든 노드의 네트워크 인터페이스를 수정 후 재부팅해주어야 한다. 먼저 Controller node의 경우, 외부와의 통신을 위한 네트워크와 오픈스택 컴포넌트들이 서로 API를 호출할 때 사용하는 내부 네트워크, VM 인스턴스들이 외부와 통신하기 위한 메뉴얼 네트워크를 설정해주어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/network/interfaces
auto &amp;lt;INTERFACE_NAME_1&amp;gt;
iface &amp;lt;INTERFACE_NAME_1&amp;gt; inet static
    address &amp;lt;PUBLIC_IP&amp;gt;
    netmask &amp;lt;PUBLIC_IP_NETMASK&amp;gt;
    gateway &amp;lt;PUBLIC_IP_GATEWAY&amp;gt;
    dns-servernames &amp;lt;DNS_NAMESERVERS&amp;gt;
auto &amp;lt;INTERFACE_NAME_2&amp;gt;
iface &amp;lt;INTERFACE_NAME_2&amp;gt; inet static
    address 10.10.10.11
    netmask 255.255.255.0
auto &amp;lt;INTERFACE_NAME_3&amp;gt;
iface &amp;lt;INTERFACE_NAME_3&amp;gt; inet manual
up ip link set dev $IFACE up
down ip link set dev $IFACE down
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compute node의 경우, 메뉴얼 네트워크가 필요없다. 오픈스택 설치가 정상적으로 설치되고나면 외부와의 통신은 필요없어 외부 네트워크를 OSD들 간의 통신을 위한 스토리지 네트워크로 설정하여 사용해도 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/network/interfaces
auto &amp;lt;INTERFACE_NAME_1&amp;gt;
iface &amp;lt;INTERFACE_NAME_1&amp;gt; inet static
    address &amp;lt;PUBLIC_IP&amp;gt;
    netmask &amp;lt;PUBLIC_IP_NETMASK&amp;gt;
    gateway &amp;lt;PUBLIC_IP_GATEWAY&amp;gt;
    dns-servernames &amp;lt;DNS_NAMESERVERS&amp;gt;
auto &amp;lt;INTERFACE_NAME_2&amp;gt;
iface &amp;lt;INTERFACE_NAME_2&amp;gt; inet static
    address 10.10.10.21
    netmask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-hosts-및-ssh-설정&quot;&gt;3. hosts 및 SSH 설정&lt;/h4&gt;

&lt;p&gt;위의 작업이 끝나면 Controller node에서 hosts 및 SSH 설정한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/hosts
10.10.10.11 controller-node
10.10.10.21 compute-node1 
10.10.10.22 compute-node2
10.10.10.23 compute-node3
    
$ cd ssustack/bin/
$ ./creating_ssh_keys.sh [&amp;lt;host_name&amp;gt; ... ]
ex) ./creating_ssh_keys.sh compute-node1 compute-node2 compute-node3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-ssustack_installer-실행&quot;&gt;4. ssustack_installer 실행&lt;/h4&gt;

&lt;p&gt;ssustack_installer는 Controller node에서 실행시킨다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ssustack_installer/
$ ./app.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;app.sh를 실행시키고나면 우분투 기본 브라우저로 사용되는 파이어폭스가 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-welcome-페이지&quot;&gt;5. Welcome 페이지&lt;/h4&gt;

&lt;p&gt;권장 사양과 현재 PC의 사양을 확인해보고 설치 전 작업이 재대로 되었는지 확인하고 다음으로 넘어간다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-enable-services-페이지&quot;&gt;6. Enable Services 페이지&lt;/h4&gt;

&lt;p&gt;Controller node 및 Compute node에서 설치할 서비스를 선택하고 넘어간다. 필수로 설치되어야하는 패키지의 경우 이미 체크되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-environment-settings-페이지&quot;&gt;7. Environment Settings 페이지&lt;/h4&gt;

&lt;p&gt;각각의 Controller node 및 Compute node에서 설정되어야 할 ip, subnet, hostname, password 등을 설정하고 다음으로 넘어간다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-installing-페이지&quot;&gt;8. Installing 페이지&lt;/h4&gt;

&lt;p&gt;앞의 설정이 재대로 되어있는지 확인해보고 Start 버튼을 눌러주고 설치 로그를 확인해준다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 번만 누르고 브라우저를 종료하면 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-finished-페이지&quot;&gt;9. Finished 페이지&lt;/h4&gt;

&lt;p&gt;정상적으로 설치되었는지 확인하고 종료한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;10-추가-설정&quot;&gt;10. 추가 설정&lt;/h4&gt;

&lt;p&gt;아래 비디오에서 Ceph OSD를 추가하고, Horizon에서 네트워크를 생성하고, 우분투 이미지를 업로드하여 인스턴스 생성 및 테스트하는 부분까지 보여준다. (10:30)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;testing-video&quot;&gt;Testing video&lt;/h3&gt;

&lt;video width=&quot;840&quot; height=&quot;480&quot; src=&quot;/static/assets/video/blog/ssustack_working.mp4&quot; controls=&quot;&quot;&gt;&lt;/video&gt;

&lt;blockquote&gt;
  &lt;p&gt;영상이 재생되지 않는다면 IE 환경에서 다시 재생&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 30 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/04/30/ssustack_installer.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/04/30/ssustack_installer.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>ssustack</category>
        
        <category>installer</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] ssustack</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 프로젝트는 2017년 숭실대학교에서 김명호 교수님의 지도하에 진행됨&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ssustack&quot;&gt;ssustack&lt;/h2&gt;

&lt;p&gt;ssustack 프로젝트는 Ubuntu 환경에서 OpenStack을 자동으로 설치하여 클라우드 컴퓨팅을 손쉽게 구축할 수 있도록 만들어졌다.&lt;/p&gt;

&lt;p&gt;OpenStack에서 사용할 기본적인 설정을 정의한 후에 설치스크립트를 이용하여 간편하게 설치가 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;environment&quot;&gt;Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OpenStack : Rokcy Release&lt;/li&gt;
  &lt;li&gt;OS : Ubuntu 18.04 LTS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;minimum-hardware-requirements&quot;&gt;Minimum hardware requirements&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Controller node
    &lt;ul&gt;
      &lt;li&gt;Processor: 1 Core&lt;/li&gt;
      &lt;li&gt;Ram: 4GB&lt;/li&gt;
      &lt;li&gt;Storage: 5GB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Compute node
    &lt;ul&gt;
      &lt;li&gt;Processor: 1 Core&lt;/li&gt;
      &lt;li&gt;Ram: 2GB&lt;/li&gt;
      &lt;li&gt;Storage: 10GB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;노드별-설치-패키지&quot;&gt;노드별 설치 패키지&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/node_packages.png&quot; alt=&quot;node_packages&quot; width=&quot;600&quot; height=&quot;280&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;다음의 설치 방법은 모든 노드가 Ubuntu 18.04 운영체제로 설치된 환경에서 진행되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-ssustack-클론&quot;&gt;1. ssustack 클론&lt;/h4&gt;

&lt;p&gt;OpenStack 환경을 구성하는 모든 노드에서 다음의 명령을 실행한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone http://git.dotstack.io/crisis513/ssustack.git
$ cd ssustack/bin
$ ./ssustack_user_creation.sh
$ cp -r &amp;lt;your_controller_path&amp;gt;/ssustack/ .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성할 유저의 패스워드를 설정하여 ssustack 유저가 생성되면 ssustack 폴더를 ssustack 유저의 홈 디렉토리로 복사한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-hosts-및-ssh-설정&quot;&gt;2. hosts 및 SSH 설정&lt;/h4&gt;

&lt;p&gt;위의 작업이 끝나면 controller node에서 hosts 및 SSH 설정한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vi /etc/hosts
10.10.10.11 controller-node
10.10.10.21 compute-node1 
10.10.10.22 compute-node2
10.10.10.23 compute-node3
    
$ cd ssustack/bin/
$ ./creating_ssh_keys.sh [&amp;lt;host_name&amp;gt; ... ]
ex) ./creating_ssh_keys.sh compute-node1 compute-node2 compute-node3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-openstack-설치-스크립트-설정&quot;&gt;3. OpenStack 설치 스크립트 설정&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ..
$ vi local.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-localconf-설정을-기반으로-각-노드별-스크립트-생성&quot;&gt;4. local.conf 설정을 기반으로 각 노드별 스크립트 생성&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./ssustack.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-ssustacktmp-경로에서-각-노드에-맞는-스크립트-실행&quot;&gt;5. ssustack/tmp 경로에서 각 노드에 맞는 스크립트 실행&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## controller-node Case
$ cd tmp/controller/
$ ./controller.sh

## compute-node1 Case
$ cd tmp/compute/
$ ./compute_1.sh
 
## compute-node2 Case
$ cd tmp/compute/
$ ./compute_2.sh
 
## compute-node3 Case
$ cd tmp/compute/
$ ./compute_3.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;현재는 각 스크립트를 직접 수정하여 rbd_secret_uuid 값을 수동으로 맞춰주어야 함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-controller-node에서-ceph-추가-설정&quot;&gt;6. controller node에서 ceph 추가 설정&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ../../bin/ # ssustack/bin/
$ ./ceph_configuration.sh [&amp;lt;host_name&amp;gt; ... ]
ex) ./ceph_configuration.sh compute-node1 compute-node2 compute-node3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-각-compute-node에서-ceph-osd-및-ceph-mon-설정&quot;&gt;7. 각 compute node에서 ceph osd 및 ceph mon 설정&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ../../bin/ # ssustack/bin/
$ ./add_ceph_osd.sh /dev/sdb    # /dev/sdb는 각 컴퓨터 노드에서 추가할 osd 장치명
$ ./add_ceph_mon.sh 10.10.10.21 # 10.10.10.21은 각 컴퓨터 노드에서 management network로 사용하는 ip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-controller-node에서-compute-호스트를-찾도록-스크립트-실행&quot;&gt;8. controller node에서 compute 호스트를 찾도록 스크립트 실행&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./add_compute_node.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 29 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/04/29/ssustack.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/04/29/ssustack.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>ssustack</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Project] naver-news-scraper</title>
        <description>&lt;h1 id=&quot;naver-news-scraper&quot;&gt;naver-news-scraper&lt;/h1&gt;

&lt;p&gt;nn-scraper 프로젝트는 원하는 키워드에 해당하는 네이버 뉴스 속보를 스크랩하여 텔레그램 봇 혹은 카카오톡 봇으로 알림받을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;environment&quot;&gt;Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OS : Ubuntu 18.04 LTS&lt;/li&gt;
  &lt;li&gt;Python : 2.7.17&lt;/li&gt;
  &lt;li&gt;pip : 9.0.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;h4 id=&quot;1-naver-news-scraper-클론&quot;&gt;1. naver-news-scraper 클론&lt;/h4&gt;

&lt;p&gt;naver-news-scraper 소스를 다운로드 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/crisis513/naver-news-scraper.git
$ cd naver-news-scraper
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-실행환경-설정&quot;&gt;2. 실행환경 설정&lt;/h4&gt;

&lt;p&gt;nn-scraper 실행을 위해 python 및 pip를 설치하고, 필요한 pip 패키지를 설치한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install -y python python-pip
$ pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-봇-설정&quot;&gt;3. 봇 설정&lt;/h4&gt;

&lt;p&gt;nn-scraper에서 사용할 수 있는 봇은 카카오톡, 텔레그램 두 종류가 있다.&lt;/p&gt;

&lt;p&gt;사용할 봇을 설정하는 방법은 다음과 같다.&lt;/p&gt;

&lt;p&gt;1) config.py 파일에서 USE_BOT 값을 카카오톡일 경우 kakaotalk, 텔레그램일 경우 telegram으로 입력한다.&lt;/p&gt;

&lt;p&gt;2) 아래 Testing images에서 선택한 플랫폼에 맞게 토큰 값을 얻어 config.py 파일에서 요구하는 토큰 혹은 키 값을 입력한다.&lt;/p&gt;

&lt;p&gt;3) app.py 파일을 실행하면 1분 주기로 SEARCH_LIST 값에 설정된 키워드에 맞는 네이버 속보 뉴스를 스크랩하여 보내준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;testing-images&quot;&gt;Testing images&lt;/h3&gt;

&lt;h4 id=&quot;telegram-bot&quot;&gt;[Telegram bot]&lt;/h4&gt;

&lt;p&gt;텔레그램 봇을 사용하기 위해서는 @botfather 를 검색하여 아래 사진과 같이 새로운 봇을 만들고 봇의 TOKEN을 획득해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/telegrambot.png&quot; alt=&quot;use_telegrambot&quot; width=&quot;360&quot; height=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에서 획득한 TOKEN 값을 config.py 파일에서 TELEGRAM_TOKEN 값에 넣어준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/telegrambot2.jpg&quot; alt=&quot;use_telegrambot&quot; width=&quot;350&quot; height=&quot;1200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;kakaotalk-bot&quot;&gt;[Kakaotalk bot]&lt;/h4&gt;

&lt;p&gt;카카오톡 봇을 사용하기 위해서는 Kakao Developer 사이트에서 카카오 API KEY를 발급 받아야 한다.&lt;/p&gt;

&lt;p&gt;https://developers.kakao.com/&lt;/p&gt;

&lt;p&gt;해당 사이트로 들어가서 로그인을 하고 애플리케이션을 만들어준다.&lt;/p&gt;

&lt;p&gt;여기서는 NN-SCRAPER 라는 앱 이름으로 생성하였고, 정상적으로 설치되면 아래 사진처럼 각종 앱 키가 보이는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/kakaotalkbot.png&quot; alt=&quot;use_kakaotalkbot&quot; width=&quot;700&quot; height=&quot;460&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 앱 키 중에서 REST API 키를 config.py 파일에서 RESTAPI_KEY 값에 넣어준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/kakaotalkbot2.png&quot; alt=&quot;use_kakaotalkbot&quot; width=&quot;360&quot; height=&quot;780&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/project/2020/04/08/nn_scraper.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/project/2020/04/08/nn_scraper.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>project</category>
        
        <category>nn-scraper</category>
        
        
        <category>Project</category>
        
      </item>
    
      <item>
        <title>[Patent] 히스토그램을 이용한 영상 처리 방법 및 이를 수행하기 위한 기록매체</title>
        <description>&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;히스토그램을 이용한 고속 유사도 측정 방법 및 이를 수행할 수 있는 유사도 측정 장치가 제공된다. 본 발명의 실사례에 따른 고속 유사도 측정 방법은 유사도 측정 대상 영상의 히스토그램을 생성하는 히스토그램 생성 단계, 상기 히스토그램을 기반으로 상기 유사도 측정 대상 영상의 이진수 열을 생성하는 메타데이터 생성 단계, 메타데이터 데이터베이스로부터 기준 영상의 이진수 열을 획득하여 상기 유사도 측정 대상 영상의 이진수 열과 매칭(matching)하는 매칭 단계 및 상기 매칭 결과를 출력하는 출력 단계를 포함한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 특허증&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;   1.1. 특허&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;   1.2. 출원번호&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;   1.3. 출원일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;   1.4. 등록일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list6&quot;&gt;   1.5. 발명의 명칭&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list7&quot;&gt;   1.6. KIPRIS 검색&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;특허증----&quot;&gt;특허증    &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h5 id=&quot;certificate-of-patent&quot;&gt;CERTIFICATE OF PATENT&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특허&quot;&gt;특허&lt;/h3&gt;
&lt;h6 id=&quot;patent-number&quot;&gt;PATENT NUMBER&lt;/h6&gt;
&lt;p&gt;10-1957610&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원번호&quot;&gt;출원번호&lt;/h3&gt;
&lt;h6 id=&quot;application-number&quot;&gt;Application Number&lt;/h6&gt;
&lt;p&gt;10-2017-0173938&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원일&quot;&gt;출원일&lt;/h3&gt;
&lt;h6 id=&quot;filing-date&quot;&gt;Filing Date&lt;/h6&gt;
&lt;p&gt;2017년 12월 18일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;등록일&quot;&gt;등록일&lt;/h3&gt;
&lt;h6 id=&quot;registration-date&quot;&gt;Registration Date&lt;/h6&gt;
&lt;p&gt;2019년 03월 06일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;발명의-명칭&quot;&gt;발명의 명칭&lt;/h3&gt;
&lt;h6 id=&quot;title-of-the-invention&quot;&gt;Title of the Invention&lt;/h6&gt;
&lt;p&gt;히스토그램을 이용한 영상 처리 방법 및 이를 수행하기 위한 기록매체&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kipris-검색&quot;&gt;KIPRIS 검색&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/patent2.png&quot; alt=&quot;patent2&quot; width=&quot;675&quot; height=&quot;150&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/research/2020/04/03/patent2.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/research/2020/04/03/patent2.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>research</category>
        
        <category>patent</category>
        
        <category>histogram</category>
        
        
        <category>Research</category>
        
      </item>
    
      <item>
        <title>[Patent] 타이핑 속도 정보를 이용한 사용자 인증 시스템 및 방법, 이를 수행하기 위한 기록매체</title>
        <description>&lt;h3 id=&quot;abstact&quot;&gt;Abstact&lt;/h3&gt;

&lt;p&gt;타이핑 속도 정보를 이용한 사용자 인증 시스템 및 방법을 개시한다. 사용자 단말로부터 수신한 ID와 패스워드를 이용하여 웹 서버에서 사용자 인증을 수행하는 사용자 인증 시스템에 있어서, 상기 사용자 단말은, 사용자로부터 ID 및 패스워드를 입력받는 입력부; 상기 입력부를 통해 패스워드를 입력받을 때, 패스워드를 구성하는 각각의 문자에 대해 키 입력이 시작되는 시간 및 키 입력이 종료되는 시간, 마지막 엔터키가 입력되는 시간을 감지하여 키 입력 정보를 생성하는 키 입력 정보 생성부; 및 상기 입력부를 통해 입력받은 ID 및 패스워드와 상기 키 입력 정보 생성부에서 생성된 키 입력 정보를 상기 웹 서버로 전송하는 전송부;를 포함하고, 상기 웹 서버는, 상기 사용자 단말로부터 ID 및 패스워드와 키 입력 정보를 수신하는 수신부; 사용자별로 사용자 인증에 필요한 ID 및 패스워드와 타이핑 속도 허용 범위를 저장하는 사용자 인증 DB; 상기 수신한 키 입력 정보를 이용하여 패스워드를 구성하는 문자열의 입력에 대한 타이핑 속도를 산출하는 타이핑 속도 산출부; 상기 수신한 ID 및 패스워드와 상기 사용자 인증 DB에 저장되어 있는 ID 및 패스워드를 비교하여 사용자 인증을 수행하는 제1사용자 인증부; 및 상기 제1사용자 인증부에서 사용자 인증에 성공하면, 상기 산출된 타이핑 속도와 상기 ID에 매핑되어 상기 사용자 인증 DB에 저장되어 있는 타이핑 속도 허용 범위를 비교하여 사용자 인증을 수행하는 제2사용자 인증부;를 포함하는 것이 바람직하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 특허증&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;   1.1. 특허&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;   1.2. 출원번호&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;   1.3. 출원일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;   1.4. 등록일&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list6&quot;&gt;   1.5. 발명의 명칭&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list7&quot;&gt;   1.6. KIPRIS 검색&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;특허증----&quot;&gt;특허증    &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h5 id=&quot;certificate-of-patent&quot;&gt;CERTIFICATE OF PATENT&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특허----&quot;&gt;특허    &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;patent-number&quot;&gt;PATENT NUMBER&lt;/h6&gt;
&lt;p&gt;10-1959219&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원번호----&quot;&gt;출원번호    &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;application-number&quot;&gt;Application Number&lt;/h6&gt;
&lt;p&gt;10-2017-0120224&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;출원일--&quot;&gt;출원일  &lt;a name=&quot;list4&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;filing-date&quot;&gt;Filing Date&lt;/h6&gt;
&lt;p&gt;2017년 09월 19일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;등록일--&quot;&gt;등록일  &lt;a name=&quot;list5&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;registration-date&quot;&gt;Registration Date&lt;/h6&gt;
&lt;p&gt;2019년 03월 12일&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;발명의-명칭-&quot;&gt;발명의 명칭 &lt;a name=&quot;list6&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h6 id=&quot;title-of-the-invention&quot;&gt;Title of the Invention&lt;/h6&gt;
&lt;p&gt;타이핑 속도 정보를 이용한 사용자 인증 시스템 및 방법, 이를 수행하기 위한 기록매체&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kipris-검색-&quot;&gt;KIPRIS 검색 &lt;a name=&quot;list7&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/landing/patent.png&quot; alt=&quot;patent1&quot; width=&quot;675&quot; height=&quot;150&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/research/2020/04/03/patent1.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/research/2020/04/03/patent1.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>research</category>
        
        <category>patent</category>
        
        <category>authentication</category>
        
        <category>tps</category>
        
        
        <category>Research</category>
        
      </item>
    
      <item>
        <title>[Thesis] 클라우드 컴퓨팅 환경에서 블록체인 기반의 인증 키 관리 시스템 설계 및 구현</title>
        <description>&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;클라우드 컴퓨팅은 컴퓨팅 자원을 유연하게 사용할 수 있어 프로비저닝이 빠르고 편리하며 확장성이 높은 등 많은 장점을 제공하고 있다. 하지만 해킹을 통한 중요 데이터가 유출되는 사고가 발생한 사례들이 많아 클라우드 보안 위협은 꾸준히 제기되고 있다. 그 중에서도 클라우드 인증에 사용되는 토큰과 이 토큰의 정보를 보호하기 위해 사용되는 암호 키를 관리하는 것은 보안에 있어 항상 중요한 문제이다. 암호 키가 재대로 관리되지 않으면 무단 접근을 허용하여 조직 혹은 사용자에게 심각한 피해가 생기게 된다. 보안 강도가 높은 암호화 알고리즘을 사용하더라도 키가 노출된다면 자유롭게 데이터를 복호화할 수 있게 되기 때문에 키 관리는 매우 중요하다. 기존에는 대부분 중앙집중식으로 키를 관리하여 확장성이 낮고 분산된 키 관리 서비스를 제공하지 않아 항상 잠재적인 단일 장애점의 문제를 갖고 있다. 그리고 키 보안 공급 업체를 통해 암호 키를 관리하더라도 단일 보안 위반 상태가 된다.&lt;/p&gt;

&lt;p&gt;본 논문에서는 프라이빗 블록체인을 구축하여 허가형 비공개 네트워크에서 안전하게 암호 키를 분산 저장 및 관리하는 환경을 통해 클라우드 컴퓨팅 인증을 수행하는 시스템을 제안한다. 제안하는 시스템은 기존에 항상 잠재적으로 존재해왔던 단일 장애점의 문제를 해결하고 분산 저장을 통해 확장성을 높일 수 있다. 제안하는 시스템을 구현한 결과 기존의 키 관리 방식에 비해 성능에 큰 차이가 없고 기본적인 키 관리 요구사항들을 충족시키면서 단일 장애점의 문제를 해결했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 논문 제목&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;   1.1. 저자&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;   1.2. 발행연도&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;   1.3. 주제어&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;   1.4. URL&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;논문-제목---&quot;&gt;논문 제목   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;클라우드 컴퓨팅 환경에서 블록체인 기반의 인증 키 관리 시스템 설계 및 구현 = Design and Implementation of Blockchain-based Authentication Key Management System in Cloud Computing Environment&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;저자----&quot;&gt;저자    &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;손한기&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;발행연도----&quot;&gt;발행연도    &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;2020.02&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;주제어----&quot;&gt;주제어    &lt;a name=&quot;list4&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;클라우드 컴퓨팅, 블록체인, 키 관리 시스템&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;url---&quot;&gt;URL   &lt;a name=&quot;list5&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;http://www.riss.kr/search/detail/DetailView.do?p_mat_type=be54d9b8bc7cdb09&amp;amp;control_no=648f5d72e457c232ffe0bdc3ef48d419&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/research/2020/04/01/bkms.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/research/2020/04/01/bkms.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>research</category>
        
        <category>thesis</category>
        
        <category>bkms</category>
        
        <category>blockchain</category>
        
        <category>cloud</category>
        
        
        <category>Research</category>
        
      </item>
    
      <item>
        <title>[Sample] title</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;본 포스트는 작성 중입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. A&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_1&quot;&gt;   1.1. a&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list1_2&quot;&gt;   1.2. b&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-a---&quot;&gt;&lt;span style=&quot;color:purple&quot;&gt;&lt;strong&gt;1. A&lt;/strong&gt;&lt;/span&gt;   &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;a&lt;/strong&gt;   &lt;a name=&quot;list1_1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;a 내용 입력&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;b&lt;/strong&gt;   &lt;a name=&quot;list1_2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;b 내용 입력&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Mar 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/sample/2020/03/08/sample2.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/sample/2020/03/08/sample2.html</guid>
        
        <category>son</category>
        
        <category>blog</category>
        
        <category>sample</category>
        
        
        <category>Sample</category>
        
      </item>
    
      <item>
        <title>Blog sample</title>
        <description>&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#list1&quot;&gt;1. 헤더(Header)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list2&quot;&gt;2. 목록(List)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list3&quot;&gt;3. 이미지(Images)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list4&quot;&gt;4. 하이퍼링크(Links)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list5&quot;&gt;5. 인용 상자(Blockquotes)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list6&quot;&gt;6. 강조(Emphasis)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list7&quot;&gt;7. 테이블(Tables)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list8&quot;&gt;8. 체크 박스(Task Lists)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list9&quot;&gt;9. 인라인 코드(Inline code)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list10&quot;&gt;10. 수평선(hr)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list11&quot;&gt;11. 탈출 문자(Backslash Escapes)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list12&quot;&gt;12. 이모지(Emoji)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list13&quot;&gt;13. 코드 블록(Code Blocks)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#list14&quot;&gt;14. 배지(Badge) 만들기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;헤더header----&quot;&gt;헤더(Header)    &lt;a name=&quot;list1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;h1 id=&quot;헤더-크기-h1&quot;&gt;헤더 크기 (h1)&lt;/h1&gt;
&lt;h2 id=&quot;헤더-크기-h2&quot;&gt;헤더 크기 (h2)&lt;/h2&gt;
&lt;h3 id=&quot;헤더-크기-h3&quot;&gt;헤더 크기 (h3)&lt;/h3&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;목록list----&quot;&gt;목록(List)    &lt;a name=&quot;list2&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Unordered&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2
    &lt;ul&gt;
      &lt;li&gt;Item 2a&lt;/li&gt;
      &lt;li&gt;Item 2b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ordered&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3
    &lt;ol&gt;
      &lt;li&gt;Item 3a&lt;/li&gt;
      &lt;li&gt;Item 3b&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;이미지images----&quot;&gt;이미지(Images)    &lt;a name=&quot;list3&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;첫번째 방법&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/markdown_logo.jpg&quot; alt=&quot;Github logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Format: &lt;img src=&quot;url 링크&quot; alt=&quot;이미지 alt명&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두번째 방법&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;https://github.com/..각자절대경로../images/markdown_syntax.jpg&quot; width=&quot;400px&quot; alt=&quot;sample image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Format: img 태그 사용 - 이미지경로는 상대경로 or 절대경로&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;하이퍼링크links----&quot;&gt;하이퍼링크(Links)    &lt;a name=&quot;list4&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;깃허브&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;인용-상자blockquotes----&quot;&gt;인용 상자(Blockquotes)    &lt;a name=&quot;list5&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As Grace Hopper said:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’ve always been more interested. 
in the future than in the past.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;강조emphasis----&quot;&gt;강조(Emphasis)    &lt;a name=&quot;list6&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;This text will be italic&lt;/em&gt; 
&lt;em&gt;This will also be italic&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This text will be bold&lt;/strong&gt; 
&lt;strong&gt;This will also be bold&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;You &lt;strong&gt;can&lt;/strong&gt; combine them&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;테이블tables----&quot;&gt;테이블(Tables)    &lt;a name=&quot;list7&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;First Header&lt;/th&gt;
      &lt;th&gt;Second Header&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Content cell 1&lt;/td&gt;
      &lt;td&gt;Content cell 2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content column 1&lt;/td&gt;
      &lt;td&gt;Content column 2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;체크-박스task-lists----&quot;&gt;체크 박스(Task Lists)    &lt;a name=&quot;list8&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;this is a complete item&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;this is an incomplete item&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;@mentions, #refs, &lt;a href=&quot;&quot;&gt;links&lt;/a&gt;, &lt;strong&gt;formatting&lt;/strong&gt;, and &lt;del&gt;tags&lt;/del&gt; supported&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;list syntax required (any unordered or ordered list supported)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;인라인-코드inline-code----&quot;&gt;인라인 코드(Inline code)    &lt;a name=&quot;list9&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;문단 중간에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code&lt;/code&gt;를 넣을 수 있습니다. 
예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf(&quot;hello world!&quot;);&lt;/code&gt; 이런 식으로 들어갑니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;수평선hr----&quot;&gt;수평선(hr)    &lt;a name=&quot;list10&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;탈출-문자backslash-escapes----&quot;&gt;탈출 문자(Backslash Escapes)    &lt;a name=&quot;list11&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;＼&lt;em&gt;literal asterisks＼&lt;/em&gt; 
&lt;em&gt;literal asterisks&lt;/em&gt; 
&lt;strong&gt;＼&lt;em&gt;＼&lt;/em&gt;Text＼&lt;em&gt;＼&lt;/em&gt;&lt;/strong&gt; 
_＼_Tom＼__&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;이모지emoji----&quot;&gt;이모지(Emoji)    &lt;a name=&quot;list12&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;GitHub supports emoji!&lt;/p&gt;

&lt;p&gt;:+1: :sparkles: :camel: :tada: 
:rocket: :metal: :octocat:&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;코드-블록code-blocks----&quot;&gt;코드 블록(Code Blocks)    &lt;a name=&quot;list13&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;코드 내용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;배지bedge-만들기----&quot;&gt;배지(Bedge) 만들기    &lt;a name=&quot;list14&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;https://shields.io&lt;/p&gt;

&lt;p&gt;작성 예시
&lt;a href=&quot;https://img.shields.io/badge/license-mit-green.svg&amp;quot;&quot;&gt;https://img.shields.io/badge/license-mit-green.svg&quot;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;https://img.shields.io/badge/–.svg&lt;/p&gt;

&lt;p&gt;APM: /apm/l/:packageName.svg&lt;/p&gt;

&lt;p&gt;AUR license: /aur/license/:packageName.svg&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Mar 2020 00:00:00 +0900</pubDate>
        <link>http://192.168.116.128:4000/sample/2020/03/07/sample.html</link>
        <guid isPermaLink="true">http://192.168.116.128:4000/sample/2020/03/07/sample.html</guid>
        
        <category>Son</category>
        
        <category>blog</category>
        
        
        <category>Sample</category>
        
      </item>
    
  </channel>
</rss>
